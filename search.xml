<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[spring进阶篇(IOC[注解方式]/spring AOP)]]></title>
    <url>%2F2018%2F12%2F24%2Fspring2%2F</url>
    <content type="text"><![CDATA[Spring框架的学习路线 1. Spring入门篇：Spring的IOC容器之XML的方式，Spring框架与Web项目整合 2. Spring进阶篇：Spring的IOC容器之注解的方式，Spring的AOP技术 3. Spring高级篇：Spring的事务管理、Spring框架的JDBC模板 本篇内容概述 一. Spring框架的IOC基于注解的方式 二. Spring框架整合JUnit单元测试 三. AOP的概述 四. AOP的底层实现原理（了解） 五. AOP功能基于AspectJ的配置文件方式 一.Spring框架的IOC功能之注解的方式1.Spring框架的IOC之注解方式的快速入门1. 步骤一：导入注解开发所有需要的jar包 * 引入IOC容器必须的6个jar包 * 多引入一个：Spring框架的AOP的jar包，spring-aop的jar包 2. 步骤二：创建对应的包结构，编写Java的类 * UserService -- 接口 * UserServiceImpl -- 具体的实现类 3. 步骤三：在src的目录下，创建applicationContext.xml的配置文件，然后引入约束。注意：因为现在想使用注解的方式，那么引入的约束发生了变化 * 需要引入context的约束，具体的约束如下 &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- bean definitions here --&gt; &lt;/beans&gt; 4. 步骤四：在applicationContext.xml配置文件中开启组件扫描 * Spring的注解开发:组件扫描 &lt;context:component-scan base-package=&quot;com.itheima.demo1&quot;/&gt; * 注意：可以采用如下配置 &lt;context:component-scan base-package=&quot;com.itheima&quot;/&gt; 这样是扫描com.itheima包下所有的内容 5. 步骤五：在UserServiceImpl的实现类上添加注解 * @Component(value=&quot;userService&quot;) -- 相当于在XML的配置方式中 &lt;bean id=&quot;userService&quot; class=&quot;...&quot;&gt; 6. 步骤六：编写测试代码 public class SpringDemo1 { @Test public void run1(){ ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserService us = (UserService) ac.getBean(&quot;userService&quot;); us.save(); } } 2.Spring框架中Bean管理的常用注解1. @Component:组件.(作用在类上) 2. Spring中提供@Component的三个衍生注解:(功能目前来讲是一致的) * @Controller -- 作用在WEB层 * @Service -- 作用在业务层 * @Repository -- 作用在持久层 * 说明：这三个注解是为了让标注类本身的用途清晰，Spring在后续版本会对其增强 3. 属性注入的注解(说明：使用注解注入的方式,可以不用提供set方法) * 如果是注入的普通类型，可以使用value注解 * @Value -- 用于注入普通类型 * 如果注入的是对象类型，使用如下注解 * @Autowired -- 默认按类型进行自动装配 * 如果想按名称注入 * @Qualifier -- 强制使用名称注入 * @Resource -- 相当于@Autowired和@Qualifier一起使用 * 强调：Java提供的注解 * 属性使用name属性 3.Bean的作用范围和生命周期的注解1. Bean的作用范围注解(同 xml IOC开发： &lt;bean id=&quot;&quot;,class=&quot;&quot;, scope=&quot;&quot;&gt;) * 注解为@Scope(value=&quot;prototype&quot;)，作用在类上。值如下： * singleton -- 单例，默认值 * prototype -- 多例 2. Bean的生命周期的配置（了解） * 注解如下： * @PostConstruct -- 相当于init-method * @PreDestroy -- 相当于destroy-method 二.Spring框架整合JUnit单元测试1. 为了简化了JUnit的测试，使用Spring框架也可以整合测试 2. 具体步骤 * 要求：必须先有JUnit的环境（即已经导入了JUnit4的开发环境）！！ * 步骤一：在程序中引入:spring-test.jar * 步骤二：在具体的测试类上添加注解 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) public class SpringDemo1 { @Resource(name=&quot;userService&quot;) private UserService userService; @Test public void demo2(){ userService.save(); } } 三.AOP的概述1. 什么是AOP的技术？ * 在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程 * AOP是一种编程范式，隶属于软工范畴，指导开发者如何组织程序结构 * AOP最早由AOP联盟的组织提出的,制定了一套规范.Spring将AOP思想引入到框架中,必须遵守AOP联盟的规范 * 通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术 * AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型 * 利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率 2. AOP:面向切面编程.(思想.---解决OOP遇到一些问题) 3. AOP采取横向抽取机制，取代了传统纵向继承体系重复性代码（性能监视、事务管理、安全检查、缓存） 4. 为什么要学习AOP * 可以在不修改源代码的前提下，对程序进行增强！！ 四.Spring框架的AOP的底层实现1.基本概述1. Srping框架的AOP技术底层也是采用的代理技术，代理的方式提供了两种 1. 基于JDK的动态代理 * 必须是面向接口的，只有实现了具体接口的类才能生成代理对象 2. 基于CGLIB动态代理 * 对于没有实现了接口的类，也可以产生代理，产生这个类的子类的方式 2. Spring的传统AOP中根据类是否实现接口，来采用不同的代理方式 1. 如果实现类接口，使用JDK动态代理完成AOP 2. 如果没有实现接口，采用CGLIB动态代理完成AOP 2.JDK的动态代理（代码了解，理解原理）1. 使用Proxy类来生成代理对象的一些代码如下： /** * 使用JDK的方式生成代理对象 * @author Administrator */ public class MyProxyUtils { public static UserDao getProxy(final UserDao dao) { // 使用Proxy类生成代理对象 UserDao proxy = (UserDao) Proxy.newProxyInstance(dao.getClass().getClassLoader(), dao.getClass().getInterfaces(), new InvocationHandler() { // 代理对象方法一直线，invoke方法就会执行一次 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { if(&quot;save&quot;.equals(method.getName())){ System.out.println(&quot;记录日志...&quot;); // 开启事务 } // 提交事务 // 让dao类的save或者update方法正常的执行下去 return method.invoke(dao, args); } }); // 返回代理对象 return proxy; } } 3.CGLIB的代理技术（代码了解）1. 引入CBLIB的开发包 * 如果想使用CGLIB的技术来生成代理对象，那么需要引入CGLIB的开发的jar包，在Spring框架核心包中已经引入了CGLIB的开发包了。所以直接引入Spring核心开发包即可！ 2. 编写相关的代码 public static OrderDaoImpl getProxy(){ // 创建CGLIB核心的类 Enhancer enhancer = new Enhancer(); // 设置父类 enhancer.setSuperclass(OrderDaoImpl.class); // 设置回调函数 enhancer.setCallback(new MethodInterceptor() { @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy methodProxy) throws Throwable { if(&quot;save&quot;.equals(method.getName())){ // 记录日志 System.out.println(&quot;记录日志了...&quot;); } return methodProxy.invokeSuper(obj, args); } }); // 生成代理对象 OrderDaoImpl proxy = (OrderDaoImpl) enhancer.create(); return proxy; } 五.Spring基于AspectJ的AOP的开发1.技术分析之AOP的相关术语1. Joinpoint(连接点) -- 所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法,因为spring只支持方法类型的连接点 2. Pointcut(切入点) -- 所谓切入点是指我们要对哪些Joinpoint进行拦截的定义 3. Advice(通知/增强) -- 所谓通知是指拦截到Joinpoint之后所要做的事情就是通知.通知分为前置通知,后置通知,异常通知,最终通知,环绕通知(切面要完成的功能) 4. Introduction(引介) -- 引介是一种特殊的通知在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或Field 5. Target(目标对象) -- 代理的目标对象 6. Weaving(织入) -- 是指把增强应用到目标对象来创建新的代理对象的过程 7. Proxy（代理） -- 一个类被AOP织入增强后，就产生一个结果代理类 8. Aspect(切面) -- 是切入点和通知的结合，以后咱们自己来编写和配置的 2.技术分析之AspectJ的XML方式完成AOP的开发1. 步骤一：创建JavaWEB项目，引入具体的开发的jar包 * 先引入Spring框架开发的基本开发包 * 再引入Spring框架的AOP的开发包 * spring的传统AOP的开发的包 * spring-aop-4.2.4.RELEASE.jar * com.springsource.org.aopalliance-1.0.0.jar * aspectJ的开发包 * com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar * spring-aspects-4.2.4.RELEASE.jar 2. 步骤二：创建Spring的配置文件，引入具体的AOP的schema约束 &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; 3. 步骤三：创建包结构，编写具体的接口和实现类 * com.itheima.demo2 * CustomerDao -- 接口 * CustomerDaoImpl -- 实现类 4. 步骤四：将目标类配置到Spring中 &lt;bean id=&quot;customerDao&quot; class=&quot;com.itheima.demo3.CustomerDaoImpl&quot;/&gt; 5. 步骤五：定义切面类 public class MyAspectXml { // 定义通知 public void log(){ System.out.println(&quot;记录日志...&quot;); } } 6. 步骤六：在配置文件中定义切面类 &lt;bean id=&quot;myAspectXml&quot; class=&quot;com.itheima.demo3.MyAspectXml&quot;/&gt; 7. 步骤七：在配置文件中完成aop的配置 &lt;aop:config&gt; &lt;!-- 引入切面类 --&gt; &lt;aop:aspect ref=&quot;myAspectXml&quot;&gt; &lt;!-- 定义通知类型：切面类的方法和切入点的表达式 --&gt; &lt;aop:before method=&quot;log&quot; pointcut=&quot;execution(public * com.itheima.demo3.CustomerDaoImpl.save(..))&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 8. 完成测试 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) public class Demo3 { @Resource(name=&quot;customerDao&quot;) private CustomerDao customerDao; @Test public void run1(){ customerDao.save(); customerDao.update(); customerDao.delete(); } } 3.切入点的表达式1. 再配置切入点的时候，需要定义表达式，重点的格式如下：execution(public * *(..))，具体展开如下： * 切入点表达式的格式如下： * execution([修饰符] 返回值类型 包名.类名.方法名(参数)) * 修饰符可以省略不写，不是必须要出现的。 * 返回值类型是不能省略不写的，根据你的方法来编写返回值。可以使用 * 代替。 * 包名例如：com.itheima.demo3.BookDaoImpl * 首先com是不能省略不写的，但是可以使用 * 代替 * 中间的包名可以使用 * 号代替 * 如果想省略中间的包名可以使用 .. * 类名也可以使用 * 号代替，也有类似的写法：*DaoImpl * 方法也可以使用 * 号代替 * 参数如果是一个参数可以使用 * 号代替，如果想代表任意参数使用 .. 4.AOP的通知类型1. 前置通知 * 在目标类的方法执行之前执行。 * 配置文件信息：&lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;myPointcut3&quot;/&gt; * 应用：可以对方法的参数来做校验 2. 最终通知 * 在目标类的方法执行之后执行，如果程序出现了异常，最终通知也会执行。 * 在配置文件中编写具体的配置：&lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;myPointcut3&quot;/&gt; * 应用：例如像释放资源 3. 后置通知 * 方法正常执行后的通知。 * 在配置文件中编写具体的配置：&lt;aop:after-returning method=&quot;afterReturning&quot; pointcut-ref=&quot;myPointcut2&quot;/&gt; * 应用：可以修改方法的返回值 4. 异常抛出通知 * 在抛出异常后通知 * 在配置文件中编写具体的配置：&lt;aop:after-throwing method=&quot;afterThorwing&quot; pointcut-ref=&quot;myPointcut3&quot;/&gt; * 应用：包装异常的信息 5. 环绕通知 * 方法的执行前后执行。 * 在配置文件中编写具体的配置：&lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;myPointcut2&quot;/&gt; * 要注意：目标的方法默认不执行，需要使用ProceedingJoinPoint对来让目标对象的方法执行。]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>spring进阶篇</tag>
        <tag>spring IOC（控制反转[注解方式]）</tag>
        <tag>spring AOP（面向切面）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux基础]]></title>
    <url>%2F2018%2F12%2F24%2Flinux1%2F</url>
    <content type="text"><![CDATA[一.Linux的概述：1.什么是Linux：1.学习Linux之前先了解UnixUnix是一个强大的多用户、多任务操作系统。于1969年在AT&amp;T的贝尔实验室开发。UNIX的商标权由国际开放标准组织（The Open Group）所拥有。UNIX操作系统是商业版，需要收费，价格比Microsoft Windows正版要贵一些。 2.Linux的概述：Linux是基于Unix的Linux是一种自由和开放源码的操作系统，存在着许多不同的Linux版本，但它们都使用了Linux内核。Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、台式计算机 诞生于1991 年10 月5 日。是由芬兰赫尔辛基大学学生Linus Torvalds和后来加入的众多爱好者共同开发完成 3.Linux的历史：Linux最初是由芬兰赫尔辛基大学学生Linus Torvalds由于自己不满意教学中使用的MINIX操作系统， 所以在1990年底由于个人爱好设计出了LINUX系统核心。后来发布于芬兰最大的ftp服务器上，用户可以免费下载，所以它的周边的程序越来越多，Linux本身也逐渐发展壮大起来，之后Linux在不到三年的时间里成为了一个功能完善，稳定可靠的操作系统. 4.Linux系统的应用：服务器系统Web应用服务器、数据库服务器、接口服务器、DNS、FTP等等；嵌入式系统路由器、防火墙、手机、PDA、IP 分享器、交换器、家电用品的微电脑控制器等等，高性能运算、计算密集型应用Linux有强大的运算能力。桌面应用系统移动手持系统 5.Linux的版本Linux的版本分为两种：内核版本和发行版本；内核版本是指在Linus领导下的内核小组开发维护的系统内核的版本号 ；发行版本是一些组织和公司根据自己发行版的不同而自定的 ； 6.Linux的主流版本 二.Linux的安装：1.虚拟机安装：1.什么是虚拟机虚拟机：一台虚拟的电脑. 虚拟机软件: * VmWare :收费的. * VirtualBox :免费的. 2.安装1.安装VmWare 参考《虚拟软件vmware安装.doc》 2.CentOS的安装 参考《CentOS6详细安装文档.doc》 3Linux的目录结构： root管理员的home目录root其他用户的home目录home目录中 三.Linux的常用命令1.切换目录命令cd：使用 cd app 切换到app目录 cd .. 切换到上一层目录 cd / 切换到系统根目录 cd ~ 切换到用户主目录 cd - 切换到上一个所在目录 2.列出文件列表：ls ll dir(*)ls(list)是一个非常有用的命令，用来显示当前目录下的内容。配合参数的使用，能以不同的方式显示目录内容。 格式：ls[参数] [路径或文件名] 常用：在linux中以 . 开头的文件都是隐藏的文件 * ls * ls -a 显示所有文件或目录（包含隐藏的文件） * ls -l 缩写成ll 3.创建目录和移除目录：mkdir rmdirmkdir(make directory)命令可用来创建子目录。 mkdir app  在当前目录下创建app目录 mkdir –p app2/test  级联创建aap2以及test目 rmdir(remove directory)命令可用来删除“空”的子目录： rmdir app  删除app目录 4.浏览文件【cat、more、less、tail】 1.cat用于显示文件的内容。 格式：cat[参数]&lt;文件名&gt; * cat yum.conf 2.more一般用于要显示的内容会超过一个画面长度的情况。按空格键显示下一个画面。 回车显示下一行内容。 按 q 键退出查看。 * more yum.conf * 空格显示下一页数据 回车显示下一行的数据 3.less用法和more类似，不同的是less可以通过PgUp、PgDn键来控制。 * less yum.conf * PgUp 和 PgDn 进行上下翻页. 4.tail命令是在实际使用过程中使用非常多的一个命令，它的功能是：用于显示文件后几行的内容。 用法: tail -10 /etc/passwd  查看后10行数据 tail -f catalina.log  动态查看日志(*****) 5.ctrl+c 结束查看 5.文件操作：1.【rm】rm 删除文件 用法：rm [选项]... 文件... rm a.txt  删除a.txt文件 删除需要用户确认，y/n rm 删除不询问 rm -f a.txt  不询问，直接删除 rm 删除目录 rm -r a  递归删除 不询问递归删除（慎用） rm -rf a  不询问递归删除 rm -rf *  删除所有文件 rm -rf /*  自杀 2.【cp、mv】cp(copy)命令可以将文件从一处复制到另一处。一般在使用cp命令时将一个文件复制成另一个文件或复制到某目录时，需要指定源文件名与目标文件名或目录。 cp a.txt b.txt  将a.txt复制为b.txt文件 cp a.txt ../  将a.txt文件复制到上一层目录中 mv 移动或者重命名 mv a.txt ../  将a.txt文件移动到上一层目录中 mv a.txt b.txt  将a.txt文件重命名为b.txt 3.【tar】命令:(* 打包或解压)tar命令位于/bin目录下，它能够将用户所指定的文件或目录打包成一个文件，但不做压缩。一般Linux上常用的压缩方式是选用tar将许多文件打包成一个文件，再以gzip压缩命令压缩成xxx.tar.gz(或称为xxx.tgz)的文件。 常用参数： -c：创建一个新tar文件 -v：显示运行过程的信息 -f：指定文件名 -z：调用gzip压缩命令进行压缩 -t：查看压缩文件的内容 -x：解开tar文件 打包： tar –cvf xxx.tar ./* 打包并且压缩： tar –zcvf xxx.tar.gz ./* 解压 tar –xvf xxx.tar tar -xvf xxx.tar.gz -C /usr/aaa 4.【grep】命令查找符合条件的字符串。 用法: grep [选项]... PATTERN [FILE]... 示例： grep lang anaconda-ks.cfg 在文件中查找lang grep lang anaconda-ks.cfg –color 高亮显示 6.其他常用命令1.【pwd】 显示当前所在目录 2.【touch】 创建一个空文件 * touch a.txt 3.【ll -h】 友好显示文件大小 4.【wget】 下载资料 * wget http://nginx.org/download/nginx-1.9.12.tar.gz 四.Vi和Vim编辑器1.Vim编辑器：在Linux下一般使用vi编辑器来编辑文件。 vi既可以查看文件也可以编辑文件。 三种模式：命令行、插入、底行模式。 切换到命令行模式：按Esc键； 切换到插入模式：按 i 、o、a键； i 在当前位置生前插入 I 在当前行首插入 a 在当前位置后插入 A 在当前行尾插入 o 在当前行之后插入一行 O 在当前行之前插入一行 切换到底行模式：按 :（冒号）； 更多详细用法，查询文档《Vim命令合集.docx》和《vi使用方法详细介绍.docx》 打开文件：vim file 退出：esc :q 修改文件：输入i进入插入模式 保存并退出：esc:wq 不保存退出：esc:q! 3中进入插入模式： i:在当前的光标所在处插入 o:在当前光标所在的行的下一行插入 a:在光标所在的下一个字符插入 快捷键： dd – 快速删除一行 R – 替换 2.重定向输出&gt;和&gt;&gt;&gt; 重定向输出，覆盖原有内容； &gt;&gt; 重定向输出，又追加功能； 示例： cat /etc/passwd &gt; a.txt 将输出定向到a.txt中 cat /etc/passwd &gt;&gt; a.txt 输出并且追加 ifconfig &gt; ifconfig.txt 3.管道 |管道是Linux命令中重要的一个概念，其作用是将一个命令的输出用作另一个命令的输入。 示例 ls --help | more 分页查询帮助信息 ps –ef | grep java 查询名称中包含java的进程 ifconfig | more cat index.html | more ps –ef | grep aio 4.&amp;&amp;命令执行控制：命令之间使用 &amp;&amp; 连接，实现逻辑与的功能。 只有在 &amp;&amp; 左边的命令返回真（命令返回值 $? == 0），&amp;&amp; 右边的命令才会被执行。 只要有一个命令返回假（命令返回值 $? == 1），后面的命令就不会被执行。 mkdir test &amp;&amp; cd test 5.网络通讯命令ifconfig 显示或设置网络设备。 ifconfig 显示网络设备 ifconfig eth0 up 启用eth0网卡 ifconfig eth0 down 停用eth0网卡 ping 探测网络是否通畅。 ping 192.168.0.1 netstat 查看网络端口。 netstat -an | grep 3306 查询3306端口占用情况 6.系统管理命令date 显示或设置系统时间 date 显示当前系统时间 date -s “2014-01-01 10:10:10“ 设置系统时间 df 显示磁盘信息 df –h 友好显示大小 free 显示内存状态 free –m 以mb单位显示内存组昂头 top 显示，管理执行中的程序 clear 清屏幕 ps 正在运行的某个进程的状态 ps –ef 查看所有进程 ps –ef | grep ssh 查找某一进程 kill 杀掉某一进程 kill 2868 杀掉2868编号的进程 kill -9 2868 强制杀死进程 du 显示目录或文件的大小。 du –h 显示当前目录的大小 who 显示目前登入系统的用户信息。 hostname 查看当前主机名 修改：vi /etc/sysconfig/network uname 显示系统信息。 uname -a 显示本机详细信息。 依次为：内核名称(类别)，主机名，内核版本号，内核版本，内核编译日期，硬件名，处理器类型，硬件平台类型，操作系统名称 五.Linux的用户和组1.用户的管理useradd 添加一个用户 useradd test 添加test用户 useradd test -d /home/t1 指定用户home目录 passwd 设置、修改密码 passwd test 为test用户设置密码 切换登录： ssh -l test -p 22 192.168.19.128 su – 用户名 userdel 删除一个用户 userdel test 删除test用户(不会删除home目录) userdel –r test 删除用户以及home目录 2.组管理：当在创建一个新用户user时，若没有指定他所属于的组，就建立一个和该用户同名的私有组 创建用户时也可以指定所在组 groupadd 创建组 groupadd public 创建一个名为public的组 useradd u1 –g public 创建用户指定组 groupdel 删除组，如果该组有用户成员，必须先删除用户才能删除组。 groupdel public 3.id，su命令【id命令】 功能：查看一个用户的UID和GID 用法：id [选项]... [用户名] 直接使用id 直接使用id 用户名 【su命令】 功能：切换用户。 用法：su [选项]... [-] [用户 [参数]... ] 示例： su - u1 切换到u1用户，并且将环境也切换到u1用户的环境（推荐使用） 【账户文件】 /etc/passwd 用户文件 /etc/shadow 密码文件 /etc/group 组信息文件 【用户文件】 root:x:0:0:root:/root:/bin/bash 账号名称： 在系统中是唯一的 用户密码： 此字段存放加密口令 用户标识码(User ID)： 系统内部用它来标示用户 组标识码(Group ID)： 系统内部用它来标识用户属性 用户相关信息： 例如用户全名等 用户目录： 用户登录系统后所进入的目录 用户环境: 用户工作的环境 【密码文件】 shadow文件中每条记录用冒号间隔的9个字段组成. 用户名：用户登录到系统时使用的名字，而且是惟一的 口令： 存放加密的口令 最后一次修改时间: 标识从某一时刻起到用户最后一次修改时间 最大时间间隔: 口令保持有效的最大天数，即多少天后必须修改口令 最小时间间隔： 再次修改口令之间的最小天数 警告时间：从系统开始警告到口令正式失效的天数 不活动时间： 口令过期少天后，该账号被禁用 失效时间：指示口令失效的绝对天数(从1970年1月1日开始计算) 标志：未使用 【组文件】 root:x:0: 组名：用户所属组 组口令：一般不用 GID：组ID 用户列表：属于该组的所有用户 六.Linux的权限命令1.文件权限 2.Linux三种文件类型：1.普通文件： 包括文本文件、数据文件、可执行的二进制程序文件等。 2.目录文件： Linux系统把目录看成是一种特殊的文件，利用它构成文件系统的树型结构。 3.设备文件： Linux系统把每一个设备都看成是一个文件 3.文件类型标识普通文件（-） 目录（d） 符号链接（l） 进入etc可以查看，相当于快捷方式 字符设备文件（c） 块设备文件（s） 套接字（s） 命名管道（p） 4.文件权限管理：chmod 变更文件或目录的权限。 chmod 755 a.txt chmod u=rwx,g=rx,o=rx a.txt chmod 000 a.txt / chmod 777 a.txt chown 变更文件或目录改文件所属用户和组 chown u1:public a.txt ：变更当前的目录或文件的所属用户和组 chown -R u1:public dir ：变更目录中的所有的子目录及文件的所属用户和组]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>linux 基础篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring入门篇(IOC[配置文件方式]/spring整合基础web)]]></title>
    <url>%2F2018%2F12%2F23%2Fspring1%2F</url>
    <content type="text"><![CDATA[Spring框架的学习路线 1. Spring入门篇：Spring的IOC容器之XML的方式，Spring框架与Web项目整合 2. Spring进阶：Spring的IOC容器之注解的方式，Spring的AOP技术 3. Spring高级：Spring的事务管理、Spring框架的JDBC模板 本篇内容概述 一. Spring框架的概述 二. SpringIOC的快速入门 三. IoC容器XML的方式以及依赖注入(DI) 四. 在web项目中集成Spring 一. Spring框架的概述1.什么是Spring框架* Spring是一个开源框架 * Spring是于2003 年兴起的一个轻量级的Java开发框架，由Rod Johnson在其著作Expert One-On-One J2EE Development and Design中阐述的部分理念和原型衍生而来。 * 它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。 * Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以 从Spring中受益。 * Spring的核心是控制反转（IoC）和面向切面（AOP）。简单来说，Spring是一个分层的JavaSE/EEfull-stack(一站式) 轻量级开源框架。 * EE开发分成三层结构 * WEB层 -- Spring MVC * 业务层 -- Bean管理:(IOC) * 持久层 -- Spring的JDBC模板.ORM模板用于整合其他的持久层框架 2.Spring框架的特点1. 为什么要学习Spring的框架 * 方便解耦，简化开发 * Spring就是一个大工厂，可以将所有对象创建和依赖关系维护，交给Spring管理 * AOP编程的支持 * Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能 * 声明式事务的支持 * 只需要通过配置就可以完成对事务的管理，而无需手动编程 * 方便程序的测试 * Spring对Junit4支持，可以通过注解方便的测试Spring程序 * 方便集成各种优秀框架 * Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts2、Hibernate、MyBatis、Quartz等）的直接支持 * 降低JavaEE API的使用难度 * Spring 对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低 2. Spring框架的版本 * Spring3.x和Spring4.x的版本 二.Spring IOC（控制反转）1.Spring框架的IOC核心功能快速入门1. 什么是IOC的功能？ * IoC -- Inverse of Control，控制反转，将对象的创建权反转给Spring！！ * 使用IOC可以解决的程序耦合性高的问题！！ 2. 步骤一：下载Spring框架的开发包 * 官网：http://spring.io/ * 下载地址：http://repo.springsource.org/libs-release-local/org/springframework/spring解压:(Spring目录结构:) * docs -- API和开发规范 * libs -- jar包和源码 * schema -- 约束 3. 步骤二：创建JavaWEB项目，引入Spring的开发包 * 引入Spring框架IOC核心功能需要的具体的jar包 * Spring框架的IOC的功能，那么根据Spring框架的体系结构图能看到，只需要引入如下的jar包 * Beans * Core * Context * Expression Language * Spring框架也需要引入日志相关的jar包 * 在spring-framework-3.0.2.RELEASE-dependencies/org.apache.commons/com.springsource.org.apache.commons.logging/1.1.1 * com.springsource.org.apache.commons.logging-1.1.1.jar * 还需要引入log4j的jar包 spring-framework-3.0.2.RELEASE-dependencies\org.apache.log4j\com.springsource.org.apache.log4j\1.2.15 * com.springsource.org.apache.log4j-1.2.15.jar 4. 步骤三：创建对应的包结构，编写Java的类，要注意：以后使用Spring框架做开发，都需要来编写接口与实现类！！ * com.itcast.demo1 * UserService -- 接口 * UserServiceImpl -- 具体的实现类 5. 步骤四：想把UserServiceImpl实现类的创建交给Spring框架来管理，需要创建Spring框架的配置文件，完成配置 * 在src目录下创建applicationContext.xml的配置文件，名称是可以任意的，但是一般都会使用默认名称！！ * 引入spring的约束，需要先找到具体的约束头信息！！ * spring-framework-3.2.0.RELEASE\docs\spring-framework-reference\html\xsd-config.html * 具体的约束如下： &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;/beans&gt; * 完成UserService的配置 &lt;!-- Spring的快速入门 --&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.itcast.demo1.UserServiceImpl&quot;/&gt; 6. 步骤五：编写测试程序，采用Spring框架的工厂方式来获取到UserService接口的具体实现类！！ public void demo2(){ // 使用Spring的工厂: ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); // 通过工厂获得类: UserService userService = (UserService) applicationContext.getBean(&quot;userService&quot;); userService.sayHello(); } 2.Spring框架中的工厂（了解）1. ApplicationContext接口 * 使用ApplicationContext工厂的接口，使用该接口可以获取到具体的Bean对象 * 该接口下有两个具体的实现类 * ClassPathXmlApplicationContext -- 加载类路径下的Spring配置文件 * FileSystemXmlApplicationContext -- 加载本地磁盘下的Spring配置文件 2. BeanFactory工厂（是Spring框架早期的创建Bean对象的工厂接口） * 使用BeanFactory接口也可以获取到Bean对象 public void run(){ BeanFactory factory = new XmlBeanFactory(new ClassPathResource(&quot;applicationContext.xml&quot;)); UserService us = (UserService) factory.getBean(&quot;us&quot;); us.sayHello(); } * BeanFactory和ApplicationContext的区别 * BeanFactory -- BeanFactory采取延迟加载，第一次getBean时才会初始化Bean * ApplicationContext -- 在加载applicationContext.xml时候就会创建具体的Bean对象的实例，还提供了一些其他的功能 * 事件传递 * Bean自动装配 * 各种不同应用层的Context实现 3.配置Spring框架编写XML的提示1. 步骤一：先复制， http://www.springframework.org/schema/beans/spring-beans.xsd 2. 步骤二：搜索XML Catalog，点击Add按钮 3. 步骤三：先选择Location的schema的约束地址 * E:\class\2016\JavaEE28\day35_Spring框架第一天\资料\spring-framework-4.2.4.RELEASE-schema\beans\spring-beans-4.2.xsd 4. 步骤四：注意：Key type要选择：Schema location 5. 步骤五：Key把http://www.springframework.org/schema/beans/spring-beans.xsd复制上 三.Spring框架的Bean管理的配置文件方式1.Spring框架中标签的配置1. id属性和name属性的区别 * id -- Bean起个名字，在约束中采用ID的约束，唯一 * 取值要求：必须以字母开始，可以使用字母、数字、连字符、下划线、句话、冒号 id:不能出现特殊字符 * name -- Bean起个名字，没有采用ID的约束（了解） * 取值要求：name:出现特殊字符.如果&lt;bean&gt;没有id的话 , name可以当做id使用 * Spring框架在整合Struts1的框架的时候，Struts1的框架的访问路径是以/开头的，例如：/bookAction 2. class属性 -- Bean对象的全路径 3. scope属性 -- scope属性代表Bean的作用范围 * singleton -- 单例（默认值） * prototype -- 多例，在Spring框架整合Struts2框架的时候，Action类也需要交给Spring做管理，配置把Action类配置成多例！！ * request -- 应用在Web项目中,每次HTTP请求都会创建一个新的Bean * session -- 应用在Web项目中,同一个HTTP Session 共享一个Bean * globalsession -- 应用在Web项目中,多服务器间的session 4. Bean对象的创建和销毁的两个属性配置（了解） * 说明：Spring初始化bean或销毁bean时，有时需要作一些处理工作，因此spring可以在创建和拆卸bean的时候调用bean的两个生命周期方法 * init-method -- 当bean被载入到容器的时候调用init-method属性指定的方法 * destroy-method -- 当bean从容器中删除的时候调用destroy-method属性指定的方法 * 想查看destroy-method的效果，有如下条件 * scope= singleton有效 * web容器中会自动调用，但是main函数或测试用例需要手动调用（需要使用ClassPathXmlApplicationContext的close()方法） 2.依赖注入（DI）1. IOC和DI的概念 * IOC -- Inverse of Control，控制反转，将对象的创建权反转给Spring！！ * DI -- Dependency Injection，依赖注入，在Spring框架负责创建Bean对象时，动态的将依赖对象注入到Bean组件中！！ 2. DI（依赖注入） * 例如：如果UserServiceImpl的实现类中有一个属性，那么使用Spring框架的IOC功能时，可以通过依赖注入把该属性的值传入进来！！ * 具体的配置如下 &lt;bean id=&quot;us&quot; class=&quot;com.itheima.demo1.UserServiceImpl&quot;&gt; &lt;property name=&quot;uname&quot; value=&quot;小风&quot;/&gt; &lt;/bean&gt; 3.Spring框架的属性注入1. 对于类成员变量，常用的注入方式有两种 * 构造函数注入 * 属性setter方法注入 2. 在Spring框架中提供了前两种的属性注入的方式 1. 构造方法的注入方式，两步 * 编写Java的类，提供构造方法 public class Car { private String name; private double money; public Car(String name, double money) { this.name = name; this.money = money; } @Override public String toString() { return &quot;Car [name=&quot; + name + &quot;, money=&quot; + money + &quot;]&quot;; } } * 编写配置文件 &lt;bean id=&quot;car&quot; class=&quot;com.itheima.demo4.Car&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;大奔&quot;/&gt; &lt;constructor-arg name=&quot;money&quot; value=&quot;100&quot;/&gt; &lt;/bean&gt; 2. 属性的setter方法的注入方式 * 编写Java的类，提供属性和对应的set方法即可 * 编写配置文件 3. 如果Java类的属性是另一个Java的类，那么需要怎么来注入值呢？ * &lt;property name=&quot;name&quot; rel=&quot;具体的Bean的ID或者name的值&quot;/&gt; * 例如： &lt;bean id=&quot;person&quot; class=&quot;com.itheima.demo4.Person&quot;&gt; &lt;property name=&quot;pname&quot; value=&quot;美美&quot;/&gt; &lt;property name=&quot;car2&quot; ref=&quot;car2&quot;/&gt; &lt;/bean&gt; 4.Spring的2.5版本中提供了一种:p名称空间的注入（了解）1. 步骤一：需要先引入 p 名称空间 * 在schema的名称空间中加入该行：xmlns:p=&quot;http://www.springframework.org/schema/p&quot; 2. 步骤二：使用p名称空间的语法 * p:属性名 = &quot;&quot; * p:属性名-ref = &quot;&quot; 3. 步骤三：测试 * &lt;bean id=&quot;person&quot; class=&quot;com.itheima.demo4.Person&quot; p:pname=&quot;老王&quot; p:car2-ref=&quot;car2&quot;/&gt; 5.Spring的3.0提供了一种:SpEL注入方式（了解）1. SpEL：Spring Expression Language是Spring的表达式语言，有一些自己的语法 2. 语法 * #{SpEL} 3. 例如如下的代码 &lt;!-- SpEL的方式 --&gt; &lt;bean id=&quot;person&quot; class=&quot;com.itheima.demo4.Person&quot;&gt; &lt;property name=&quot;pname&quot; value=&quot;#{&apos;小风&apos;}&quot;/&gt; &lt;property name=&quot;car2&quot; value=&quot;#{car2}&quot;/&gt; &lt;/bean&gt; 4. 还支持调用类中的属性或者方法 * 定义类和方法，例如 public class CarInfo { public String getCarname(){ return &quot;奇瑞QQ&quot;; } } 6.数组，集合(List,Set,Map)，Properties等的注入1. 如果是数组或者List集合，注入配置文件的方式是一样的 &lt;bean id=&quot;collectionBean&quot; class=&quot;com.itheima.demo5.CollectionBean&quot;&gt; &lt;property name=&quot;arrs&quot;&gt; &lt;list&gt; &lt;value&gt;美美&lt;/value&gt; &lt;value&gt;小风&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 2. 如果是Set集合，注入的配置文件方式如下： &lt;property name=&quot;sets&quot;&gt; &lt;set&gt; &lt;value&gt;哈哈&lt;/value&gt; &lt;value&gt;呵呵&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; 3. 如果是Map集合，注入的配置方式如下： &lt;property name=&quot;map&quot;&gt; &lt;map&gt; &lt;entry key=&quot;老王2&quot; value=&quot;38&quot;/&gt; &lt;entry key=&quot;凤姐&quot; value=&quot;38&quot;/&gt; &lt;entry key=&quot;如花&quot; value=&quot;29&quot;/&gt; &lt;/map&gt; &lt;/property&gt; 4. 如果是properties属性文件的方式，注入的配置如下： &lt;property name=&quot;pro&quot;&gt; &lt;props&gt; &lt;prop key=&quot;uname&quot;&gt;root&lt;/prop&gt; &lt;prop key=&quot;pass&quot;&gt;123&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; 7.Spring框架的配置文件分开管理（了解）例如：在src的目录下又多创建了一个配置文件，现在是两个核心的配置文件，那么加载这两个配置文件的方式有两种！ * 主配置文件中包含其他的配置文件: &lt;import resource=&quot;applicationContext2.xml&quot;/&gt; * 工厂创建的时候直接加载多个配置文件: ApplicationContext applicationContext = new ClassPathXmlApplicationContext( &quot;applicationContext.xml&quot;,&quot;applicationContext2.xml&quot;); 四.Spring框架整合基础WEB （不是最终的整合）1. 创建JavaWEB项目，引入Spring的开发包。编写具体的类和方法。 * 环境搭建好后，启动服务器来测试项目，发送每访问一次都会加载一次配置文件，这样效率会非常非常慢！！ 2. 解决上面的问题 * 将工厂创建好了以后放入到ServletContext域中.使用工厂的时候,从ServletContext中获得. * ServletContextListener:用来监听ServletContext对象的创建和销毁的监听器. * 当ServletContext对象创建的时候:创建工厂 , 将工厂存入到ServletContext 3. Spring整合Web项目 * 引入spring-web-4.2.4.RELEASE.jar包 * 配置监听器 &lt;!-- 配置Spring的核心监听器: --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; 4. 修改servlet的代码 * 从ServletContext中获得工厂 * 具体代码如下 ServletContext servletContext = ServletActionContext.getServletContext(); // 需要使用WEB的工厂的方式 WebApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(servletContext); CustomerService cs = (CustomerService) context.getBean(&quot;customerService&quot;); cs.save();]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>spring入门篇</tag>
        <tag>spring IOC（控制反转[配置文件方式]）</tag>
        <tag>spring DI（依赖注入）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[struts2完善篇(OGNL表达式/值栈/特殊符号[$,#,%])]]></title>
    <url>%2F2018%2F12%2F22%2Fstruts2-3%2F</url>
    <content type="text"><![CDATA[Struts2的学习路线 1.Struts2的入门篇：主要是学习Struts2的开发流程（Struts2的开发流程、常见的配置、Action类的编写） 2.Struts2的进阶篇: Struts2的Servlet的API、参数封装和拦截器 3.Struts2的完善篇: Struts2的值栈和OGNL表达式 一.技术分析之OGNL表达式1.OGNL表达式概述1. OGNL是Object Graphic Navigation Language（对象图导航语言）的缩写 * 所谓对象图，即以任意一个对象为根，通过OGNL可以访问与这个对象关联的其它对象 * 通过它简单一致的表达式语法，可以存取对象的任意属性，调用对象的方法，遍历整个对象的结构图，实现字段类型转化等功能。它使用相同的表达式去存取对象的属性 2. Struts2框架使用OGNL作为默认的表达式语言 * OGNL是一种比EL强大很多倍的语言 * xwork提供 OGNL表达式 * ognl-3.0.5.jar 3. OGNL 提供五大类功能 * 支持对象方法调用 * 支持类静态的方法调用和值访问 * 访问OGNL上下文（OGNL context）和ActionContext * 支持赋值操作和表达式串联 * 操作集合对象 4. 测试的代码 // 访问对象的方法 @Test public void run1() throws OgnlException{ OgnlContext context = new OgnlContext(); // 获取对象的方法 Object obj = Ognl.getValue(&quot;&apos;helloworld&apos;.length()&quot;, context, context.getRoot()); System.out.println(obj); } // 获取OGNL上下文件的对象 @Test public void run3() throws OgnlException{ OgnlContext context = new OgnlContext(); context.put(&quot;name&quot;, &quot;美美&quot;); // 获取对象的方法 Object obj = Ognl.getValue(&quot;#name&quot;, context, context.getRoot()); System.out.println(obj); } // 从root栈获取值 @Test public void demo3() throws OgnlException{ OgnlContext context = new OgnlContext(); Customer c = new Customer(); c.setCust_name(&quot;haha&quot;); context.setRoot(c); String name = (String) Ognl.getValue(&quot;cust_name&quot;, context, context.getRoot()); System.out.println(name); } 2.技术分析之在Struts2框架中使用OGNL表达式1. Struts2引入了OGNL表达式，主要是在JSP页面中获取值栈中的值 2. 具体在Struts2中怎么使用呢？如下步骤 * 需要先引入Struts2的标签库 &gt; &lt;%@ taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot; %&gt; * 使用Struts2提供的标签中的标签 &gt; &lt;s:property value=&quot;OGNL表达式&quot;/&gt; 3. 在JSP页面使用OGNL表达式 * 访问对象方法 &lt;s:property value=&quot;&apos;hello&apos;.length()&quot;/&gt; 二.技术分析之 值栈1.值栈的概述问题一：什么是值栈？ * 值栈就相当于Struts2框架的数据的中转站，向值栈存入一些数据。从值栈中获取到数据。 * ValueStack 是 struts2 提供一个接口，实现类 OgnlValueStack ---- 值栈对象 （OGNL是从值栈中获取数据的 ） * Action是多例的，有一起请求，创建Action实例，创建一个ActionContext对象，代表的是Action的上下文对象，还会创建一个ValueStack对象。 * 每个Action实例都有一个ValueStack对象 （一个请求 对应 一个ValueStack对象 ） * 在其中保存当前Action 对象和其他相关对象 * Struts 框架把 ValueStack 对象保存在名为 “struts.valueStack” 的请求属性中,request中 （值栈对象 是 request一个属性） * ValueStack vs = (ValueStack)request.getAttribute(&quot;struts.valueStack&quot;); 2.技术分析之值栈的内部结构问题二 ： 值栈的内部结构 ？ * 值栈由两部分组成 &gt; root -- Struts把动作和相关对象压入 ObjectStack 中--List &gt; context -- Struts把各种各样的映射关系(一些 Map 类型的对象) 压入 ContextMap 中 * Struts会默认把下面这些映射压入ContextMap（context）中 * 注意：request代表的是Map集合的key值，value的值其实也是一个Map集合。 &gt; parameters: 该 Map 中包含当前请求的请求参数 ?name=xxx&amp;password=123 &gt; request: 该 Map 中包含当前 request 对象中的所有属性 &gt; session: 该 Map 中包含当前 session 对象中的所有属性 &gt; application:该 Map 中包含当前 application 对象中的所有属性 &gt; attr: 该 Map 按如下顺序来检索某个属性: request, session, application * ValueStack中 存在root属性 (CompoundRoot) 、 context 属性 （OgnlContext ） &gt; CompoundRoot 就是ArrayList &gt; OgnlContext 就是 Map * context 对应Map 引入 root对象 &gt; context中还存在 request、 session、application、 attr、 parameters 对象引用 &gt; OGNL表达式访问值栈中的数据 * 访问root中数据时 不需要 # * 访问 request、 session、application、 attr、 parameters 对象数据 必须写 # &gt; 操作值栈 默认指 操作 root 元素 3.技术分析之值栈的创建和ActionContext对象的关系问题三 ： 值栈对象的创建，ValueStack 和 ActionContext 是什么关系？ * 值栈对象是请求时创建的 * ActionContext是绑定到当前的线程上，那么在每个拦截器或者Action中获取到的ActionContext是同一个。 * ActionContext中存在一个Map集合，该Map集合和ValueStack的context是同一个地址。 * ActionContext中可以获取到ValueStack的引用，以后再开发，使用ActionContext来获取到值栈对象 4.技术分析之获取到值栈的对象问题四 ： 如何获得值栈对象 * 获得值栈对象 有三种方法 * ValueStack vs1 = (ValueStack) ServletActionContext.getRequest().getAttribute(&quot;struts.valueStack&quot;); * ValueStack vs2 = (ValueStack) ServletActionContext.getRequest().getAttribute(ServletActionContext.STRUTS_VALUESTACK_KEY); * ValueStack vs3 = ActionContext.getContext().getValueStack(); 5.技术分析之向值栈中保存数据问题五： 向值栈保存数据 （主要针对root栈） &gt; valueStack.push(Object obj); * push方法的底层调用root对象的push方法（把元素添加到0位置） &gt; valueStack.set(String key, Object obj); * 源码获取map集合（map有可能是已经存在的，有可能是新创建的），把map集合push到栈顶，再把数据存入到map集合中。 &gt; 在jsp中 通过 &lt;s:debug /&gt; 查看值栈的内容 6.技术分析之从值栈中获取值问题六： 在JSP中获取值栈的数据 * 总结几个小问题： &gt; 访问root中数据 不需要# &gt; 访问context其它对象数据 加 # &gt; 如果向root中存入对象的话，优先使用push方法。 &gt; 如果向root中存入集合的话，优先要使用set方法。 * 在OgnlContext中获取数据 &gt; 在Action中向域对象中存入值 &gt; request:&lt;s:property value=&quot;#request.username&quot;/&gt; &gt; session:&lt;s:property value=&quot;#session.username&quot;/&gt; &gt; application:&lt;s:property value=&quot;#application.username&quot;/&gt; &gt; attr:&lt;s:property value=&quot;#attr.username&quot;/&gt; &gt; parameters:&lt;s:property value=&quot;#parameters.cid&quot;/&gt; 代码如下 &lt;!-- // vs.push(&quot;美美&quot;); // 获取到栈顶的值 &lt;s:property value=&quot;[0].top&quot;/&gt; --&gt; &lt;!-- // 栈顶是map集合，通过key获取值 vs.set(&quot;msg&quot;, &quot;小凤&quot;); &lt;s:property value=&quot;[0].top.msg&quot;/&gt; --&gt; &lt;!-- vs.push(user); // 栈顶放user对象 &lt;s:property value=&quot;[0].top.username&quot;/&gt; &lt;s:property value=&quot;[0].top.password&quot;/&gt; // [0].top 关键字是可以省略的 findValue() &lt;s:property value=&quot;username&quot;/&gt; --&gt; &lt;!-- vs.set(&quot;user&quot;, user); &lt;s:property value=&quot;[0].top.user.username&quot;/&gt; &lt;s:property value=&quot;[0].top.user.password&quot;/&gt; // 省略关键字 &lt;s:property value=&quot;user.username&quot;/&gt; --&gt; &lt;!-- // 在ValueStack1Action提供了成员的属性 private User user = new User(&quot;小泽&quot;,&quot;456&quot;); public User getUser() { return user; } public void setUser(User user) { this.user = user; } User user = new User(&quot;小苍&quot;,&quot;123&quot;); vs.set(&quot;user&quot;, user); // 从栈顶开始查找，找user的属性，显示名称 返回的小苍 &lt;s:property value=&quot;user.username&quot;/&gt; // [1].top获取ValueStack1Action [1].top.user返回user对象 [1].top.user.username获取对象的属性名称 &lt;s:property value=&quot;[1].top.user.username&quot;/&gt; --&gt; &lt;!-- 栈顶是list集合 vs.push(ulist); &lt;s:property value=&quot;[0].top[0].username&quot;/&gt; &lt;s:property value=&quot;[0].top[1].username&quot;/&gt; --&gt; &lt;!-- vs.set(&quot;ulist&quot;, ulist); &lt;s:property value=&quot;ulist[0].username&quot;/&gt; --&gt; &lt;!-- 迭代的标签 属性 * value 要迭代的集合，需要从值栈中获取 * var 迭代过程中，遍历的对象 * var编写上，把迭代产生的对象默认压入到context栈中，从context栈取值，加#号 * var不编写，默认把迭代产生的对象压入到root栈中 for(User user:ulist){} // 编写var的属性 &lt;s:iterator value=&quot;ulist&quot; var=&quot;u&quot;&gt; &lt;s:property value=&quot;#u.username&quot;/&gt; &lt;s:property value=&quot;#u.password&quot;/&gt; &lt;/s:iterator&gt; // 没有编写var关键字 &lt;s:iterator value=&quot;ulist&quot;&gt; &lt;s:property value=&quot;username&quot;/&gt; &lt;s:property value=&quot;password&quot;/&gt; &lt;/s:iterator&gt; --&gt; &lt;!-- 从context栈中获取值，加#号 HttpServletRequest request = ServletActionContext.getRequest(); request.setAttribute(&quot;msg&quot;, &quot;美美&quot;); request.getSession().setAttribute(&quot;msg&quot;, &quot;小风&quot;); &lt;s:property value=&quot;#request.msg&quot;/&gt; &lt;s:property value=&quot;#session.msg&quot;/&gt; &lt;s:property value=&quot;#parameters.id&quot;/&gt; &lt;s:property value=&quot;#attr.msg&quot;/&gt; --&gt; &lt;!-- 在JSP页面上，查看值栈的内部结构 --&gt; &lt;s:debug&gt;&lt;/s:debug&gt; 7.技术分析之EL表达式也会获取到值栈中的数据问题七：为什么EL也能访问值栈中的数据？ * StrutsPreparedAndExecuteFilter的doFilter代码中 request = prepare.wrapRequest(request); &gt; 对Request对象进行了包装 ，StrutsRequestWrapper &gt; 增强了request的 getAttribute Object attribute = super.getAttribute(s); if (attribute == null) { attribute = stack.findValue(s); } &gt; 访问request范围的数据时，如果数据找不到，去值栈中找 &gt; request对象 具备访问值栈数据的能力 （查找root的数据） 三.总结OGNL表达式的特殊的符号1. # 符号的用法* 获得contextMap中的数据 &gt; &lt;s:property value=&quot;#request.name&quot;/&gt; &gt; &lt;s:property value=&quot;#session.name&quot;/&gt; &gt; &lt;s:property value=&quot;#application.name&quot;/&gt; &gt; &lt;s:property value=&quot;#attr.name&quot;/&gt; &gt; &lt;s:property value=&quot;#parameters.id&quot;/&gt; &gt; &lt;s:property value=&quot;#parameters.name&quot;/&gt; * 构建一个map集合 * 例如： * &lt;s:radio name=&quot;sex&quot; list=&quot;{&apos;男&apos;,&apos;女&apos;}&quot;&gt;&lt;/s:radio&gt; * &lt;s:radio name=&quot;sex&quot; list=&quot;#{&apos;0&apos;:&apos;男&apos;,&apos;1&apos;:&apos;女&apos;}&quot;&gt;&lt;/s:radio&gt; 2. % 符号的用法* 强制字符串解析成OGNL表达式。 &gt; 例如：在request域中存入值，然后在文本框（&lt;s:textfield&gt;）中取值，现在到value上。 &gt; &lt;s:textfield value=&quot;%{#request.msg}&quot;/&gt; * { }中值用&apos;&apos;引起来,此时不再是ognl表达式,而是普通的字符串 &gt; 例如：&lt;s:property value=&quot;%{&apos;#request.msg&apos;}&quot;/&gt; 3. $ 符号的用法* 在配置文件中可以使用OGNL表达式，例如：文件下载的配置文件。 &lt;action name=&quot;download1&quot; class=&quot;cn.itcast.demo2.DownloadAction&quot;&gt; &lt;result name=&quot;success&quot; type=&quot;stream&quot;&gt; &lt;param name=&quot;contentType&quot;&gt;${contentType}&lt;/param&gt; &lt;param name=&quot;contentDisposition&quot;&gt;attachment;filename=${downFilename}&lt;/param&gt; &lt;/result&gt; &lt;/action&gt;]]></content>
      <categories>
        <category>struts2</category>
      </categories>
      <tags>
        <tag>struts2</tag>
        <tag>struts2完善篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[struts2进阶篇(Servlet的API/参数封装/拦截器的定义使用)]]></title>
    <url>%2F2018%2F12%2F21%2Fstruts2-2%2F</url>
    <content type="text"><![CDATA[Struts2的学习路线 1.Struts2的入门篇：主要是学习Struts2的开发流程（Struts2的开发流程、常见的配置、Action类的编写） 2.Struts2的进阶篇: Struts2的Servlet的API、参数封装和拦截器 3.Struts2的完善篇: Struts2的值栈和OGNL表达式 一.技术分析之在Struts2框架中使用Servlet的API1. 在Action类中也可以获取到Servlet一些常用的API * 需求：提供JSP的表单页面的数据，在Action中使用Servlet的API接收到，然后保存到三个域对象中，最后再显示到JSP的页面上。 * 提供JSP注册的页面，演示下面这三种方式 &lt;h3&gt;注册页面&lt;/h3&gt; &lt;form action=&quot;${ pageContext.request.contextPath }/xxx.action&quot; method=&quot;post&quot;&gt; 姓名:&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br/&gt; 密码:&lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;注册&quot; /&gt; &lt;/form&gt; 2. 完全解耦合的方式 * 如果使用该种方式，Struts2框架中提供了一个类，ActionContext类，该类中提供一些方法，通过方法获取Servlet的API * 一些常用的方法如下 * static ActionContext getContext() -- 获取ActionContext对象实例 * java.util.Map&lt;java.lang.String,java.lang.Object&gt; getParameters() -- 获取请求参数，相当于request.getParameterMap(); * java.util.Map&lt;java.lang.String,java.lang.Object&gt; getSession() -- 获取的代表session域的Map集合，就相当于操作session域。 * java.util.Map&lt;java.lang.String,java.lang.Object&gt; getApplication() -- 获取代表application域的Map集合 * void put(java.lang.String key, java.lang.Object value) -- 注意：向request域中存入值。 3. 使用原生Servlet的API的方式 * Struts2框架提供了一个类，ServletActionContext，该类中提供了一些静态的方法 * 具体的方法如下 * getPageContext() * getRequest() * getResponse() * getServletContext() 二.技术分析之结果页面的跳转1. 结果页面存在两种方式 * 全局结果页面 &gt; 条件：如果&lt;package&gt;包中的一些action都返回success，并且返回的页面都是同一个JSP页面，这样就可以配置全局的结果页面。 &gt; 全局结果页面针对的当前的包中的所有的Action，但是如果局部还有结果页面，会优先局部的。使用的标签是 &lt;global-results&gt; &lt;result&gt;/demo3/suc.jsp&lt;/result&gt; &lt;/global-results&gt; * 局部结果页面 &lt;result&gt;/demo3/suc.jsp&lt;/result&gt; 2. 结果页面的类型 * 结果页面使用&lt;result&gt;标签进行配置，包含两个属性 &gt; name -- 逻辑视图的名称 &gt; type -- 跳转的类型，值一些，需要掌握一些常用的类型。常见的结果类型去struts-default.xml中查找。 * dispatcher -- 转发.type的默认值.Action---&gt;JSP * redirect -- 重定向. Action---&gt;JSP * chain -- 多个action之间跳转.从一个Action转发到另一个Action. Action---Action * redirectAction -- 多个action之间跳转.从一个Action重定向到另一个Action. Action---Action * stream -- 文件下载时候使用的 三.技术分析之Struts2框架的数据封装 1. 为什么要使用数据的封装呢？ * 作为MVC框架，必须要负责解析HTTP请求参数，并将其封装到Model对象中 * 封装数据为开发提供了很多方便 * Struts2框架提供了很强大的数据封装的功能，不再需要使用Servlet的API完成手动封装了！！ 2. Struts2中提供了两类数据封装的方式？ * 第一种方式：属性驱动 &gt; 提供对应属性的set方法进行数据的封装。 * 表单的哪些属性需要封装数据，那么在对应的Action类中提供该属性的set方法即可。 * 表单中的数据提交，最终找到Action类中的setXxx的方法，最后赋值给全局变量。 * 注意0：Struts2的框架采用的拦截器完成数据的封装。 * 注意1：这种方式不是特别好:因为属性特别多,提供特别多的set方法,而且还需要手动将数据存入到对象中. * 注意2：这种情况下，Action类就相当于一个JavaBean，就没有体现出MVC的思想，Action类又封装数据，又接收请求处理，耦合性较高。 &gt; 在页面上，使用OGNL表达式进行数据封装。 * 在页面中使用OGNL表达式进行数据的封装，就可以直接把属性封装到某一个JavaBean的对象中。 * 在页面中定义一个JavaBean，并且提供set方法：例如：private User user; * 页面中的编写发生了变化，需要使用OGNL的方式，表单中的写法：&lt;input type=&quot;text&quot; name=&quot;user.username&quot;&gt; * 注意：只提供一个set方法还不够，必须还需要提供user属性的get和set方法！！！ &gt; 先调用get方法，判断一下是否有user对象的实例对象，如果没有，调用set方法把拦截器创建的对象注入进来， * 第二种方式：模型驱动 &gt; 使用模型驱动的方式，也可以把表单中的数据直接封装到一个JavaBean的对象中，并且表单的写法和之前的写法没有区别！ &gt; 编写的页面不需要任何变化，正常编写name属性的值 &gt; 模型驱动的编写步骤： * 手动实例化JavaBean，即：private User user = new User(); * 必须实现ModelDriven&lt;T&gt;接口，实现getModel()的方法，在getModel()方法中返回user即可！！ 四.技术分析之Struts2把数据封装到集合中1. 封装复杂类型的参数（集合类型 Collection 、Map接口等） 2. 需求：页面中有可能想批量添加一些数据，那么现在就可以使用上述的技术了。把数据封装到集合中 3. 把数据封装到Collection中 * 因为Collection接口都会有下标值，所有页面的写法会有一些区别，注意： &gt; &lt;input type=&quot;text&quot; name=&quot;products[0].name&quot; /&gt; * 在Action中的写法，需要提供products的集合，并且提供get和set方法。 4. 把数据封装到Map中 * Map集合是键值对的形式，页面的写法 &gt; &lt;input type=&quot;text&quot; name=&quot;map[&apos;one&apos;].name&quot; /&gt; * Action中提供map集合，并且提供get和set方法 五.案例总结之Struts2的拦截器技术1. 拦截器的概述 * 拦截器就是AOP（Aspect-Oriented Programming）的一种实现。（AOP是指用于在某个方法或字段被访问之前，进行拦截然后在之前或之后加入某些操作。） * 过滤器:过滤从客服端发送到服务器端请求的 * 拦截器:拦截对目标Action中的某些方法进行拦截 * 拦截器不能拦截JSP * 拦截到Action中某些方法 2. 拦截器和过滤器的区别 1）拦截器是基于JAVA反射机制的，而过滤器是基于函数回调的 2）过滤器依赖于Servlet容器，而拦截器不依赖于Servlet容器 3）拦截器只能对Action请求起作用（Action中的方法），而过滤器可以对几乎所有的请求起作用（CSS JSP JS） * 拦截器 采用 责任链 模式 &gt; 在责任链模式里,很多对象由每一个对象对其下家的引用而连接起来形成一条链 &gt; 责任链每一个节点，都可以继续调用下一个节点，也可以阻止流程继续执行 * 在struts2 中可以定义很多个拦截器，将多个拦截器按照特定顺序 组成拦截器栈 （顺序调用 栈中的每一个拦截器 ） 3. Struts2的核心是拦截器，看一下Struts2的运行流程 六.案例总结之自定义拦截器和配置1. 编写拦截器，需要实现Interceptor接口，实现接口中的三个方法 protected String doIntercept(ActionInvocation invocation) throws Exception { // 获取session对象 User user = (User) ServletActionContext.getRequest().getSession().getAttribute(&quot;existUser&quot;); if(user == null){ // 说明，没有登录，后面就不会执行了 return &quot;login&quot;; } return invocation.invoke(); } 2. 需要在struts.xml中进行拦截器的配置，配置一共有两种方式 &lt;!-- 定义了拦截器 第一种方式 &lt;interceptors&gt; &lt;interceptor name=&quot;DemoInterceptor&quot; class=&quot;com.itheima.interceptor.DemoInterceptor&quot;/&gt; &lt;/interceptors&gt; --&gt; &lt;!-- 第二种方式：定义拦截器栈 --&gt; &lt;interceptors&gt; &lt;interceptor name=&quot;DemoInterceptor&quot; class=&quot;com.itheima.interceptor.DemoInterceptor&quot;/&gt; &lt;!-- 定义拦截器栈 --&gt; &lt;interceptor-stack name=&quot;myStack&quot;&gt; &lt;interceptor-ref name=&quot;DemoInterceptor&quot;/&gt; &lt;interceptor-ref name=&quot;defaultStack&quot;/&gt; &lt;/interceptor-stack&gt; &lt;/interceptors&gt; &lt;action name=&quot;userAction&quot; class=&quot;com.itheima.demo3.UserAction&quot;&gt; &lt;!-- 只要是引用自己的拦截器，默认栈的拦截器就不执行了，必须要手动引入默认栈 &lt;interceptor-ref name=&quot;DemoInterceptor&quot;/&gt; &lt;interceptor-ref name=&quot;defaultStack&quot;/&gt; --&gt; &lt;!-- 引入拦截器栈就OK --&gt; &lt;interceptor-ref name=&quot;myStack&quot;/&gt; &lt;/action&gt;]]></content>
      <categories>
        <category>struts2</category>
      </categories>
      <tags>
        <tag>struts2</tag>
        <tag>struts2进阶篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[struts2入门篇(基础框架搭建)]]></title>
    <url>%2F2018%2F12%2F20%2Fstruts2-1%2F</url>
    <content type="text"><![CDATA[Struts2的学习路线 1.Struts2的入门篇：主要是学习Struts2的开发流程（Struts2的开发流程、常见的配置、Action类的编写） 2.Struts2的进阶篇: Struts2的Servlet的API、参数封装和拦截器 3.Struts2的完善篇: Struts2的值栈和OGNL表达式 一.技术分析之Struts2框架的概述 1. Struts2是一个基于MVC设计模式的Web层框架 * MVC和JavaEE的三层结构 * MVC设计模式:是由一些网站的开发人员提出来的 * JavaEE三层结构:SUN公司为EE开发划分的结构 2. 常见的Web层的框架 * Struts1 * Struts2 * Webwork * SpringMVC 3. Web层框架的特点 * 都是一个特点，前端控制器模式 * 记住：前端控制器（核心的控制器） * Struts2框架前端的控制器就是过滤器 二.技术分析之Struts2快速入门的环境准备1.基础环境搭建1. 创建WEB项目，编写JSP的页面，编写超链接，点击超链接发送请求，请求服务器，让服务器的方法去执行！！ &lt;h3&gt;Struts2的入门程序&lt;/h3&gt; &lt;a href=&quot;${ pageContext.request.contextPath }/hello.action&quot;&gt;Struts2入门程序&lt;/a&gt; 2. 下载Struts2的开发包 * https://struts.apache.org/ -- 官网地址 3. 解压struts-2.3.24-all.zip包 * 解压后会看到有包和一些文件，大家需要掌握包相关的信息 * apps -- Struts2框架提供了一些应用 * libs -- Struts2框架开发的jar包 * docs -- Struts2框架开发文档 * src -- Struts2框架源码 4. 引入需要开发的jar包（最基础的jar包为13个） * Struts2框架的开发jar包非常多，但是不是所有都是必须要引入的，有一些必须要导入的jar包，这些jar包可以从Struts2框架提供的应用中找到。 * 大家可以打开apps目录，然后找到struts2-blank.war应用。war包和zip包的压缩格式是一样的，所以可以自己修改后缀名，解压。 * 找到解压后的应用，打开WEB-INF/lib目录下所以的jar包。复制到工程中，就可以了。 5. 需要配置Struts2的前端控制器，注意：这一步是必须要做的操作，这是Struts2核心的控制器。 * Struts2的前端控制器就是一个过滤器，那么过滤器相关知识咱们都学习过，需要在web.xml中进行配置。 * 前端控制器的类的路径和名称：org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter * 具体配置如下 &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 2.技术分析之编写Action类1. Action类是动作类，是Struts2处理请求，封装数据，响应页面的核心控制器。需要自己编写。 package cn.itcast.action; public String sayHello(){ System.out.println(&quot;Hello Struts2!!&quot;); return null; } 3.技术分析之编写Struts的配置文件1. 配置文件名称是struts.xml（名称必须是struts.xml） 2. 在src下引入struts.xml配置文件（配置文件的路径必须是在src的目录下） 3. 配置如下 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE struts PUBLIC &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot; &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt; &lt;struts&gt; &lt;package name=&quot;default&quot; namespace=&quot;/&quot; extends=&quot;struts-default&quot;&gt; &lt;action name=&quot;hello&quot; class=&quot;com.itheima.action.HelloAction&quot; method=&quot;sayHello&quot;&gt; &lt;/action&gt; &lt;/package&gt; &lt;/struts&gt; 三.入门总结之Struts2的执行流程1. 执行的流程 * 编写的页面，点击超链接，请求提交到服务器端。 * 请求会先经过Struts2的核心过滤器（StrutsPrepareAndExecuteFilter） * 过滤器的功能是完成了一部分代码功能 * 就是一系列的拦截器执行了，进行一些处理工作。 * 咱们可以在struts-default.xml配置文件中看到有很多的拦截器。可以通过断点的方式来演示。 * 拦截器执行完后，会根据struts.xml的配置文件找到请求路径，找到具体的类，通过反射的方式让方法执行。 2. 总结 * JSP页面--&gt;StrutsPrepereAndExecuteFilter过滤器--&gt;执行一系列拦截器（完成了部分代码）--&gt;执行到目标Action--&gt;返回字符串--&gt;结果页面（result）--&gt;页面跳转 四.入门总结之struts.xml的配置文件1.xml引入 dtd 约束（标签语法提示）1. 先找到struts.xml的配置文件，复制http://struts.apache.org/dtds/struts-2.3.dtd，注意，不要有双引号。 * http://struts.apache.org/dtds/struts-2.3.dtd 2. 选择window -- 首选项 -- 搜索xml -- 选择xml Catalog 3. 选择添加按钮（add按钮） * key type 要选择URI * key的位置把刚才复制的路径拷贝进去。http://struts.apache.org/dtds/struts-2.3.dtd * Location要在本地能找到struts2-2.3.dtd的真实文件。点击File System，去资料中找到它 4. 如果想查看源代码 * 选择资料/struts2/struts-2.3.24-all.zip 2.入门总结之Struts2框架配置文件加载的顺序需要掌握 * 加载了哪些个配置文件（重点的） * 配置文件的名称是什么 * 配置文件的位置 * 配置文件的作用 1. Struts2框架的核心是StrutsPrepareAndExecuteFilter过滤器，该过滤器有两个功能 * Prepare -- 预处理，加载核心的配置文件 * Execute -- 执行，让部分拦截器执行 2. StrutsPrepareAndExecuteFilter过滤器会加载哪些配置文件呢？ * 通过源代码可以看到具体加载的配置文件和加载配置文件的顺序 * init_DefaultProperties(); -- 加载org/apache/struts2/default.properties * init_TraditionalXmlConfigurations(); -- 加载struts-default.xml,struts-plugin.xml,struts.xml * init_LegacyStrutsProperties(); -- 加载自定义的struts.properties. * init_CustomConfigurationProviders(); -- 加载用户自定义配置提供者 * init_FilterInitParameters() ; -- 加载web.xml 3. 重点了解的配置文件 * default.properties -- 在org/apache/struts2/目录下，代表的是配置的是Struts2的常量的值 * struts-default.xml -- 在Struts2的核心包下，代表的是Struts2核心功能的配置（Bean、拦截器、结果类型等） * struts.xml -- 重点中的重点配置，代表WEB应用的默认配置，在工作中，基本就配置它就可以了！！（可以配置常量） * web.xml -- 配置前端控制器（可以配置常量） * 注意： * 前3个配置文件是struts2框架的默认配置文件，基本不用修改。 * 后3个配置文件可以允许自己修改struts2的常量。但是有一个特点：后加载的配置文件修改的常量的值，会覆盖掉前面修改的常量的值。 4. 总结（重点掌握的配置文件） * 先加载default.properties文件，在org/apache/struts2/default.properties文件，都是常量。 * 又加载struts-default.xml配置文件，在核心的jar包最下方，struts2框架的核心功能都是在该配置文件中配置的。 * 再加载struts.xml的配置文件，在src的目录下，代表用户自己配置的配置文件 * 最后加载web.xml的配置文件 * 后加载的配置文件会覆盖掉之前加载的配置文件（在这些配置文件中可以配置常量） 5. 注意一个问题 * 哪些配置文件中可以配置常量？ * default.properties -- 默认值 * struts.xml -- 可以配置，开发中基本上都在该配置文件中配置常量 * struts.properties -- 可以配置，基本不会在该配置文件中配置 * web.xml -- 可以配置，基本不会在该配置文件中配置 * 后加载的配置文件会覆盖掉之前加载的配置！！ 4.入门总结之struts.xml配置文件的配置1. &lt;package&gt;标签，如果要配置&lt;Action&gt;的标签，那么必须要先配置&lt;package&gt;标签，代表的包的概念 * 包含的属性 * name -- 包的名称，要求是唯一的，管理action配置 * extends -- 继承，可以继承其他的包，只要继承了，那么该包就包含了其他包的功能，一般都是继承struts-default * namespace -- 名称空间，一般与&lt;action&gt;标签中的name属性共同决定访问路径（通俗话：怎么来访问action），常见的配置如下 * namespace=&quot;/&quot; -- 根名称空间 * namespace=&quot;/aaa&quot; -- 带有名称的名称空间 * abstract -- 抽象的。这个属性基本很少使用，值如果是true，那么编写的包是被继承的 2. &lt;action&gt;标签 * 代表配置action类，包含的属性 * name -- 和&lt;package&gt;标签的namespace属性一起来决定访问路径的 * class -- 配置Action类的全路径（默认值是ActionSupport类） * method -- Action类中执行的方法，如果不指定，默认值是execute 3. &lt;result&gt;标签 * action类中方法执行，返回的结果跳转的页面 * name -- 结果页面逻辑视图名称 * type -- 结果类型（默认值是转发，也可以设置其他的值） 5.入门总结之Struts2配置常量1. 可以在Struts2框架中的哪些配置文件中配置常量？ * struts.xml（必须要掌握，开发中基本上就在该配置文件中编写常量） * &lt;constant name=&quot;key&quot; value=&quot;value&quot;&gt;&lt;/constant&gt; * web.xml * 在StrutsPrepareAndExecuteFilter配置文件中配置初始化参数 * 注意：后加载的配置的文件的常量会覆盖之前加载的常量！！ 2. 需要大家了解的常量 * struts.i18n.encoding=UTF-8 -- 指定默认编码集,作用于HttpServletRequest的setCharacterEncoding方法 * struts.action.extension=action,, -- 该属性指定需要Struts 2处理的请求后缀，该属性的默认值是action，即所有匹配*.action的请求都由Struts2处理。如果用户需要指定多个请求后缀，则多个后缀之间以英文逗号（,）隔开 * struts.serve.static.browserCache=true -- 设置浏览器是否缓存静态内容,默认值为true(生产环境下使用),开发阶段最好关闭 * struts.configuration.xml.reload=false -- 当struts的配置文件修改后,系统是否自动重新加载该文件,默认值为false(生产环境下使用) * struts.devMode = false -- 开发模式下使用,这样可以打印出更详细的错误信息 6.入门总结之指定多个struts的配置文件（了解）1. 在大部分应用里，随着应用规模的增加，系统中Action的数量也会大量增加，导致struts.xml配置文件变得非常臃肿。 为了避免struts.xml文件过于庞大、臃肿，提高struts.xml文件的可读性，我们可以将一个struts.xml配置文件分解成多个配置文件，然后在struts.xml文件中包含其他配置文件。 2. 可以在&lt;package&gt;标签中，使用&lt;include&gt;标签来引入其他的struts_xx.xml的配置文件。例如： &lt;struts&gt; &lt;include file=&quot;struts-part1.xml&quot;/&gt; &lt;include file=&quot;struts-part2.xml&quot;/&gt; &lt;/struts&gt; 3. 注意注意注意（重要的事情说三遍）：&lt;include file=&quot;cn/itcast/demo2/struts-part1.xml&quot;/&gt; 五.技术分析之Action类的三种写法1. 配置文件学习完成，下面的重点是Action类的三种写法 * Action类就是一个POJO类 * 什么是POJO类，POJO（Plain Ordinary Java Object）简单的Java对象.简单记：没有继承某个类，没有实现接口，就是POJO的类。 * Action类可以实现Action接口 * Action接口中定义了5个常量，5个常量的值对应的是5个逻辑视图跳转页面（跳转的页面还是需要自己来配置），还定义了一个方法，execute方法。 * 大家需要掌握5个逻辑视图的常量 * SUCCESS -- 成功. * INPUT -- 用于数据表单校验.如果校验失败,跳转INPUT视图. * LOGIN -- 登录. * ERROR -- 错误. * NONE -- 页面不转向. * Action类可以去继承ActionSupport类（开发中这种方式使用最多） * 设置错误信息 六.技术分析之Action的访问1. 通过&lt;action&gt;标签中的method属性，访问到Action中的具体的方法。 * 传统的配置方式，配置更清晰更好理解！但是扩展需要修改配置文件等！ * 具体的实例如下： * 页面代码 * &lt;a href=&quot;${pageContext.request.contextPath}/addBook.action&quot;&gt;添加图书&lt;/a&gt; * &lt;a href=&quot;${pageContext.request.contextPath}/deleteBook.action&quot;&gt;删除图书&lt;/a&gt; * 配置文件的代码 &lt;package name=&quot;demo2&quot; extends=&quot;struts-default&quot; namespace=&quot;/&quot;&gt; &lt;action name=&quot;addBook&quot; class=&quot;cn.itcast.demo2.BookAction&quot; method=&quot;add&quot;&gt;&lt;/action&gt; &lt;action name=&quot;deleteBook&quot; class=&quot;cn.itcast.demo2.BookAction&quot; method=&quot;delete&quot;&gt;&lt;/action&gt; &lt;/package&gt; * Action的代码 public String add(){ System.out.println(&quot;添加图书&quot;); return NONE; } public String delete(){ System.out.println(&quot;删除图书&quot;); return NONE; } 2. 通配符的访问方式:(访问的路径和方法的名称必须要有某种联系.) 通配符就是 * 代表任意的字符 * 使用通配符的方式可以简化配置文件的代码编写，而且扩展和维护比较容易。 * 具体实例如下： * 页面代码 &lt;a href=&quot;${pageContext.request.contextPath}/order_add.action&quot;&gt;添加订单&lt;/a&gt; &lt;a href=&quot;${pageContext.request.contextPath}/order_delete.action&quot;&gt;删除订单&lt;/a&gt; * 配置文件代码 * &lt;action name=&quot;order_*&quot; class=&quot;cn.itcast.demo2.OrderAction&quot; method=&quot;{1}&quot;&gt;&lt;/action&gt; * Action的代码 public String add(){ System.out.println(&quot;添加订单&quot;); return NONE; } public String delete(){ System.out.println(&quot;删除订单&quot;); return NONE; } * 具体理解：在JSP页面发送请求，http://localhost/struts2_01/order_add.action，配置文件中的order_*可以匹配该请求，*就相当于变成了add，method属性的值使用{1}来代替，{1}就表示的是第一个*号的位置！！所以method的值就等于了add，那么就找到Action类中的add方法，那么add方法就执行了！ 3. 动态方法访问的方式（有的开发中也会使用这种方式） * 如果想完成动态方法访问的方式，需要开启一个常量，struts.enable.DynamicMethodInvocation = false，把值设置成true。 * 注意：不同的Struts2框架的版本，该常量的值不一定是true或者false，需要自己来看一下。如果是false，需要自己开启。 * 在struts.xml中开启该常量。 * &lt;constant name=&quot;struts.enable.DynamicMethodInvocation&quot; value=&quot;true&quot;&gt;&lt;/constant&gt; * 具体代码如下 * 页面的代码 * &lt;a href=&quot;${pageContext.request.contextPath}/product!add.action&quot;&gt;添加商品&lt;/a&gt; * &lt;a href=&quot;${pageContext.request.contextPath}/product!delete.action&quot;&gt;删除商品&lt;/a&gt; * 配置文件代码 * &lt;action name=&quot;product&quot; class=&quot;cn.itcast.demo2.ProductAction&quot;&gt;&lt;/action&gt; * Action的类的代码 public class ProductAction extends ActionSupport{ public String add(){ System.out.println(&quot;添加订单&quot;); return NONE; } public String delete(){ System.out.println(&quot;删除订单&quot;); return NONE; } }]]></content>
      <categories>
        <category>struts2</category>
      </categories>
      <tags>
        <tag>struts2</tag>
        <tag>struts2入门篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hibernate完善篇(HQL/QBC/查询策略)]]></title>
    <url>%2F2018%2F12%2F19%2Fhibernate-4%2F</url>
    <content type="text"><![CDATA[Hibernate框架的学习路线 学习的路线 * 入门篇：主要是学习框架的入门，自己搭建框架，完成增删改查的操作 * 进阶篇：主要学习一级缓存、事务管理和基本的查询 * 高级篇：主要学习一对多和多对多的操作等 * 完善篇：基本查询和查询的优化 本篇内容 1. Hibernate的查询方式 2. Hibernate的查询策略 一.Hibernate查询1.技术分析之Hibernate框架的查询方式1. 唯一标识OID的检索方式 * session.get(对象.class,OID) 2. 对象的导航的方式 3. HQL的检索方式 * Hibernate Query Language -- Hibernate的查询语言 4. QBC的检索方式 * Query By Criteria -- 条件查询 5. SQL检索方式（了解） * 本地的SQL检索 2.技术分析之HQL的查询方式概述1. HQL的介绍 * HQL(Hibernate Query Language) 是面向对象的查询语言, 它和 SQL 查询语言有些相似 * 在 Hibernate 提供的各种检索方式中, HQL 是使用最广的一种检索方式 2. HQL与SQL的关系 * HQL 查询语句是面向对象的,Hibernate负责解析HQL查询语句, 然后根据对象-关系映射文件中的映射信息, 把 HQL 查询语句翻译成相应的 SQL 语句. * HQL 查询语句中的主体是域模型中的类及类的属性 * SQL 查询语句是与关系数据库绑定在一起的. SQL查询语句中的主体是数据库表及表的字段 3.技术分析之HQL的查询演示1. HQL基本的查询格式 * 支持方法链的编程，即直接调用list()方法 * 简单的代码如下 * session.createQuery(&quot;from Customer&quot;).list(); 2. 使用别名的方式 * 可以使用别名的方式 * session.createQuery(&quot;from Customer c&quot;).list(); * session.createQuery(&quot;select c from Customer c&quot;).list(); 3. 排序查询 * 排序查询和SQL语句中的排序的语法是一样的 * 升序 * session.createQuery(&quot;from Customer order by cust_id&quot;).list(); * 降序 * session.createQuery(&quot;from Customer order by cust_id desc&quot;).list(); 4. 分页查询 * Hibernate框架提供了分页的方法，咱们可以调用方法来完成分页 * 两个方法如下 * setFirstResult(a) -- 从哪条记录开始，如果查询是从第一条开启，值是0 * setMaxResults(b) -- 每页查询的记录条数 * 演示代码如下 * List&lt;LinkMan&gt; list = session.createQuery(&quot;from LinkMan&quot;).setFirstResult(0).setMaxResults().list(); 5. 带条件的查询 * setParameter(&quot;?号的位置，默认从0开始&quot;,&quot;参数的值&quot;); 不用考虑参数的具体类型 * 按位置绑定参数的条件查询（指定下标值，默认从0开始） * 按名称绑定参数的条件查询（HQL语句中的 ? 号换成 :名称 的方式） * 例如代码如下 Query query = session.createQuery(&quot;from Linkman where lkm_name like ? order by lkm_id desc&quot;); query.setFirstResult(0).setMaxResults(3); query.setParameter(0, &quot;%熊%&quot;); List&lt;Linkman&gt; list = query.list(); for (Linkman linkman : list) { System.out.println(linkman); } 4.HQL的投影查询1. 投影查询就是想查询某一字段的值或者某几个字段的值 2. 投影查询的案例 * 如果查询多个字段，例如下面这种方式 List&lt;Object[]&gt; list = session.createQuery(&quot;select c.cust_name,c.cust_level from Customer c&quot;).list(); for (Object[] objects : list) { System.out.println(Arrays.toString(objects)); } * 如果查询两个字段，也可以把这两个字段封装到对象中 * 先在持久化类中提供对应字段的构造方法 * 使用下面这种HQL语句的方式 List&lt;Customer&gt; list = session.createQuery(&quot;select new Customer(c.cust_name,c.cust_level) from Customer c&quot;).list(); for (Customer customer : list) { System.out.println(customer); } 5.技术分析之聚合函数查询1. 获取总的记录数 Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); List&lt;Number&gt; list = session.createQuery(&quot;select count(c) from Customer c&quot;).list(); Long count = list.get(0).longValue(); System.out.println(count); tr.commit(); 2. 获取某一列数据的和 Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); List&lt;Number&gt; list = session.createQuery(&quot;select sum(c.cust_id) from Customer c&quot;).list(); Long count = list.get(0).longValue(); System.out.println(count); tr.commit(); 6.技术分析之QBC检索方式 QBC：Query By Criteria 按条件进行查询 1. 简单查询，使用的是Criteria接口 List&lt;Customer&gt; list = session.createCriteria(Customer.class).list(); for (Customer customer : list) { System.out.println(customer); } 2. 排序查询 * 需要使用addOrder()的方法来设置参数，参数使用org.hibernate.criterion.Order对象 * 具体代码如下： Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); Criteria criteria = session.createCriteria(Linkman.class); // 设置排序 criteria.addOrder(Order.desc(&quot;lkm_id&quot;)); List&lt;Linkman&gt; list = criteria.list(); for (Linkman linkman : list) { System.out.println(linkman); } tr.commit(); 3. 分页查询 * QBC的分页查询也是使用两个方法 * setFirstResult(); * setMaxResults(); * 代码如下; Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); Criteria criteria = session.createCriteria(Linkman.class); // 设置排序 criteria.addOrder(Order.desc(&quot;lkm_id&quot;)); criteria.setFirstResult(0); criteria.setMaxResults(3); List&lt;Linkman&gt; list = criteria.list(); for (Linkman linkman : list) { System.out.println(linkman); } tr.commit(); 4. 条件查询（Criterion是查询条件的接口，Restrictions类是Hibernate框架提供的工具类，使用该工具类来设置查询条件） * 条件查询使用Criteria接口的add方法，用来传入条件。 * 使用Restrictions的添加条件的方法，来添加条件，例如： * Restrictions.eq -- 相等 * Restrictions.gt -- 大于号 * Restrictions.ge -- 大于等于 * Restrictions.lt -- 小于 * Restrictions.le -- 小于等于 * Restrictions.between -- 在之间 * Restrictions.like -- 模糊查询 * Restrictions.in -- 范围 * Restrictions.and -- 并且 * Restrictions.or -- 或者 * 测试代码如下 Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); Criteria criteria = session.createCriteria(Linkman.class); // 设置排序 criteria.addOrder(Order.desc(&quot;lkm_id&quot;)); // 设置查询条件 criteria.add(Restrictions.or(Restrictions.eq(&quot;lkm_gender&quot;, &quot;男&quot;), Restrictions.gt(&quot;lkm_id&quot;, 3L))); List&lt;Linkman&gt; list = criteria.list(); for (Linkman linkman : list) { System.out.println(linkman); } tr.commit(); 5. 聚合函数查询（Projection的聚合函数的接口，而Projections是Hibernate提供的工具类，使用该工具类设置聚合函数查询） * 使用QBC的聚合函数查询，需要使用criteria.setProjection()方法 * 具体的代码如下 Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); Criteria criteria = session.createCriteria(Linkman.class); criteria.setProjection(Projections.rowCount()); List&lt;Number&gt; list = criteria.list(); Long count = list.get(0).longValue(); System.out.println(count); tr.commit(); 7.技术分析之离线条件查询1. 离线条件查询使用的是DetachedCriteria接口进行查询，离线条件查询对象在创建的时候，不需要使用Session对象，只是在查询的时候使用Session对象即可。 2. 创建离线条件查询对象 * DetachedCriteria criteria = DetachedCriteria.forClass(Linkman.class); 3. 具体的代码如下 Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); DetachedCriteria criteria = DetachedCriteria.forClass(Linkman.class); // 设置查询条件 criteria.add(Restrictions.eq(&quot;lkm_gender&quot;, &quot;男&quot;)); // 查询数据 List&lt;Linkman&gt; list = criteria.getExecutableCriteria(session).list(); for (Linkman linkman : list) { System.out.println(linkman); } tr.commit(); 8.技术分析之SQL查询方式（了解）基本语法 Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); SQLQuery sqlQuery = session.createSQLQuery(&quot;select * from cst_linkman where lkm_gender = ?&quot;); sqlQuery.setParameter(0,&quot;男&quot;); sqlQuery.addEntity(Linkman.class); List&lt;Linkman&gt; list = sqlQuery.list(); System.out.println(list); tr.commit(); 9.技术分析之HQL多表查询1. 多表的查询进来使用HQL语句进行查询，HQL语句和SQL语句的查询语法比较类似。 * 内连接查询 * 显示内连接 * select * from customers c inner join orders o on c.cid = o.cno; * 隐式内连接 * select * from customers c,orders o where c.cid = o.cno; * 外连接查询 * 左外连接 * select * from customers c left join orders o on c.cid = o.cno; * 右外连接 * select * from customers c right join orders o on c.cid = o.cno; 2. HQL的多表查询 * 迫切和非迫切： * 非迫切返回结果是Object[] * 迫切连接返回的结果是对象，把客户的信息封装到客户的对象中，把订单的信息封装到客户的Set集合中。 3. 内连接查询 * 内连接使用 inner join ，默认返回的是Object数组 Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); List&lt;Object[]&gt; list = session.createQuery(&quot;from Customer c inner join c.linkmans&quot;).list(); for (Object[] objects : list) { System.out.println(Arrays.toString(objects)); } tr.commit(); * 迫切内连接:inner join fetch ，返回的是实体对象 Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); List&lt;Customer&gt; list = session.createQuery(&quot;from Customer c inner join fetch c.linkmans&quot;).list(); Set&lt;Customer&gt; set = new HashSet&lt;Customer&gt;(list); for (Customer customer : set) { System.out.println(customer); } tr.commit(); 4. 左外连接查询 * 左外连接: 封装成List&lt;Object[]&gt; * 迫切左外连接 Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); List&lt;Customer&gt; list = session.createQuery(&quot;from Customer c left join fetch c.linkmans&quot;).list(); Set&lt;Customer&gt; set = new HashSet&lt;Customer&gt;(list); for (Customer customer : set) { System.out.println(customer); } tr.commit(); 二.查询功能优化1.技术分析之延迟加载1. 延迟加载先获取到代理对象，当真正使用到该对象中的属性的时候，才会发送SQL语句，是Hibernate框架提升性能的方式 2. 类级别的延迟加载 * Session对象的load方法默认就是延迟加载 * Customer c = session.load(Customer.class, 1L);没有发送SQL语句，当使用该对象的属性时，才发送SQL语句 * 使类级别的延迟加载失效 * 在&lt;class&gt;标签上配置lazy=”false” * Hibernate.initialize(Object proxy); 3. 关联级别的延迟加载（查询某个客户，当查看该客户下的所有联系人是是否是延迟加载） * 默认是延迟加载 Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); Customer c = session.get(Customer.class, 1L); System.out.println(&quot;=============&quot;); System.out.println(c.getLinkmans().size()); tr.commit(); 2.技术分析之Hibernate框架的查询策略1. 查询策略：使用Hibernate查询一个对象的时候，查询其关联对象.应该如何查询.是Hibernate的一种优化手段!!! 2. Hibernate框架的检索策略解决的问题 * 查询的时机 Customer c1 = (Customer) session.get(Customer.class, 1); System.out.println(c1.getLinkmans().size()); * lazy属性解决查询的时机的问题，需要配置是否采用延迟加载！！ * 查询的语句形式 List&lt;Customer&gt; list = session.createQuery(&quot;from Customer&quot;).list(); for(Customer c : list){ System.out.println(c.getLinkmans()); } * fetch属性就可以解决查询语句的形式的问题！！ 3.技术分析之在set标签上配置策略1. 在&lt;set&gt;标签上使用fetch和lazy属性 * fetch的取值 -- 控制SQL语句生成的格式 * select -- 默认值.发送查询语句 * join -- 连接查询.发送的是一条迫切左外连接!!!配置了join.lazy就失效了 * subselect -- 子查询.发送一条子查询查询其关联对象.(需要使用list()方法进行测试) * lazy的取值 -- 查找关联对象的时候是否采用延迟! * true -- 默认.延迟 * false -- 不延迟 * extra -- 及其懒惰 2. set标签上的默认值是fetch=&quot;select&quot;和lazy=&quot;true&quot; 3. 总结：Hibernate框架都采用了默认值，开发中基本上使用的都是默认值。特殊的情况。 4.技术分析之在man-to-one标签上配置策略1. 在&lt;many-to-one&gt;标签上使用fetch和lazy属性 * fetch的取值 -- 控制SQL的格式. * select -- 默认。发送基本select语句查询 * join -- 发送迫切左外连接查询 * lazy的取值 -- 控制加载关联对象是否采用延迟. * false -- 不采用延迟加载. * proxy -- 默认值.代理.现在是否采用延迟. * 由另一端的&lt;class&gt;上的lazy确定.如果这端的class上的lazy=”true”.proxy的值就是true(延迟加载). * 如果class上lazy=”false”.proxy的值就是false(不采用延迟.) 2. 在&lt;many-to-one&gt;标签上的默认值是fetch=&quot;select&quot;和proxy]]></content>
      <categories>
        <category>hibernate</category>
      </categories>
      <tags>
        <tag>hibernate</tag>
        <tag>hibernate HQL/QBC</tag>
        <tag>hibernate完善篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hibernate高级篇(一对多/多对多)]]></title>
    <url>%2F2018%2F12%2F18%2Fhibernate-3%2F</url>
    <content type="text"><![CDATA[Hibernate框架的学习路线 学习的路线 * 入门篇：主要是学习框架的入门，自己搭建框架，完成增删改查的操作 * 进阶篇：主要学习一级缓存、事务管理和基本的查询 * 高级篇：主要学习一对多和多对多的操作等 * 完善篇：基本查询和查询的优化 今天内容 一. 一对多 二. 多对多 一.一对多1.技术分析之Hibernate的关联关系映射之 一对多 映射（重点）1. 编写客户和联系人的JavaBean程序（注意一对多的编写规则） * 客户的JavaBean如下 public class Customer { private Long cust_id; private String cust_name; private Long cust_user_id; private Long cust_create_id; private String cust_source; private String cust_industry; private String cust_level; private String cust_linkman; private String cust_phone; private String cust_mobile; private Set&lt;Linkman&gt; linkmans = new HashSet&lt;Linkman&gt;(); } * 联系人的JavaBean如下 public class Linkman { private Long lkm_id; private String lkm_name; private String lkm_gender; private String lkm_phone; private String lkm_mobile; private String lkm_email; private String lkm_qq; private String lkm_position; private String lkm_memo; private Customer customer; } 2. 编写客户和联系人的映射配置文件（注意一对多的配置编写） * 客户的映射配置文件如下 &lt;class name=&quot;com.itheima.domain.Customer&quot; table=&quot;cst_customer&quot;&gt; &lt;id name=&quot;cust_id&quot; column=&quot;cust_id&quot;&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;property name=&quot;cust_name&quot; column=&quot;cust_name&quot;/&gt; &lt;property name=&quot;cust_user_id&quot; column=&quot;cust_user_id&quot;/&gt; &lt;property name=&quot;cust_create_id&quot; column=&quot;cust_create_id&quot;/&gt; &lt;property name=&quot;cust_source&quot; column=&quot;cust_source&quot;/&gt; &lt;property name=&quot;cust_industry&quot; column=&quot;cust_industry&quot;/&gt; &lt;property name=&quot;cust_level&quot; column=&quot;cust_level&quot;/&gt; &lt;property name=&quot;cust_linkman&quot; column=&quot;cust_linkman&quot;/&gt; &lt;property name=&quot;cust_phone&quot; column=&quot;cust_phone&quot;/&gt; &lt;property name=&quot;cust_mobile&quot; column=&quot;cust_mobile&quot;/&gt; &lt;set name=&quot;linkmans&quot;&gt; &lt;key column=&quot;lkm_cust_id&quot;/&gt; &lt;one-to-many class=&quot;com.itheima.domain.Linkman&quot;/&gt; &lt;/set&gt; &lt;/class&gt; * 联系人的映射配置文件如下 &lt;class name=&quot;com.itheima.domain.Linkman&quot; table=&quot;cst_linkman&quot;&gt; &lt;id name=&quot;lkm_id&quot; column=&quot;lkm_id&quot;&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;property name=&quot;lkm_name&quot; column=&quot;lkm_name&quot;/&gt; &lt;property name=&quot;lkm_gender&quot; column=&quot;lkm_gender&quot;/&gt; &lt;property name=&quot;lkm_phone&quot; column=&quot;lkm_phone&quot;/&gt; &lt;property name=&quot;lkm_mobile&quot; column=&quot;lkm_mobile&quot;/&gt; &lt;property name=&quot;lkm_email&quot; column=&quot;lkm_email&quot;/&gt; &lt;property name=&quot;lkm_qq&quot; column=&quot;lkm_qq&quot;/&gt; &lt;property name=&quot;lkm_position&quot; column=&quot;lkm_position&quot;/&gt; &lt;property name=&quot;lkm_memo&quot; column=&quot;lkm_memo&quot;/&gt; &lt;many-to-one name=&quot;customer&quot; class=&quot;com.itheima.domain.Customer&quot; column=&quot;lkm_cust_id&quot;/&gt; &lt;/class&gt; 2.技术分析之保存客户和联系人的数据进行双向关联进行数据的保存 3.技术分析之级联保存1. 测试：如果现在代码只插入其中的一方的数据 * 如果只保存其中的一方的数据，那么程序会抛出异常。 * 如果想完成只保存一方的数据，并且把相关联的数据都保存到数据库中，那么需要配置级联！！ * 级联保存是方向性 2. 级联保存效果 * 级联保存：保存一方同时可以把关联的对象也保存到数据库中！！ * 使用cascade=&quot;save-update&quot; 4.技术分析之级联删除1. 先来给大家在数据库中演示含有外键的删除客户功能，那么SQL语句是会报出错误的 * 例如：delete from customers where cid = 1; 2. 如果使用Hibernate框架直接删除客户的时候，测试发现是可以删除的 3. 上述的删除是普通的删除，那么也可以使用级联删除，注意：级联删除也是有方向性的！！ * &lt;many-to-one cascade=&quot;delete&quot; /&gt; 5.技术分析之级联的取值（cascade的取值）和孤儿删除1. 需要大家掌握的取值如下 * none -- 不使用级联 * save-update -- 级联保存或更新 * delete -- 级联删除 * delete-orphan -- 孤儿删除.(注意：只能应用在一对多关系) * all -- 除了delete-orphan的所有情况.（包含save-update delete） * all-delete-orphan -- 包含了delete-orphan的所有情况.（包含save-update delete delete-orphan） 2. 孤儿删除（孤子删除），只有在一对多的环境下才有孤儿删除 * 在一对多的关系中,可以将一的一方认为是父方.将多的一方认为是子方.孤儿删除:在解除了父子关系的时候.将子方记录就直接删除。 * &lt;many-to-one cascade=&quot;delete-orphan&quot; /&gt; 6.技术分析之让某一方放弃外键的维护，为多对多做准备1. 先测试双方都维护外键的时候，会产生多余的SQL语句。 * 想修改客户和联系人的关系，进行双向关联，双方都会维护外键，会产生多余的SQL语句。 * 产生的原因：session的一级缓存中的快照机制，会让双方都更新数据库，产生了多余的SQL语句。 2. 如果不想产生多余的SQL语句，那么需要一方来放弃外键的维护！ * 在&lt;set&gt;标签上配置一个inverse=”true”.true:放弃.false:不放弃.默认值是false * &lt;inverse=&quot;true&quot;&gt; 7.技术分析之cascade和inverse的区别1. cascade用来级联操作（保存、修改和删除） 2. inverse用来维护外键的 二.Hibernate的关联关系映射之多对多映射1.技术分析之多对多JavaBean的编写1. 编写用户和角色的JavaBean * 用户的JavaBean代码如下 public class User { private Long user_id; private String user_code; private String user_name; private String user_password; private String user_state; private Set&lt;Role&gt; roles = new HashSet&lt;Role&gt;(); } * 角色的JavaBean代码如下 public class Role { private Long role_id; private String role_name; private String role_memo; private Set&lt;User&gt; users = new HashSet&lt;User&gt;(); } 2. 用户和角色的映射配置文件如下 * 用户的映射配置文件如下 &lt;class name=&quot;com.itheima.domain.User&quot; table=&quot;sys_user&quot;&gt; &lt;id name=&quot;user_id&quot; column=&quot;user_id&quot;&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;property name=&quot;user_code&quot; column=&quot;user_code&quot;/&gt; &lt;property name=&quot;user_name&quot; column=&quot;user_name&quot;/&gt; &lt;property name=&quot;user_password&quot; column=&quot;user_password&quot;/&gt; &lt;property name=&quot;user_state&quot; column=&quot;user_state&quot;/&gt; &lt;set name=&quot;roles&quot; table=&quot;sys_user_role&quot;&gt; &lt;key column=&quot;user_id&quot;/&gt; &lt;many-to-many class=&quot;com.itheima.domain.Role&quot; column=&quot;role_id&quot;/&gt; &lt;/set&gt; &lt;/class&gt; * 角色的映射配置文件如下 &lt;class name=&quot;com.itheima.domain.Role&quot; table=&quot;sys_role&quot;&gt; &lt;id name=&quot;role_id&quot; column=&quot;role_id&quot;&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;property name=&quot;role_name&quot; column=&quot;role_name&quot;/&gt; &lt;property name=&quot;role_memo&quot; column=&quot;role_memo&quot;/&gt; &lt;set name=&quot;users&quot; table=&quot;sys_user_role&quot;&gt; &lt;key column=&quot;role_id&quot;/&gt; &lt;many-to-many class=&quot;com.itheima.domain.User&quot; column=&quot;user_id&quot;/&gt; &lt;/set&gt; &lt;/class&gt; 3. 多对多进行双向关联的时候:必须有一方去放弃外键维护权 2.技术分析之多对多的级联保存级联保存 * &lt;set cascade=&quot;save-update&quot;&gt; 3.级联删除（在多对多中是很少使用的）]]></content>
      <categories>
        <category>hibernate</category>
      </categories>
      <tags>
        <tag>hibernate</tag>
        <tag>hibernate高级篇</tag>
        <tag>hibernate一对多</tag>
        <tag>hibernate多对多</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hibernate进阶篇(持久化对象/session/事务)]]></title>
    <url>%2F2018%2F12%2F17%2Fhibernate-2%2F</url>
    <content type="text"><![CDATA[Hibernate框架的学习路线 学习的路线 * 入门篇：主要是学习框架的入门，自己搭建框架，完成增删改查的操作 * 进阶篇：主要学习一级缓存、事务管理和基本的查询 * 高级篇：主要学习一对多和多对多的操作等 * 完善篇：基本查询和查询的优化 本篇内容（接hibernate入门篇 一. Hibernate持久化对象的状态 二. Hibernate的一级缓存 三. Hibernate的事务与并发 四. Hibernate的基本查询 一.Hibernate的持久化类1.什么是持久化类持久化类:就是一个Java类（JavaBean），这个Java类与表建立了映射关系就可以成为是持久化类。 持久化类 = JavaBean + xxx.hbm.xml 2.持久化类的编写规则1. 提供一个无参数 public访问控制符的构造器 -- 底层需要进行反射. 2. 提供一个标识属性，映射数据表主键字段 -- 唯一标识OID.数据库中通过主键.Java对象通过地址确定对象.持久化类通过唯一标识OID确定记录 3. 所有属性提供public访问控制符的 set或者get 方法 4. 标识属性应尽量使用基本数据类型的包装类型 3.区分自然主键和代理主键1. 创建表的时候 * 自然主键:对象本身的一个属性.创建一个人员表,每个人都有一个身份证号. (唯一的)使用身份证号作为表的主键.自然主键.（开发中不会使用这种方式） * 代理主键:不是对象本身的一个属性.创建一个人员表,为每个人员单独创建一个字段. 用这个字段作为主键.代理主键.（开发中推荐使用这种方式） 2. 创建表的时候尽量使用 代理主键 创建表 4.主键的生成策略1. increment:适用于short,int,long作为主键.不是使用的数据库自动增长机制. * Hibernate中提供的一种增长机制. * 先进行查询 :select max(id) from user; * 再进行插入 :获得最大值+1作为新的记录的主键. * 问题:不能在集群环境下或者有并发访问的情况下使用. 2. identity:适用于short,int,long作为主键。但是这个必须使用在有自动增长数据库中.采用的是数据库底层的自动增长机制. * 底层使用的是数据库的自动增长(auto_increment).像Oracle数据库没有自动增长. 3. sequence:适用于short,int,long作为主键.底层使用的是序列的增长方式. * Oracle数据库底层没有自动增长,想自动增长需要使用序列. 4. uuid:适用于char,varchar类型的作为主键. * 使用随机的字符串作为主键. 5. native:本地策略.根据底层的数据库不同,自动选择适用于该种数据库的生成策略.(short,int,long) * 如果底层使用的MySQL数据库:相当于identity. * 如果底层使用Oracle数据库:相当于sequence. 6. assigned:主键的生成不用Hibernate管理了.必须手动设置主键. 5.Hibernate持久化对象的状态1. Hibernate的持久化类 * 持久化类:Java类与数据库的某个表建立了映射关系.这个类就称为是持久化类. * 持久化类 = Java类 + hbm的配置文件 2. Hibernate的持久化类的状态 * Hibernate为了管理持久化类：将持久化类分成了三个状态 * 瞬时态:Transient Object * 没有持久化标识OID, 没有被纳入到Session对象的管理. * 持久态:Persistent Object * 有持久化标识OID,已经被纳入到Session对象的管理. * 脱管态:Detached Object * 有持久化标识OID,没有被纳入到Session对象的管理. 6.Hibernate持久化对象的状态的转换1. 瞬时态 -- 没有持久化标识OID, 没有被纳入到Session对象的管理 * 获得瞬时态的对象 * User user = new User() * 瞬时态对象转换持久态 * save()/saveOrUpdate(); * 瞬时态对象转换成脱管态 * user.setId(1) 2. 持久态 -- 有持久化标识OID,已经被纳入到Session对象的管理 * 获得持久态的对象 * get()/load(); * 持久态转换成瞬时态对象 * delete(); --- 比较有争议的，进入特殊的状态(删除态:Hibernate中不建议使用的) * 持久态对象转成脱管态对象 * session的close()/evict()/clear(); 3. 脱管态 -- 有持久化标识OID,没有被纳入到Session对象的管理 * 获得托管态对象:不建议直接获得脱管态的对象. * User user = new User(); * user.setId(1); * 脱管态对象转换成持久态对象 * update();/saveOrUpdate()/lock(); * 脱管态对象转换成瞬时态对象 * user.setId(null); 4. 注意：持久态对象有自动更新数据库的能力!!! 二.Hibernate的一级缓存1.Session对象的一级缓存（重点）1. 什么是缓存？ * 其实就是一块内存空间,将数据源（数据库或者文件）中的数据存放到缓存中.再次获取的时候 ,直接从缓存中获取.可以提升程序的性能！ 2. Hibernate框架提供了两种缓存 * 一级缓存 -- 自带的不可卸载的.一级缓存的生命周期与session一致.一级缓存称为session级别的缓存. * 二级缓存 -- 默认没有开启，需要手动配置才可以使用的.二级缓存可以在多个session中共享数据,二级缓存称为是sessionFactory级别的缓存. 3. Session对象的缓存概述 * Session接口中,有一系列的java的集合,这些java集合构成了Session级别的缓存(一级缓存).将对象存入到一级缓存中,session没有结束生命周期,那么对象在session中存放着 * 内存中包含Session实例 --&gt; Session的缓存（一些集合） --&gt; 集合中包含的是缓存对象！ 4. 证明一级缓存的存在，编写查询的代码即可证明 * 在同一个Session对象中两次查询，可以证明使用了缓存 5. Hibernate框架是如何做到数据发生变化时进行同步操作的呢？ * 使用get方法查询User对象 * 然后设置User对象的一个属性，注意：没有做update操作。发现，数据库中的记录也改变了。 * 利用快照机制来完成的（SnapShot） 2.控制Session的一级缓存（了解）1. 学习Session接口中与一级缓存相关的方法 * Session.clear() -- 清空缓存。 * Session.evict(Object entity) -- 从一级缓存中清除指定的实体对象。 * Session.flush() -- 刷出缓存 三.Hibernate中的事务与并发1.事务相关的概念1. 什么是事务 * 事务就是逻辑上的一组操作，组成事务的各个执行单元，操作要么全都成功，要么全都失败. * 转账的例子：冠希给美美转钱，扣钱，加钱。两个操作组成了一个事情！ 2. 事务的特性 * 原子性 -- 事务不可分割. * 一致性 -- 事务执行的前后数据的完整性保持一致. * 隔离性 -- 一个事务执行的过程中,不应该受到其他的事务的干扰. * 持久性 -- 事务一旦提交,数据就永久保持到数据库中. 3. 如果不考虑隔离性:引发一些读的问题 * 脏读 -- 一个事务读到了另一个事务未提交的数据. * 不可重复读 -- 一个事务读到了另一个事务已经提交的update数据,导致多次查询结果不一致. * 虚读 -- 一个事务读到了另一个事务已经提交的insert数据,导致多次查询结构不一致. 4. 通过设置数据库的隔离级别来解决上述读的问题 * 未提交读:以上的读的问题都有可能发生. * 已提交读:避免脏读,但是不可重复读，虚读都有可能发生. * 可重复读:避免脏读，不可重复读.但是虚读是有可能发生. * 串行化:以上读的情况都可以避免. 5. 如果想在Hibernate的框架中来设置隔离级别，需要在hibernate.cfg.xml的配置文件中通过标签来配置 * 通过：hibernate.connection.isolation = 4 来配置 * 取值 * 1—Read uncommitted isolation * 2—Read committed isolation * 4—Repeatable read isolation * 8—Serializable isolation 2.丢失更新的问题1. 如果不考虑隔离性，也会产生写入数据的问题，这一类的问题叫丢失更新的问题。 2. 例如：两个事务同时对某一条记录做修改，就会引发丢失更新的问题。 * A事务和B事务同时获取到一条数据，同时再做修改 * 如果A事务修改完成后，提交了事务 * B事务修改完成后，不管是提交还是回滚，如果不做处理，都会对数据产生影响 3. 解决方案有两种 * 悲观锁 * 采用的是数据库提供的一种锁机制，如果采用做了这种机制，在SQL语句的后面添加 for update 子句 * 当A事务在操作该条记录时，会把该条记录锁起来，其他事务是不能操作这条记录的。 * 只有当A事务提交后，锁释放了，其他事务才能操作该条记录 * 乐观锁 * 采用版本号的机制来解决的。会给表结构添加一个字段version=0，默认值是0 * 当A事务在操作完该条记录，提交事务时，会先检查版本号，如果发生版本号的值相同时，才可以提交事务。同时会更新版本号version=1. * 当B事务操作完该条记录时，提交事务时，会先检查版本号，如果发现版本不同时，程序会出现错误。 4. 使用Hibernate框架解决丢失更新的问题 * 悲观锁 * 使用session.get(Customer.class, 1,LockMode.UPGRADE); 方法 * 乐观锁 * 1.在对应的JavaBean中添加一个属性，名称可以是任意的。例如：private Integer version; 提供get和set方法 * 2.在映射的配置文件中，提供&lt;version name=&quot;version&quot;/&gt;标签即可。 3.绑定本地的Session1. 之前在讲JavaWEB的事务的时候，需要在业务层使用Connection来开启事务， * 一种是通过参数的方式传递下去 * 另一种是把Connection绑定到ThreadLocal对象中 2. 现在的Hibernate框架中，使用session对象开启事务，所以需要来传递session对象，框架提供了ThreadLocal的方式 * 需要在hibernate.cfg.xml的配置文件中提供配置 * &lt;property name=&quot;hibernate.current_session_context_class&quot;&gt;thread&lt;/property&gt; * 重新HibernateUtil的工具类，使用SessionFactory的getCurrentSession()方法，获取当前的Session对象。并且该Session对象不用手动关闭，线程结束了，会自动关闭。 public static Session getCurrentSession(){ return factory.getCurrentSession(); } * 注意：想使用getCurrentSession()方法，必须要先配置才能使用。 四.Hibernate框架的查询方式1.Query查询接口具体的查询代码如下: // 1.查询所有记录 /*Query query = session.createQuery(&quot;from Customer&quot;); List&lt;Customer&gt; list = query.list(); System.out.println(list);*/ // 2.条件查询: /*Query query = session.createQuery(&quot;from Customer where name = ?&quot;); query.setString(0, &quot;李健&quot;); List&lt;Customer&gt; list = query.list(); System.out.println(list);*/ // 3.条件查询: /*Query query = session.createQuery(&quot;from Customer where name = :aaa and age = :bbb&quot;); query.setString(&quot;aaa&quot;, &quot;李健&quot;); query.setInteger(&quot;bbb&quot;, 38); List&lt;Customer&gt; list = query.list(); System.out.println(list);*/ 2.Criteria查询接口（做条件查询非常合适）具体的查询代码如下 // 1.查询所有记录 /*Criteria criteria = session.createCriteria(Customer.class); List&lt;Customer&gt; list = criteria.list(); System.out.println(list);*/ // 2.条件查询 /*Criteria criteria = session.createCriteria(Customer.class); criteria.add(Restrictions.eq(&quot;name&quot;, &quot;李健&quot;)); List&lt;Customer&gt; list = criteria.list(); System.out.println(list);*/ // 3.条件查询 /*Criteria criteria = session.createCriteria(Customer.class); criteria.add(Restrictions.eq(&quot;name&quot;, &quot;李健&quot;)); criteria.add(Restrictions.eq(&quot;age&quot;, 38)); List&lt;Customer&gt; list = criteria.list(); System.out.println(list);*/]]></content>
      <categories>
        <category>hibernate</category>
      </categories>
      <tags>
        <tag>hibernate</tag>
        <tag>hibernate进阶篇</tag>
        <tag>hibernate session</tag>
        <tag>hibernate 持久化</tag>
        <tag>hibernate 事务</tag>
        <tag>hibernate 一级缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx介绍篇(反向代理/负载均衡/动静分离/session共享)]]></title>
    <url>%2F2018%2F12%2F17%2Fnginx-introduce%2F</url>
    <content type="text"><![CDATA[一.nginx概述1.什么是nginxNginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。 2.为什么使用Nginx?背景:互联网飞速发展的今天,大用户量高并发已经成为互联网的主体.怎样能让一个网站能够承载几万个或几十万个用户的持续访问呢？这是一些中小网站急需解决的问题。用单机tomcat搭建的网站，在比较理想的状态下能够承受的并发访问量在150到200左右。按照并发访问量占总用户数量的5%到10%这样计算，单点tomcat网站的用户人数在1500到4000左右。对于一个为全国范围提供服务的网站显然是不够用的，为了解决这个问题引入了负载均衡方法。负载均衡就是一个web服务器解决不了的问题可以通过多个web服务器来平均分担压力来解决，并发过来的请求被平均分配到多个后台web服务器来处理，这样压力就被分解开来。 负载均衡服务器分为两种一种是通过硬件实现的负载均衡服务器，简称硬负载例如：f5。另一种是通过软件来实现的负载均衡，简称软负载:例如apache和nginx。硬负载和软负载相比前者作用的网络层次比较多可以作用到socket接口的数据链路层对发出的请求进行分组转发但是价格成本比较贵，而软负载作用的层次在http协议层之上可以对http请求进行分组转发并且因为是开源的所以几乎是0成本，并且阿里巴巴，京东等电商网站使用的都是Nginx服务器。 二.nginx的功能实现完成Nginx负载均衡,那么需要先来介绍Tomcat的安装和配置,我们首先要来配置Tomcat完成集群的配置.因为我们没有多台服务器运行Tomcat.那么我们可以模拟在一台服务器上运行多个Tomcat程序. 1.使用Tomcat配置Tomcat集群:修改 nginx/conf/nginx.conf 文件： 2session共享问题问题:通过以上的配置我们已经可以通过访问http://192.168.93.88/project访问到不同的tomcat来分担服务器端的压力.请求负载过程中会话信息不能丢失.那么需要在多个tomcat中session需要共享. 配置Tomcat的session共享可以有三种解决方案: 第一种是以负载均衡服务器本身提供的session共享策略，每种服务期的配置是不一样的并且nginx本身是没有的。（linux常用 一个ip只能始终访问一台服务器） 第二种是利用web容器本身的session共享策略来配置共享。针对于weblogic这种方式还是靠普的。但是针对于tomcat这种方式存在很大的缺陷，主要因为是依靠广播方式来实现的session复制，会浪费很多带宽导致整个网络反映缓慢。官网也建议这种方式最好不要超过4台tomcat,具体的内容可参考/webapps/docs/cluster-howto.html里面有详细的说明。下面是具体的配置过程（windows常用） 第三种是Tomcat集群+redis的Session共享配置方法. 二.nginx反向代理/负载均衡/动静分离 理解1.nginx反向代理反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。 2.nginx负载均衡负载均衡，英文名称为Load Balance，是指建立在现有网络结构之上，并提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。其原理就是数据流量分摊到多个服务器上执行，减轻每台服务器的压力，多台服务器共同完成工作任务，从而提高了数据的吞吐量。 3.nginx动静分离为了提高网站的响应速度，减轻程序服务器（Tomcat，Jboss等）的负载，对于静态资源比如图片，js，css等文件，我们可以在反向代理服务器中进行缓存，这样浏览器在请求一个静态资源时，代理服务器就可以直接处理，而不用将请求转发给后端服务器。用户请求的动态文件比如servlet,jsp则转发给Tomcat，Jboss服务器处理，这就是动静分离。]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>nginx 功能概述</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hibernate入门篇(框架搭建)]]></title>
    <url>%2F2018%2F12%2F16%2Fhibernate-1%2F</url>
    <content type="text"><![CDATA[Hibernate框架的学习路线 学习的路线 * 入门篇：主要是学习框架的入门，自己搭建框架，完成增删改查的操作 * 进阶篇：主要学习一级缓存、事务管理和基本的查询 * 高级篇：主要学习一对多和多对多的操作等 * 完善篇：基本查询和查询的优化 一.Hibernate框架的概述1. Hibernate框架的概述 * Hibernate称为 * Hibernate是一个开放源代码的对象关系映射（ORM）框架，它对JDBC进行了非常轻量级的对象封装，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 * Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用。 * Hibernate是轻量级JavaEE应用的持久层解决方案，是一个关系数据库ORM框架 2. 记住：Hibernate是一个持久层的ORM框架！！！ 二.什么是ORM（对象关系映射） 1. ORM映射：Object Relational Mapping * O：面向对象领域的Object（JavaBean对象） * R：关系数据库领域的Relational（表的结构） * M：映射Mapping（XML的配置文件） 2. 简单一句话：Hibernate使程序员通过操作对象的方式来操作数据库表记录 三.Hibernate优点1. 优点 * Hibernate对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码 * Hibernate是一个基于jdbc的主流持久化框架，是一个优秀的orm实现，它很大程度的简化了dao层编码工作 * Hibernate的性能非常好，因为它是一个轻量级框架。映射的灵活性很出色。它支持很多关系型数据库，从一对一到多对多的各种复杂关系 四.技术分析之Hibernate框架的快速入门1.第一步：下载Hibernate5的运行环境1. 下载相应的jar包等 * http://sourceforge.net/projects/hibernate/files/hibernate-orm/5.0.7.Final/hibernate-release-5.0.7.Final.zip/download 2. 解压后对目录结构有一定的了解 2.第二步：创建表结构**1. 建表语句如下 Create database hibernate_day01; Use hibernate_day01; CREATE TABLE `cst_customer` ( `cust_id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT &apos;客户编号(主键)&apos;, `cust_name` varchar(32) NOT NULL COMMENT &apos;客户名称(公司名称)&apos;, `cust_user_id` bigint(32) DEFAULT NULL COMMENT &apos;负责人id&apos;, `cust_create_id` bigint(32) DEFAULT NULL COMMENT &apos;创建人id&apos;, `cust_source` varchar(32) DEFAULT NULL COMMENT &apos;客户信息来源&apos;, `cust_industry` varchar(32) DEFAULT NULL COMMENT &apos;客户所属行业&apos;, `cust_level` varchar(32) DEFAULT NULL COMMENT &apos;客户级别&apos;, `cust_linkman` varchar(64) DEFAULT NULL COMMENT &apos;联系人&apos;, `cust_phone` varchar(64) DEFAULT NULL COMMENT &apos;固定电话&apos;, `cust_mobile` varchar(16) DEFAULT NULL COMMENT &apos;移动电话&apos;, PRIMARY KEY (`cust_id`) ) ENGINE=InnoDB AUTO_INCREMENT=94 DEFAULT CHARSET=utf8; 3.第三步：搭建Hibernate的开发环境1. 创建WEB工程，引入Hibernate开发所需要的jar包 * MySQL的驱动jar包 * Hibernate开发需要的jar包（资料/hibernate-release-5.0.7.Final/lib/required/所有jar包） * 日志jar包（资料/jar包/log4j/所有jar包） 4.第四步：编写JavaBean实体类1. Customer类的代码如下： public class Customer { private Long cust_id; private String cust_name; private Long cust_user_id; private Long cust_create_id; private String cust_source; private String cust_industry; private String cust_level; private String cust_linkman; private String cust_phone; private String cust_mobile; // 省略get和set方法 } 5.第五步：创建类与表结构的映射1. 在JavaBean所在的包下创建映射的配置文件 * 默认的命名规则为：实体类名.hbm.xml * 在xml配置文件中引入约束（引入的是hibernate3.0的dtd约束，不要引入4的约束） &lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt; 2. 如果不能上网，编写配置文件是没有提示的，需要自己来配置 * 先复制http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd --&gt; window --&gt; preferences --&gt; 搜索xml --&gt; 选择xml catalog --&gt; 点击add --&gt; 现在URI --&gt; 粘贴复制的地址 --&gt; 选择location，选择本地的DTD的路径 3. 编写映射的配置文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt; &lt;hibernate-mapping&gt; &lt;class name=&quot;com.itheima.domain.Customer&quot; table=&quot;cst_customer&quot;&gt; &lt;id name=&quot;cust_id&quot; column=&quot;cust_id&quot;&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;property name=&quot;cust_name&quot; column=&quot;cust_name&quot;/&gt; &lt;property name=&quot;cust_user_id&quot; column=&quot;cust_user_id&quot;/&gt; &lt;property name=&quot;cust_create_id&quot; column=&quot;cust_create_id&quot;/&gt; &lt;property name=&quot;cust_source&quot; column=&quot;cust_source&quot;/&gt; &lt;property name=&quot;cust_industry&quot; column=&quot;cust_industry&quot;/&gt; &lt;property name=&quot;cust_level&quot; column=&quot;cust_level&quot;/&gt; &lt;property name=&quot;cust_linkman&quot; column=&quot;cust_linkman&quot;/&gt; &lt;property name=&quot;cust_phone&quot; column=&quot;cust_phone&quot;/&gt; &lt;property name=&quot;cust_mobile&quot; column=&quot;cust_mobile&quot;/&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; 6.第六步：编写Hibernate核心的配置文件1. 在src目录下，创建名称为hibernate.cfg.xml的配置文件 2. 在XML中引入DTD约束 &lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt; 3. 打开：资料/hibernate-release-5.0.7.Final/project/etc/hibernate.properties，可以查看具体的配置信息 * 必须配置的4大参数 #hibernate.connection.driver_class com.mysql.jdbc.Driver #hibernate.connection.url jdbc:mysql:///test #hibernate.connection.username gavin #hibernate.connection.password * 数据库的方言（必须配置的） #hibernate.dialect org.hibernate.dialect.MySQLDialect * 可选的配置 #hibernate.show_sql true #hibernate.format_sql true #hibernate.hbm2ddl.auto update * 引入映射配置文件（一定要注意，要引入映射文件，框架需要加载映射文件） * &lt;mapping resource=&quot;com/itheima/domain/Customer.hbm.xml&quot;/&gt; 4. 具体的配置如下 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt; &lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;hibernate.connection.url&quot;&gt;jdbc:mysql:///hibernate_day01&lt;/property&gt; &lt;property name=&quot;hibernate.connection.username&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;hibernate.connection.password&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;mapping resource=&quot;com/itheima/domain/Customer.hbm.xml&quot;/&gt; &lt;/session-factory&gt; &lt;/hibernate-configuration&gt; 7.第七步：编写Hibernate入门代码1. 具体的代码如下 /** * 测试保存客户 */ @Test public void testSave(){ // 先加载配置文件 Configuration config = new Configuration(); // 默认加载src目录下的配置文件 config.configure(); // 创建SessionFactory对象 SessionFactory factory = config.buildSessionFactory(); // 创建session对象 Session session = factory.openSession(); // 开启事务 Transaction tr = session.beginTransaction(); // 编写保存代码 Customer c = new Customer(); // c.setCust_id(cust_id); 已经自动递增 c.setCust_name(&quot;测试名称&quot;); c.setCust_mobile(&quot;110&quot;); // 保存客户 session.save(c); // 提交事务 tr.commit(); // 释放资源 session.close(); factory.close(); } 五.Hibernate具体配置文件(初阶段)1.ibernate配置文件之映射配置文件1. 映射文件，即Stu.hbm.xml的配置文件 * &lt;class&gt;标签 -- 用来将类与数据库表建立映射关系 * name -- 类的全路径 * table -- 表名.(类名与表名一致,那么table属性也可以省略) * catalog -- 数据库的名称，基本上都会省略不写 * &lt;id&gt;标签 -- 用来将类中的属性与表中的主键建立映射，id标签就是用来配置主键的。 * name -- 类中属性名 * column -- 表中的字段名.(如果类中的属性名与表中的字段名一致,那么column可以省略.) * length -- 字段的程度，如果数据库已经创建好了，那么length可以不写。如果没有创建好，生成表结构时，length最好指定。 * &lt;property&gt; -- 用来将类中的普通属性与表中的字段建立映射. * name -- 类中属性名 * column -- 表中的字段名.(如果类中的属性名与表中的字段名一致,那么column可以省略.) * length -- 数据长度 * type -- 数据类型（一般都不需要编写，如果写需要按着规则来编写） * Hibernate的数据类型 type=&quot;string&quot; * Java的数据类型 type=&quot;java.lang.String&quot; * 数据库字段的数据类型 &lt;column name=&quot;name&quot; sql-type=&quot;varchar&quot;/&gt; 2.Hibernate配置文件之核心配置文件1. 核心配置文件的两种方式 * 第一种方式是属性文件的形式，即properties的配置文件 * hibernate.properties * hibernate.connection.driver_class=com.mysql.jdbc.Driver * 缺点 * 不能加载映射的配置文件，需要手动编写代码去加载 * 第二种方式是XML文件的形式，开发基本都会选择这种方式 * hibernate.cfg.xml * &lt;property name=&quot;hibernate.connection.driver_class&quot; &gt;com.mysql.jdbc.Driver&lt;/property&gt; * 优点 * 格式比较清晰 * 编写有提示 * 可以在该配置文件中加载映射的配置文件（最主要的） 2. 关于hibernate.cfg.xml的配置文件方式 * 必须有的配置 * 数据库连接信息: hibernate.connection.driver_class -- 连接数据库驱动程序 hibernate.connection.url -- 连接数据库URL hibernate.connection.username -- 数据库用户名 hibernate.connection.password -- 数据库密码 * 方言: hibernate.dialect -- 操作数据库方言 * 可选的配置 * hibernate.show_sql -- 显示SQL * hibernate.format_sql -- 格式化SQL * hibernate.hbm2ddl.auto -- 通过映射转成DDL语句 * create -- 每次都会创建一个新的表.---测试的时候 * create-drop -- 每次都会创建一个新的表,当执行结束之后,将创建的这个表删除.---测试的时候 * update -- 如果有表,使用原来的表.没有表,创建一个新的表.同时更新表结构. * validate -- 如果有表,使用原来的表.同时校验映射文件与表中字段是否一致如果不一致就会报错. * 加载映射 * 如果XML方式：&lt;mapping resource=&quot;cn/itcast/hibernate/domain/User.hbm.xml&quot; /&gt; 六.技术分析之Hibernate常用的接口和类1.Configuration类和作用1. Configuration类 * Configuration对象用于配置并且启动Hibernate。 * Hibernate应用通过该对象来获得对象-关系映射文件中的元数据，以及动态配置Hibernate的属性，然后创建SessionFactory对象。 * 简单一句话：加载Hibernate的配置文件，可以获取SessionFactory对象。 2. Configuration类的其他应用（了解） * 加载配置文件的种类，Hibernate支持xml和properties类型的配置文件，在开发中基本都使用XML配置文件的方式。 * 如果采用的是properties的配置文件，那么通过Configuration configuration = new Configuration();就可以假装配置文件 * 但是需要自己手动加载映射文件 * 例如：config.addResource(&quot;cn/itcast/domain/Student.hbm.xml&quot;); * 如果采用的XML的配置文件，通过Configuration configuration = new Configuration().configure();加载配置文件 2.SessionFactory(重要)1. 是工厂类，是生成Session对象的工厂类 2. SessionFactory类的特点 * 由Configuration通过加载配置文件创建该对象。 * SessionFactory对象中保存了当前的数据库配置信息和所有映射关系以及预定义的SQL语句。同时，SessionFactory还负责维护Hibernate的二级缓存。 * 预定义SQL语句 * 使用Configuration类创建了SessionFactory对象是，已经在SessionFacotry对象中缓存了一些SQL语句 * 常见的SQL语句是增删改查（通过主键来查询） * 这样做的目的是效率更高 * 一个SessionFactory实例对应一个数据库，应用从该对象中获得Session实例。 * SessionFactory是线程安全的，意味着它的一个实例可以被应用的多个线程共享。 * SessionFactory是重量级的，意味着不能随意创建或销毁它的实例。如果只访问一个数据库，只需要创建一个SessionFactory实例，且在应用初始化的时候完成。 * SessionFactory需要一个较大的缓存，用来存放预定义的SQL语句及实体的映射信息。另外可以配置一个缓存插件，这个插件被称之为Hibernate的二级缓存，被多线程所共享 3. 总结 * 一般应用使用一个SessionFactory,最好是应用启动时就完成初始化。 3.编写HibernateUtil的工具类1. 具体代码如下 public class HibernateUtil { private static final Configuration cfg; private static final SessionFactory factory; static{ // 给常量赋值 // 加载配置文件 cfg = new Configuration().configure(); // 生成factory对象 factory = cfg.buildSessionFactory(); } // 获取Session对象 public static Session openSession(){ return factory.openSession(); } } 4.Session接口1. 概述 * Session是在Hibernate中使用最频繁的接口。也被称之为持久化管理器。它提供了和持久化有关的操作，比如添加、修改、删除、加载和查询实体对象 * Session 是应用程序与数据库之间交互操作的一个单线程对象，是 Hibernate 运作的中心 * Session是线程不安全的 * 所有持久化对象必须在 session 的管理下才可以进行持久化操作 * Session 对象有一个一级缓存，显式执行 flush 之前，所有的持久化操作的数据都缓存在 session 对象处 * 持久化类与 Session 关联起来后就具有了持久化的能力 2. 特点 * 不是线程安全的。应避免多个线程使用同一个Session实例 * Session是轻量级的，它的创建和销毁不会消耗太多的资源。应为每次客户请求分配独立的Session实例 * Session有一个缓存，被称之为Hibernate的一级缓存。每个Session实例都有自己的缓存 3. 常用的方法 * save(obj) * delete(obj) * get(Class,id) * update(obj) * saveOrUpdate(obj) -- 保存或者修改（如果没有数据，保存数据。如果有，修改数据） * createQuery() -- HQL语句的查询的方式 5.Transaction接口1. Transaction是事务的接口 2. 常用的方法 * commit() -- 提交事务 * rollback() -- 回滚事务 3. 特点 * Hibernate框架默认情况下事务不自动提交.需要手动提交事务 * 如果没有开启事务，那么每个Session的操作，都相当于一个独立的事务 七.本阶段总结回忆：快速入门hibernate1. 下载Hibernate框架的开发包 2. 编写数据库和表结构 3. 创建WEB的项目，导入了开发的jar包 * MySQL驱动包、Hibernate开发的必须要有的jar包、日志的jar包 4. 编写JavaBean，以后不使用基本数据类型，使用包装类 5. 编写映射的配置文件（核心），先导入开发的约束，里面正常配置标签 6. 编写hibernate的核心的配置文件，里面的内容是固定的 7. 编写代码，使用的类和方法]]></content>
      <categories>
        <category>hibernate</category>
      </categories>
      <tags>
        <tag>hibernate</tag>
        <tag>hibernate入门篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle索引]]></title>
    <url>%2F2018%2F12%2F16%2Foracle-index%2F</url>
    <content type="text"><![CDATA[一.说明1）索引是数据库对象之一，用于加快数据的检索，类似于书籍的索引。在数据库中索引可以减少数据库程序查询结果时需要读取的数据量，类似于在书籍中我们利用索引可以不用翻阅整本书即可找到想要的信息。2）索引是建立在表上的可选对象；索引的关键在于通过一组排序后的索引键来取代默认的全表扫描检索方式，从而提高检索效率3）索引在逻辑上和物理上都与相关的表和数据无关，当创建或者删除一个索引时，不会影响基本的表；4）索引一旦建立，在表上进行DML操作时（例如在执行插入、修改或者删除相关操作时），oracle会自动管理索引，索引删除，不会对表产生影响5）索引对用户是透明的，无论表上是否有索引，sql语句的用法不变6）oracle创建主键时会自动在该列上创建索引二.索引原理1. 若没有索引，搜索某个记录时（例如查找name=’wish’）需要搜索所有的记录，因为不能保证只有一个wish，必须全部搜索一遍2. 若在name上建立索引，oracle会对全表进行一次搜索，将每条记录的name值哪找升序排列，然后构建索引条目（name和rowid），存储到索引段中，查询name为wish时即可直接查找对应地方3.创建了索引并不一定就会使用，oracle自动统计表的信息后，决定是否使用索引，表中数据很少时使用全表扫描速度已经很快，没有必要使用索引三.索引使用（创建、修改、删除、查看）1.创建索引语法CREATE [UNIQUE] | [BITMAP] INDEX index_name –unique表示唯一索引 ON table_name([column1 [ASC|DESC],column2 –bitmap，创建位图索引 [ASC|DESC],…] | [express]) [TABLESPACE tablespace_name] [PCTFREE n1] –指定索引在数据块中空闲空间 [STORAGE (INITIAL n2)] [NOLOGGING] –表示创建和重建索引时允许对表做DML操作，默认情况下不应该使用 [NOLINE] [NOSORT]; –表示创建索引时不进行排序，默认不适用，如果数据已经是按照该索引顺序排列的可以使用 2.修改索引1）重命名索引alter index index_sno rename to bitmap_index; 2) 合并索引（表使用一段时间后在索引中会产生碎片，此时索引效率会降低，可以选择重建索引或者合并索引,合并索引方式更好些，无需额外存储空间，代价较低）alter index index_sno coalesce; 3)重建索引方式一：删除原来的索引，重新建立索引 方式二： alter index index_sno rebuild; 3.删除索引drop index index_sno; 4.查看索引复制代码复制代码 select index_name,index-type, tablespace_name, uniqueness from all_indexes where table_name =’tablename’; – eg:create index index_sno on student(‘name’);select * from all_indexes where table_name=’student’; 四.索引分类1. B树索引（默认索引，保存讲过排序过的索引列和对应的rowid值）1）说明： 1.oracle中最常用的索引；B树索引就是一颗二叉树；叶子节点（双向链表）包含索引列和指向表中每个匹配行的ROWID值 2.所有叶子节点具有相同的深度，因而不管查询条件怎样，查询速度基本相同 3.能够适应精确查询、模糊查询和比较查询 2）分类： UNIQUE,NON-UNIQUE(默认),REVERSE KEY（数据列中的数据是反向存储的） 3）创建例子craete index index_sno on student(‘sno’); 4）适合使用场景： 列基数（列不重复值的个数）大时适合使用B数索引 2. 位图索引1）说明： 创建位图索引时，oracle会扫描整张表，并为索引列的每个取值建立一个位图（位图中，对表中每一行 使用一位（bit，0或者1）来标识该行是否包含该位图的索引列的取值，如果为1，表示对应的rowid所在的记录包含该位图索引列值），最后通过位图索 引中的映射函数完成位到行的ROWID的转换 2)创建例子create bitmap index index_sno on student(sno); 3) 适合场景：对于基数小的列适合简历位图索引（例如性别等） 3.单列索引和复合索引（基于多个列创建）注意： 即如果索引建立在多个列上，只有它的第一个列被where子句引用时，优化器才会使用该索引，即至少要包含组合索引的第一列 4. 函数索引1)说明： 1. 当经常要访问一些函数或者表达式时，可以将其存储在索引中，这样下次访问时，该值已经计算出来了，可以加快查询速度 2. 函数索引既可以使用B数索引，也可以使用位图索引；当函数结果不确定时采用B树索引，结果是固定的某几个值时使用位图索引 3. 函数索引中可以水泥用len、trim、substr、upper（每行返回独立结果），不能使用如sum、max、min、avg等 2）例子：create index fbi on student (upper(name)); select * from student where upper(name) =’WISH’; 五.索引建立原则总结1. 如果有两个或者以上的索引，其中有一个唯一性索引，而其他是非唯一，这种情况下oracle将使用唯一性索引而完全忽略非唯一性索引2. 至少要包含组合索引的第一列（即如果索引建立在多个列上，只有它的第一个列被where子句引用时，优化器才会使用该索引）3. 小表不要简历索引4. 对于基数大的列适合建立B树索引，对于基数小的列适合简历位图索引5. 列中有很多空值，但经常查询该列上非空记录时应该建立索引6. 经常进行连接查询的列应该创建索引7. 使用create index时要将最常查询的列放在最前面8. LONG（可变长字符串数据，最长2G）和LONG RAW（可变长二进制数据，最长2G）列不能创建索引9.限制表中索引的数量（创建索引耗费时间，并且随数据量的增大而增大；索引会占用物理空间；当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度）六.注意事项1. 通配符在搜索词首出现时，oracle不能使用索引，eg：复制代码复制代码 –我们在name上创建索引； create index index_name on student(‘name’); –下面的方式oracle不适用name索引 select * from student where name like ‘%wish%’; –如果通配符出现在字符串的其他位置时，优化器能够利用索引；如下： select * from student where name like ‘wish%’; 复制代码复制代码 2. 不要在索引列上使用not，可以采用其他方式代替如下：（oracle碰到not会停止使用索引，而采用全表扫描）复制代码复制代码 select * from student where not (score=100); select * from student where score &lt;&gt; 100; –替换为 select * from student where score&gt;100 or score &lt;100 复制代码复制代码 3. 索引上使用空值比较将停止使用索引， eg：select * from student where score is not null;]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
        <tag>oracle索引</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle 数据库 实例 用户 表空间 之间的关系（转）]]></title>
    <url>%2F2018%2F12%2F13%2Foracle-framework%2F</url>
    <content type="text"><![CDATA[数据库：Oracle数据库是数据的物理存储。这就包括（数据文件ORA或者DBF、控制文件、联机日志、参数文件）。其实Oracle数据库的概念和其它数据库不一样，这里的数据库是一个操作系统只有一个库。可以看作是Oracle就只有一个大数据库。 实例：一个Oracle实例（Oracle Instance）有一系列的后台进程（Backguound Processes)和内存结构（Memory Structures)组成。一个数据库可以有n个实例。 用户：用户是在实例下建立的。不同实例可以建相同名字的用户。 表空间：表空间是一个用来管理数据存储逻辑概念，表空间只是和数据文件（ORA或者DBF文件）发生关系，数据文件是物理的，一个表空间可以包含多个数据文件，而一个数据文件只能隶属一个表空间。 数据文件（dbf、ora）： 数据文件是数据库的物理存储单位。数据库的数据是存储在表空间中的，真 正是在某一个或者多个数据文件中。而一个表空间可以由一个或多个数据文件组成，一个数据文件只能属于一个表空间。一旦数据文件被加入到某个表空间后，就不能删除这个文件，如果要删除某个数据文件，只能删除其所属于的表空间才行。 注：表的数据，是有用户放入某一个表空间的，而这个表空间会随机把这些表数据放到一个或者多个数据文件中。由于oracle的数据库不是普通的概念，oracle是有用户和表空间对数据进行管理和存放的。但是表不是有表空间去查询的，而是由用户去查的。因为不同用户可以在同一个表空间建立同一个名字的表！这里区分就是用户了！ 关系示意图： 理解1：Oracle数据库可以创建多个实例，每个实例可以创建多个表空间，每个表空间下可以创建多个用户（同时用户也属于表空间对应的实例）和数据库文件，用户可以创建多个表（每个表随机存储在一个或多个数据库文件中），如下图：理解2：理解1MS有误。实例下有和，授权访问，是管理的，经授权在中创建，随机存储到不同的中。如下图所示：操作1：安装Oracle后会有默认的实例，即ORCL。一般不创建多个实例，在默认实例下创建表空间和用户等。 1，运行CMD进入DOS界面，首先输入：sqlplus，回车；再输入：sys/sys as sysdba，回车，即进入“SQL〉”操作状态。 2，输入：CREATE TABLESPACE 表空间名称 LOGGING DATAFILE ‘c:\表空间数据文件.ora’ SIZE 500M autoextend on next 200m maxsize 2048m;，表空间创建完成。 3，输入：CREATE USER 用户名称 PROFILE default IDENTIFIED BY 用户密码 DEFAULT TABLESPACE 授权访问的表空间名称 TEMPORARY TABLESPACE temp ACCOUNT UNLOCK;，用户创建完成，并授权用户访问某表空间。 具体操作如下图所示： 操作2： 创建表和插入数据，并查询浏览插入的数据。 1，创建表，输入： create table 表名( 字段名称1 字段类型, 字段名称2 字段类型, 字段名称3 字段类型 );，回车。 2，插入数据，输入：insert into 表名(字段1,字段2,字段3) VALUES (值1,值2,值3);，回车。 3，查询数据，输入：select * from 表名;，回车。 具体操作如下图所示： 基本操作流程1.创建数据表空间 create tablespace CICI logging datafile ‘D:\oraclexe\app\oracle\oradata\CICI\CICI.DBF’ size 32m autoextend on next 32m maxsize 2048m extent management local; 2.创建用户并指定表空间 CREATE USER cici IDENTIFIED BY cici PROFILE DEFAULT DEFAULT TABLESPACE CICI ACCOUNT UNLOCK; – 为用户赋予权限 GRANT connect, resource TO cici; grant create session to cici; 3.登录用户 sql&gt;conn 请输入用户名 cici 请输入密码 XXXXXX 4.建立表 create table aa(name varchar2(100),age number(4)); insert into aa values(‘wo’,29); 5.查询表 select * from cici.A;]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
        <tag>oracle结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle函数]]></title>
    <url>%2F2018%2F12%2F13%2Foracle-function%2F</url>
    <content type="text"><![CDATA[函数的分类: 单行函数分为五种类型：字符函数、数值函数、日期函数、转换函数、通用函数 单行函数:大小写控制函数select lower(‘Hello World’) 转小写, upper(‘Hello World’) 转大写 from dual;–initcap: 首字母大写select initcap(‘hello world’) 首字符大写 from dual; 字符控制函数concat: 字符连接函数, 等同于 ||select concat(‘Hello’,’ World’) from dual; substr:求母串中的某个子串select substr(‘Hello World’,3) from dual;select substr(‘Hello World’,3,4) from dual; length和lengthb: 字符数和字节数select length(‘China’) 字符数, lengthb(‘China’) 字节数 from dual; instr:在母串中，查找子串的位置select instr(‘Hello World’,’ll’) from dual; lpad,rpad: 左右填充,将abcd用*填充到10位select lpad(‘abcd’,10,’‘) 左填充, rpad(‘abcd’,10,’‘) 右填充 from dual; trim: 去掉字符串前后指定的字符select trim(‘H’ from ‘Hello WorldH’) from dual; replace:字符串替换函数select replace(‘Hello Wordl’,’l’,’*’) from dual; 数字函数select round(45.926,2) 四舍五入, trunc(45.926,2) 截断 ,mod(1600,300) 求于 from dual; ROUND函数select round(45.923,0) 整数位, round(45.923,-1) 十位,round(45.923,-2) 百位 from dual; 日期函数显示当前日期select sysdate from dual; 显示时间部分select to_char(sysdate,’yyyy-mm-dd hh24:mi:ss’) from dual; 显示昨天，今天和明天，加减数字仍未日期select sysdate-1 昨天, sysdate 今天, sysdate+1 明天 from dual; 两个日期相减，结果为相差的天数，查询员工信息，显示员工工龄。两个日期不能相加select empno,ename, sysdate-hiredate 天 from emp; 查询员工信息，显示员工工龄,分别按照天，星期，月显示select empno,ename,sysdate-hiredate 天,(sysdate-hiredate)/7 星期, (sysdate-hiredate)/30 月 from emp; months_between:两个日期相差的月数select (sysdate-hiredate)/30 方式一, months_between(sysdate,hiredate) 方式二 from emp; add_months:在指定日期上加上若干个月select add_months(sysdate,1) 下个月, add_months(sysdate,123) “123个月后” from dual last_day: 某个日期当月的最后一天select last_day(sysdate) from dual; next_day:下周六select next_day(sysdate,’星期五’) from dual; 对日期进行四舍五入select round(sysdate,’MONTH’) 月,round(sysdate,’YEAR’) from dual; 对日期进行截断select trunc(sysdate,’MONTH’) 月,trunc(sysdate,’YEAR’) from dual; 日期格式select * from emp where hiredate=to_date(‘1982-01-23’,’yyyy-mm-dd’); 查询当前日期：显示: 2011-09-17 15:12:15今天是星期六select to_char(sysdate,’yyyy-mm-dd hh24:mi:ss”今天是”day’) from dual; 查询员工信息，显示员工的编号，姓名，月薪,要求有货币代码(L)，千位符(,)，小数点(.),select empno,ename,to_char(sal,’L9,999.99’) from emp; 大小写控制函数select lower(‘Hello World’) 转小写, upper(‘Hello World’) 转大写 from dual; initcap: 首字母大写select initcap(‘hello world’) 首字符大写 from dual; 通用函数nvl(exp1,exp2):当exp1为空时，返回exp2nvl2(exp1,exp2,exp3):当exp1为空时，返回exp3；否则返回exp2select ename,sal*12+nvl2(comm,comm,0) 年收入 from emp; NULLIF (expr1, expr2),如果expr1=expr2,返回null;否则,返回expr1select nullif(‘abc’,’abc’) from dual;select nullif(‘abc’,’abcaa’) from dual; COALESCE :找到参数列表中，第一个不为空的值select ename,comm,sal,COALESCE(comm,sal) from emp; 例子:给员工涨工资,根据职位涨，总裁涨1000，经理涨600 其他人员涨400select ename,job,sal 涨前工资,case job when ‘PRESIDENT’ then sal+1000 when ‘MANAGER’ then sal+600 else sal+400 end 涨后工资from emp; select ename,job,sal 涨前工资, decode(job,’PRESIDENT’,sal+1000,’MANAGER’,sal+600,sal+400) 涨后工资 转换函数(Conversion Functions)转换函数将指定字符从一种类型转换为另一种，通常这类函数遵循如下惯例：函数名称后面跟着待转换类型以及输出类型。 TO_CHAR() 本函数又可以分三小类，分别是转换字符-&gt;字符TO_CHAR(c)：将nchar,nvarchar2,clob,nclob类型转换为char类型；例如：SELECT TO_CHAR(‘AABBCC’) FROM DUAL; 转换时间-&gt;字符TO_CHAR(d[,fmt])：将指定的时间(data,timestamp,timestamp with time zone)按照指定格式转换为varchar2类型；例如：SELECT TO_CHAR(sysdate,’yyyy-mm-dd hh24:mi:ss’) FROM DUAL; 转换数值-&gt;字符TO_CHAR(n[,fmt])：将指定数值n按照指定格式fmt转换为varchar2类型并返回；例如：SELECT TO_CHAR(-100, ‘L99G999D99MI’) FROM DUAL; TO_DATE(c[,fmt[,nls]]) 将char,nchar,varchar2,nvarchar2转换为日期类型，如果fmt参数不为空，则按照fmt中指定格式进行转换。注意这里的fmt参数。如果ftm为’J’则表示按照公元制(Julian day)转换，c则必须为大于0并小于5373484的正整数。例如：SELECT TO_DATE(2454336, ‘J’) FROM DUAL;SELECT TO_DATE(‘2007-8-23 23:25:00’, ‘yyyy-mm-dd hh24:mi:ss’) FROM DUAL; 为什么公元制的话，c的值必须不大于5373484呢？因为Oracle的DATE类型的取值范围是公元前4712年1月1日至公元9999年12月31日。看看下面这个语句：SELECT TO_CHAR(TO_DATE(‘9999-12-31’,’yyyy-mm-dd’),’j’) FROM DUAL; TO_NUMBER(c[,fmt[,nls]]) 将char,nchar,varchar2,nvarchar2型字串按照fmt中指定格式转换为数值类型并返回。例如：SELECT TO_NUMBER(‘-100.00’, ‘9G999D99’) FROM DUAL; 其它辅助函数(Miscellaneous Single-Row Functions)DECODE(exp,s1,r1,s2,r2..s,r[,def]) 可以把它理解成一个增强型的if else，只不过它并不通过多行语句，而是在一个函数内实现if else的功能。exp做为初始参数。s做为对比值，相同则返回r，如果s有多个，则持续遍历所有s，直到某个条件为真为止，否则返回默认值def(如果指定了的话)，如果没有默认值，并且前面的对比也都没有为真，则返回空。毫无疑问，decode是个非常重要的函数，在实现行转列等功能时都会用到，需要牢记和熟练使用。 例如：select decode(‘a2’,’a1’,’true1’,’a2’,’true2’,’default’) from dual; GREATEST(n1,n2,…n) 返回序列中的最大值例如：SELECT GREATEST(15,5,75,8) “Greatest” FROM DUAL; LEAST(n1,n2….n) 返回序列中的最小值例如：SELECT LEAST(15,5,75,8) LEAST FROM DUAL; NULLIF(c1,c2)Nullif也是个很有意思的函数。逻辑等价于：CASE WHEN c1 = c2 THEN NULL ELSE c1 END例如：SELECT NULLIF(‘a’,’b’),NULLIF(‘a’,’a’) FROM DUAL; NVL(c1,c2) 逻辑等价于IF c1 is null THEN c2 ELSE c1 END。c1,c2可以是任何类型。如果两者类型不同，则oracle会自动将c2转换为c1的类型。例如：SELECT NVL(null, ‘12’) FROM DUAL; NVL2(c1,c2,c3) 大家可能都用到nvl，但你用过nvl2吗？如果c1非空则返回c2,如果c1为空则返回c3例如：select nvl2(‘a’, ‘b’, ‘c’) isNull,nvl2(null, ‘b’, ‘c’) isNotNull from dual; SYS_CONNECT_BY_PATH(col,c) 该函数只能应用于树状查询。返回通过c1连接的从根到节点的路径。该函数必须与connect by 子句共同使用。多行函数和单行函数相比，oracle提供了丰富的基于组的，多行的函数。这些函数能在select或select的having子句中使用，当用于select子串时常常都和GROUP BY一起使用。多行函数分为接收多个输入，返回一个输出 求员工的工资总和select sum(sal) from emp; 求个数select count(*) from emp; 求平均工资select sum(sal)/count(*) 方式一, avg(sal) 方式二 from emp; 关于空值：组函数会自动滤空select count(*), count(comm) from emp; max和min：求最高工资和最低工资select max(sal) 最高工资,min(sal) 最低工资 from emp; 分组数据：求各个部门的平均工资select deptno,avg(sal) from emp group by deptno; group by作用于多列： 按部门，不同的工种，统计平均工资group by作用于多列：先按照第一列分组；如果相同，再按照第二列分组select deptno,job,avg(sal) from emp group by deptno,job; ：求部门的平均工资大于2000的部门select deptno,avg(sal) from emp group by deptno having avg(sal)&gt;2000; group by的增强select deptno,job,sum(sal) from emp group by rollup(deptno,job); 不同的deptno空两行/取消设置break on deptno skip 2/break on null 转载：https://blog.csdn.net/lailai186/article/]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
        <tag>oracle 函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle基本命令]]></title>
    <url>%2F2018%2F12%2F13%2Foracle-sql%2F</url>
    <content type="text"><![CDATA[一.ORACLE支持五种类型的完整性约束1.NOT NULL (非空)防止NULL值进入指定的列,在单列基础上定义,默认情况下,ORACLE允许在任何列中有NULL值. 2.CHECK (检查)检查在约束中指定的条件是否得到了满足. 3.UNIQUE (唯一)保证在指定的列中没有重复值.在该表中每一个值或者每一组值都将是唯一的. 4.PRIMARY KEY (主键)用来唯一的标识出表的每一行,并且防止出现NULL值,一个表只能有一个主键约束. 5.POREIGN KEY (外部键)通过使用公共列在表之间建立一种父子(parent-child)关系,在表上定义的外部键可以指向主键或者其他表的唯一键.ORACLE支持五种类型的完整性约束 二.基本命令创建表空间create tablespace schooltbs datafile ‘D:\oracle\datasource\schooltbs.dbf’ size 10M autoextend on; 删除表空间drop tablespace schooltbs[including contents and datafiles]; 查询表空间基本信息select *||tablespace_name from DBA_TABLESPACES; 创建用户create user lihua identified by lihua default tablespace schooltbs temporary tablespace temp; 更改用户alter user lihua identified by 123 default tablespace users; 锁定用户alter user lihua account lock|unlock; 删除用户drop user lihua cascade;–删除用户模式 oracle数据库中的角色connect,dba,select_catalog_role,delete_catalog_role,execute_catalog_role,exp_full_database,imp_full_database,resource 授予连接服务器的角色grant connect to lihua; 授予使用表空间的角色 grant resource to lihua with grant option;–该用户也有授权的权限 授予操作表的权限grant select,insert on user_tbl to scott;–当前用户 grant delete,update on lihua.user_tbl to scott;–系统管理员 修改表的结构(alter)Alter table 表名 add(列的名称,列的类型); 三.基本查询设置每行显示多少字符set linesize 300; 设置每页显示多少条记录set pagesize 30; 用户名的切换conn system/tiger Conn sys/change_on_install as sysdba(注意超级用户 在后面加as sysdba)在超级用户下查找普通用户的表是查不到的必须这样查找 如 select * from scott.emp(普通用户下的emp表) 查看当前是那个用户身份登录:show user; 查看有多少张表:select * from tab;(注意不同用户下的表是不同的) 查看表的结构:desc emp(emp为表名) 取出重复的列(DISTINCT):如 SELECT DISTINCT JOB EMP(去掉job的重复的值) 字符串的链接操作用:|| 查询有奖金的员工:select* from emp where comm is not null; 查询没有奖金的员工信息:select * from emp where comm is null; 两个条件以上就得用and 如查询工资大雨1500和有奖金的员 select * from emp where sal&gt;1500 and comm is not null; 表示两个条件有一个满足就可就用:or 如查询工资大于1500或者没有奖金的员工信息Select * from emp where sal&gt;1500 or comm is not null; 取反可以用not 如 查询员工工资不大于1500和有奖金的员工信息 如: Select * from emp where not (sal&gt;1500 or comm is not null); 在什么什么之间用between—-and—-如查询工资在1500和3000之间的员工信息:Select * from emp where sal between 1500 and 3000; 查询员工编号是2323, 4555, 2222的员工具体信息: 如Select * from emp where empno in(2323,4555,2222); 模糊查询 like 一般结合”%”和”“使用其中%:表示可以匹配任意长度的内容,”“表示匹配一个长度放入内容 如: 查询员工姓名中第二哥字母是M的员工信息:Select from emp where ename LIKE ‘_M%’;又如姓名中包含M的员工 Select from emp where ename LIKE ‘%M%’; oracle中不等于有两种表示方式 “&lt;&gt;”和”!=”排序用order by {asc desc}其中asc 是升序排列 如果不写就默认按升序排列desc是按降序排列 排序语句放在sal语句的最后如: 按员工工资进行排序Select from emp order by sal asc(升序)Selecct from emp order by sal desc(降序)Select * from emp where deptno=’10’ order by sal desc,hiredate asc;(查询部门10的员工工资的升序排列如果工资相等就按员工的入职时间排序) group by 用于对查询的结果进行分组统计: 显示每个部门的平均工资和最高工资 如:Select avg(sal),max(sal) from emp group by deptno; Having 子句用于限制分组显示结果: 显示平均工资大于2000的的部门号和他的平均工资?如:select avg(sal), deptno from emp group by deptno having avg(sal)&gt;2000; 四.锁和数据库对象1.锁数据库用来控制共享资源并发访问的机制。 锁的类型：行级锁，表级锁 行级锁：对正在被修改的行进行锁定。行级锁也被称之为排他锁。 在使用下列语句时，Oracle会自动应用行级锁： insert,update,delete,select…… for update select……for update允许用户一次锁定多条记录进行更新。 使用commit or rollback释放锁。 表级锁： lock table user_tbl in mode mode; 表级锁类型： 行共享 row share 行排他 row exclusive 共享 share 共享行排他 share row exclusive 排他 exclusive 死锁：两个或两个以上的事务相互等待对方释放资源，从而形成死锁 2.数据库对象 oracle数据库对象又称模式对象 数据库对象是逻辑结构的集合，最基本的数据库对象是表 数据库对象：表，序列，视图，索引 2.序列序列用于生成唯一，连续序号的对象。 创建语法： create sequence user_id_seq start with 1000 increment by 1 maxvalue 2000 minvalue 1000 nocycle cache 1000;–指定内存中预先分配的序号 访问序列： select user_id_seq.currval from dual; select user_id-seq.nextval from dual;更改删除序列： alter sequence user_id_seq maxvalue 10000;–不能修改其start with 值 drop sequence user_id_seq; 在Hibernate中访问序列： user_id_seq 3.视图视图以经过定制的方式显示来自一个或多个表的数据 创建视图： create or replace view user_tbl_view (vid,vname,vage) as select id,user_name,age from user_tbl [with check option]|[with read only]; 创建带有错误的视图： create force view user_tbl_force_view as select * from user_table;–此时user_table可以不存在 创建外联接视图： create view user_stu_view as select u.id,u.user_name,u.password,s.ddress from user_tbl u,stu_tbl s where u.s_id(+)=s.id;–哪一方带有(+)，哪一方就是次要的 删除视图： drop user_stu_view; 4.索引索引用于提高SQL语句执行的性能 索引类型： 唯一索引，位图索引，组合索引，基于函数的索引，反向键索引创建标准索引： create index user_id_index on user_tbl(id) tablespace schooltbs; 重建索引： alter index user_id_index rebuild; 删除索引： drop index user_id_index;创建唯一索引： create unique index user_id_index on user_tbl(id); 创建组合索引： create index name_pass_index on user_tbl(user_name,password); 创建反向键索引： create index user_id_index on user_tbl(id) reverse; 五.使用PL/SQL可用于创建存储过程，触发器，程序包，给SQL语句的执行添加程序逻辑。 支持SQL，在PL/SQL中可以使用：数据操纵命令 事务控制命令 游标控制 SQL函数和SQL运算符支持面向对象编程(OOP)可移植性更佳的性能，PL/SQL经过编译执行 分为三个部分：声明部分，可执行部分和异常处理部分 [declare declarations] begin executable statements [exception handlers] end;打开输出 set serverout on; 1.根据输入编号获取某学员的成绩–ifdeclarescore user_tbl.score%type;beginselect score into score from user_tbl where id=’&amp;id’;if score&gt;90 thendbms_output.put_line(‘优秀’);elsif score&gt;80 thendbms_output.put_line(‘良好’);elsif score&gt;60 thendbms_output.put_line(‘及格’);elsedbms_output.put_line(‘差’);end if;end; 2.根据学员姓名获取某学员的成绩–ifdeclarescore user_tbl.score%type;beginselect score into score from user_tbl where user_name=’&amp;name’;if score&gt;90 thendbms_output.put_line(‘优秀’);elsif score&gt;80 thendbms_output.put_line(‘良好’);elsif score&gt;60 thendbms_output.put_line(‘及格’);elsedbms_output.put_line(‘差’);end if;end; 3.case的使用declaregrade user_tbl.grade%type;beginselect grade into grade from user_tbl where id=’&amp;id’;case gradewhen ‘A’ then dbms_output.put_line(‘优异’);when ‘B’ then dbms_output.put_line(‘优秀’);when ‘C’ then dbms_output.put_line(‘良好’);else dbms_output.put_line(‘一般’);end case;end; 4.基本循环declarei number(4):=1;beginloopdbms_output.put_line(‘loop size:’||i);i:=i+1;exit when i&gt;10;end loop;end; 5.while循环declarei number(4):=1;beginwhile i&lt;=10 loopdbms_output.put_line(‘while loop size=’||i);i:=i+1;end loop;end; 6.for循环declarei number(4):=1;beginfor i in 1..10 loopdbms_output.put_line(‘for loop Size:’||i);end loop;end; declarei number(2):=1;j number(2):=1;beginfor i in reverse 1..9 loopfor j in 1..i loopdbms_output.put(j||’x’||i||’=’||j*i||’ ‘);end loop;dbms_output.put_line(‘’);end loop;end; 7.动态SQLdeclareuserId number(2);sql_str varchar2(100);userName user_tbl.user_name%type;beginexecute immediate ‘create table testExe(id number,test_name varchar2(20))’;userId:=’&amp;userId’;sql_str:=’select user_name from user_tbl where id=:id’;execute immediate sql_str into userName using userId;dbms_output.put_line(userName);end;(ordeclare id_param number:=’&amp;id_param’; sql_str varchar2(100); name_param stu_tbl.stu_name%type; begin sql_str:=’select stu_name from stu_tbl where id=:p’; execute immediate sql_str into name_param using id_param; dbms_output.put_line(name_param); end; /) 8.异常处理declaregrade number(4);begingrade:=’&amp;grade’;case gradewhen 1 then dbms_output.put_line(‘好的’);–else dbms_output.put_line(‘不好’);end case;exceptionwhen case_not_found thendbms_output.put_line(‘输入类型不匹配！’);end; 9.系统异常declarerowD user_tbl%rowtype;beginselect into rowD from user_tbl;dbms_output.put_line(rowD.id||’’||rowD.user_name||’ ‘||rowD.password);exceptionwhen too_many_rows thendbms_output.put_line(‘不能将多行赋予一个属性！’);end;ordeclarerowD user_tbl%rowtype;beginselect into rowD from user_tbl where id=5;dbms_output.put_line(rowD.id||’ ‘||rowD.user_name||’ ‘||rowD.password);exceptionwhen too_many_rows thendbms_output.put_line(‘不能将多行赋予一个属性！’);when no_data_found thendbms_output.put_line(‘没有您要查找的数据！’);end; 10.自定义错误declareinvalidError exception;category varchar2(20);begincategory:=’&amp;category’;if category not in(‘附件’,’顶盘’,’备件’) thenraise invalidError;elsedbms_output.put_line(‘您输入的类别是：’||category);end if;exceptionwhen invalidError thendbms_output.put_line(‘无法识别的类别！’);end; 11.引发应用程序异常declareapp_exception exception;grade user_tbl.grade%type;beginselect grade into grade from user_tbl where id=&id;if grade=’A’ thenraise app_exception;elsedbms_output.put_line(‘查询的等级为：’||grade);end if;exceptionwhen app_exception thenraise_application_error(-20001,’未知的等级！’);end;]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
        <tag>oracle sql</tag>
        <tag>oracle 命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis完善(spring整合)篇]]></title>
    <url>%2F2018%2F12%2F12%2Fredis4%2F</url>
    <content type="text"><![CDATA[jedisjedis介绍Redis不仅是使用命令来操作，现在基本上主流的语言都有客户端支持，比如java、C、C#、C++、php、Node.js、Go等。在官方网站里列一些Java的客户端，有Jedis、Redisson、Jredis、JDBC-Redis、等其中官方推荐使用Jedis和Redisson。 在企业中用的最多的就是Jedis，下面我们就重点学习下Jedis。Jedis同样也是托管在github上，地址：https://github.com/xetorthio/jedis 通过jedis连接redis单机jar包pom坐标： &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; 单实例连接通过创建单实例jedis对象连接redis服务，如下代码： // 单实例连接redis @Test public void testJedisSingle() { Jedis jedis = new Jedis(&quot;192.168.101.3&quot;, 6379); jedis.set(&quot;name&quot;, &quot;bar&quot;); String name = jedis.get(&quot;name&quot;); System.out.println(name); jedis.close(); } 连接超时解决由于linux防火墙默认开启，redis的服务端口6379并不在开放规则之内，所有需要将此端口开放访问或者关闭防火墙。 关闭防火墙命令： sevice iptables stop 如果是修改防火墙规则，可以修改： /etc/sysconfig/iptables文件 使用连接池连接通过单实例连接redis不能对redis连接进行共享，可以使用连接池对redis连接进行共享，提高资源利用率，使用jedisPool连接redis服务，如下代码： @Test public void pool() { JedisPoolConfig config = new JedisPoolConfig(); //最大连接数 config.setMaxTotal(30); //最大连接空闲数 config.setMaxIdle(2); JedisPool pool = new JedisPool(config, &quot;192.168.101.3&quot;, 6379); Jedis jedis = null; try { jedis = pool.getResource(); jedis.set(&quot;name&quot;, &quot;lisi&quot;); String name = jedis.get(&quot;name&quot;); System.out.println(name); }catch(Exception ex){ ex.printStackTrace(); }finally{ if(jedis != null){ //关闭连接 jedis.close(); } } } jedis与spring整合配置spring配置文件applicationContext.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd &quot;&gt; 连接池配置 &lt;bean id=&quot;jedisPoolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt; &lt;!-- 最大连接数 --&gt; &lt;property name=&quot;maxTotal&quot; value=&quot;30&quot; /&gt; &lt;!-- 最大空闲连接数 --&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;10&quot; /&gt; &lt;!-- 每次释放连接的最大数目 --&gt; &lt;property name=&quot;numTestsPerEvictionRun&quot; value=&quot;1024&quot; /&gt; &lt;!-- 释放连接的扫描间隔（毫秒） --&gt; &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;30000&quot; /&gt; &lt;!-- 连接最小空闲时间 --&gt; &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;1800000&quot; /&gt; &lt;!-- 连接空闲多久后释放, 当空闲时间&gt;该值 且 空闲连接&gt;最大空闲连接数 时直接释放 --&gt; &lt;property name=&quot;softMinEvictableIdleTimeMillis&quot; value=&quot;10000&quot; /&gt; &lt;!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 --&gt; &lt;property name=&quot;maxWaitMillis&quot; value=&quot;1500&quot; /&gt; &lt;!-- 在获取连接的时候检查有效性, 默认false --&gt; &lt;property name=&quot;testOnBorrow&quot; value=&quot;true&quot; /&gt; &lt;!-- 在空闲时检查有效性, 默认false --&gt; &lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot; /&gt; &lt;!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true --&gt; &lt;property name=&quot;blockWhenExhausted&quot; value=&quot;false&quot; /&gt; &lt;/bean&gt; &lt;!-- redis单机 通过连接池 --&gt; &lt;bean id=&quot;jedisPool&quot; class=&quot;redis.clients.jedis.JedisPool&quot; destroy-method=&quot;close&quot;&gt; &lt;constructor-arg name=&quot;poolConfig&quot; ref=&quot;jedisPoolConfig&quot;/&gt; &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.145&quot;/&gt; &lt;constructor-arg name=&quot;port&quot; value=&quot;6379&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; 测试代码： private ApplicationContext applicationContext; @Before public void init() { applicationContext = new ClassPathXmlApplicationContext( &quot;classpath:applicationContext.xml&quot;); } @Test public void testJedisPool() { JedisPool pool = (JedisPool) applicationContext.getBean(&quot;jedisPool&quot;); try { Jedis jedis = pool.getResource(); jedis.set(&quot;name&quot;, &quot;lisi&quot;); String name = jedis.get(&quot;name&quot;); System.out.println(name); }catch(Exception ex){ ex.printStackTrace(); }finally{ if(jedis != null){ //关闭连接 jedis.close(); } } }]]></content>
      <categories>
        <category>spring-redis</category>
      </categories>
      <tags>
        <tag>非关系型数据库</tag>
        <tag>redis</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis高级篇]]></title>
    <url>%2F2018%2F12%2F12%2Fredis3%2F</url>
    <content type="text"><![CDATA[持久化Redis的高性能是由于其将所有数据都存储在了内存中为了使Redis在重启之后仍能保证数据不丢失，需要将数据从内存中同步到硬盘中，这一过程就是持久化。Redis支持两种方式的持久化，一种是RDB方式，一种是AOF方式。可以单独使用其中一种或将二者结合使用。 RDB持久化RDB方式的持久化是通过快照（snapshotting）完成的，当符合一定条件时Redis会自动将内存中的数据进行快照并持久化到硬盘。RDB是Redis默认采用的持久化方式，在redis.conf配置文件中默认有此下配置： save 900 1save 300 10save 60 10000 save 开头的一行就是持久化配置，可以配置多个条件（每行配置一个条件），每个条件之间是“或”的关系，“save 900 1”表示15分钟（900秒钟）内至少1个键被更改则进行快照，“save 300 10”表示5分钟（300秒）内至少10个键被更改则进行快照。 在redis.conf中：配置dir指定rdb快照文件的位置配置dbfilenam指定rdb快照文件的名称 Redis启动后会读取RDB快照文件，将数据从硬盘载入到内存。根据数据量大小与结构和服务器性能不同，这个时间也不同。通常将记录一千万个字符串类型键、大小为1GB的快照文件载入到内存中需要花费20～30秒钟。 问题总结：通过RDB方式实现持久化，一旦Redis异常退出，就会丢失最后一次快照以后更改的所有数据。这就需要开发者根据具体的应用场合，通过组合设置自动快照条件的方式来将可能发生的数据损失控制在能够接受的范围。如果数据很重要以至于无法承受任何损失，则可以考虑使用AOF方式进行持久化。 AOF持久化默认情况下Redis没有开启AOF（append only file）方式的持久化，可以通过appendonly参数开启：appendonly yes开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof，可以通过appendfilename参数修改：appendfilename appendonly.aof 主从复制（了解）什么是主从复制持久化保证了即使redis服务重启也会丢失数据，因为redis服务重启后会将硬盘上持久化的数据恢复到内存中，但是当redis服务器的硬盘损坏了可能会导致数据丢失，如果通过redis的主从复制机制就可以避免这种单点故障，如下图： 说明：主redis中的数据有两个副本（replication）即从redis1和从redis2，即使一台redis服务器宕机其它两台redis服务也可以继续提供服务。主redis中的数据和从redis上的数据保持实时同步，当主redis写入数据时通过主从复制机制会复制到两个从redis服务上。只有一个主redis，可以有多个从redis。主从复制不会阻塞master，在同步数据时，master 可以继续处理client 请求一个redis可以即是主又是从，如下图： 主从配置主redis配置无需特殊配置。 从redis配置修改从redis服务器上的redis.conf文件，添加slaveof 主redisip 主redis端口 上边的配置说明当前该从redis服务器所对应的主redis是192.168.101.3，端口是6379 主从复制过程完整复制在redis2.8版本之前主从复制过程如下图： 复制过程说明： 1、slave 服务启动，slave 会建立和master 的连接，发送sync 命令。2、master启动一个后台进程将数据库快照保存到RDB文件中注意：此时如果生成RDB文件过程中存在写数据操作会导致RDB文件和当前主redis数据不一致，所以此时master 主进程会开始收集写命令并缓存起来。3、master 就发送RDB文件给slave4、slave 将文件保存到磁盘上，然后加载到内存恢复5、master把缓存的命令转发给slave注意：后续master 收到的写命令都会通过开始建立的连接发送给slave。当master 和slave 的连接断开时slave 可以自动重新建立连接。如果master 同时收到多个slave 发来的同步连接命令，只会启动一个进程来写数据库镜像，然后发送给所有slave。 完整复制的问题： 在redis2.8之前从redis每次同步都会从主redis中复制全部的数据，如果从redis是新创建的从主redis中复制全部的数据这是没有问题的，但是，如果当从redis停止运行，再启动时可能只有少部分数据和主redis不同步，此时启动redis仍然会从主redis复制全部数据，这样的性能肯定没有只复制那一小部分不同步的数据高。 部分复制部分复制说明：从机连接主机后，会主动发起 PSYNC 命令，从机会提供 master的runid(机器标识，随机生成的一个串) 和 offset（数据偏移量，如果offset主从不一致则说明数据不同步），主机验证 runid 和 offset 是否有效， runid 相当于主机身份验证码，用来验证从机上一次连接的主机，如果runid验证未通过则，则进行全同步，如果验证通过则说明曾经同步过，根据offset同步部分数据。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>非关系型数据库</tag>
        <tag>缓存数据库</tag>
        <tag>redis</tag>
        <tag>持久化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis基础篇]]></title>
    <url>%2F2018%2F12%2F12%2Fredis1%2F</url>
    <content type="text"><![CDATA[redis介绍1.什么是NoSQL?NoSQL，泛指非关系型的数据库，NoSQL即Not-Only SQL，它可以作为关系型数据库的良好补充。随着互联网web2.0网站的兴起，非关系型的数据库现在成了一个极其热门的新领域，非关系数据库产品的发展非常迅速。而传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，例如： 1、High performance - 对数据库高并发读写的需求web2.0网站要根据用户个性化信息来实时生成动态页面和提供动态信息，所以基本上无法使用动态页面静态化技术，因此数据库并发负载非常高，往往要达到每秒上万次读写请求。关系数据库应付上万次SQL查询还勉强顶得住，但是应付上万次SQL写数据请求，硬盘IO就已经无法承受了。其实对于普通的BBS网站，往往也存在对高并发写请求的需求，例如网站的实时统计在线用户状态，记录热门帖子的点击次数，投票计数等，因此这是一个相当普遍的需求。 2、Huge Storage - 对海量数据的高效率存储和访问的需求类似Facebook，twitter，Friendfeed这样的SNS网站，每天用户产生海量的用户动态，以Friendfeed为例，一个月就达到了2.5亿条用户动态，对于关系数据库来说，在一张2.5亿条记录的表里面进行SQL查询，效率是极其低下乃至不可忍受的。再例如大型web网站的用户登录系统，例如腾讯，盛大，动辄数以亿计的帐号，关系数据库也很难应付。 3、High Scalability &amp;&amp; High Availability- 对数据库的高可扩展性和高可用性的需求在基于web的架构当中，数据库是最难进行横向扩展的，当一个应用系统的用户量和访问量与日俱增的时候，你的数据库却没有办法像web server和app server那样简单的通过添加更多的硬件和服务节点来扩展性能和负载能力。对于很多需要提供24小时不间断服务的网站来说，对数据库系统进行升级和扩展是非常痛苦的事情，往往需要停机维护和数据迁移，为什么数据库不能通过不断的添加服务器节点来实现扩展呢？ NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。 一些主流的NOSQL产品： NoSQL数据库的四大分类如下： 键值(Key-Value)存储数据库:相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB典型应用： 内容缓存，主要用于处理大量数据的高访问负载。数据模型： 一系列键值对优势： 快速查询劣势： 存储的数据缺少结构化 列存储数据库：相关产品：Cassandra, HBase, Riak典型应用：分布式的文件系统数据模型：以列簇式存储，将同一列数据存在一起优势：查找速度快，可扩展性强，更容易进行分布式扩展劣势：功能相对局限 文档型数据库：相关产品：CouchDB、MongoDB典型应用：Web应用（与Key-Value类似，Value是结构化的）数据模型： 一系列键值对 优势：数据结构要求不严格 劣势： 查询性能不高，而且缺乏统一的查询语法 图形(Graph)数据库：相关数据库：Neo4J、InfoGrid、Infinite Graph典型应用：社交网络数据模型：图结构优势：利用图结构相关算法。劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。 2.redis历史发展2008年，意大利的一家创业公司Merzia推出了一款基于MySQL的网站实时统计系统LLOOGG，然而没过多久该公司的创始人 Salvatore Sanfilippo便 对MySQL的性能感到失望，于是他决定亲自为LLOOGG量身定做一个数据库，并于2009年开发完成，这个数据库就是Redis。 不过Salvatore Sanfilippo并不满足只将Redis用于LLOOGG这一款产品，而是希望更多的人使用它，于是在同一年Salvatore Sanfilippo将Redis开源发布，并开始和Redis的另一名主要的代码贡献者Pieter Noordhuis一起继续着Redis的开发，直到今天。Salvatore Sanfilippo自己也没有想到，短短的几年时间，Redis就拥有了庞大的用户群体。Hacker News在2012年发布了一份数据库的使用情况调查，结果显示有近12%的公司在使用Redis。国内如新浪微博、街旁网、知乎网，国外如GitHub、Stack Overflow、Flickr等都是Redis的用户。 VMware公司从2010年开始赞助Redis的开发， Salvatore Sanfilippo和Pieter Noordhuis也分别在3月和5月加入VMware，全职开发Redis。 3.什么是redisRedis是用C语言开发的一个开源的高性能键值对（key-value）数据库。 它通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下： 字符串类型散列类型列表类型集合类型有序集合类型。3.4redis的应用场景缓存（数据查询、短连接、新闻内容、商品内容等等）。（最多使用）分布式集群架构中的session分离。聊天室的在线好友列表。任务队列。（秒杀、抢购、12306等等）应用排行榜。网站访问统计。数据过期处理（可以精确到毫秒） 4.测试环境redis需要安装在linux服务器上运行测试，本教程使用 linux虚拟机及ssh客户端进行功能测试。 4.1 虚拟机创建Centos6.4虚拟机作为linux服务器。 虚拟机ip：192.168.93.88 4.2 ssh客户端在开发环境(windows)安装ssh客户端，本教程使用SecureCRT作为ssh客户端连接虚拟机。 5.安装运行redis5.1redis安装环境redis是C语言开发，建议在linux上运行，本教程使用Centos6.4作为安装环境。 安装redis需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境， 需要安装gcc：yum install gcc-c++ 5.2redis安装版本说明 本教程使用redis3.0版本。3.0版本主要增加了redis集群功能。 源码下载 从官网下载 http://download.redis.io/releases/redis-3.0.0.tar.gz 将redis-3.0.0.tar.gz拷贝到/usr/local下 解压源码 tar -zxvf redis-3.0.0.tar.gz 进入解压后的目录进行编译 cd /usr/local/redis-3.0.0 make 安装到指定目录,如 /usr/local/redis cd /usr/local/redis-3.0.0 make PREFIX=/usr/local/redis install redis.conf redis.conf是redis的配置文件，redis.conf在redis源码目录。 注意修改port作为redis进程的端口,port默认6379。 拷贝配置文件到安装目录下 进入源码目录，里面有一份配置文件 redis.conf，然后将其拷贝到安装路径下 cd /usr/local/redis mkdir conf cp /usr/local/redis-3.0.0/redis.conf /usr/local/redis/bin 安装目录bin下的文件列表 redis3.0新增的redis-sentinel是redis集群管理工具可实现高可用。 5.3 redis启动5.3.1前端模式启动 直接运行bin/redis-server将以前端模式启动， 前端模式启动的缺点是ssh命令窗口关闭则redis-server程序结束， 不推荐使用此方法。 5.3.2后端模式启动 修改redis.conf配置文件， daemonize yes 以后端模式启动。 执行如下命令启动redis： cd /usr/local/redis ./bin/redis-server ./redis.conf redis默认使用6379端口。 也可更改redis.conf文件，修改端口号： 5.3.3启动多个redis进程 方法1： 启动时指定端口可在一台服务器启动多个redis进程。 cd /usr/local/redis/bin ./redis-server ./redis.conf --port 6380 方法2(推荐此方法)： 创建多个redis目录，以端口号命名，比如：创建6379、6380两个目录， redis的安装文件bin和conf拷贝至这两个目录。 修改6379目录下的redis.conf设置端口号为6379 修改6380目录下的redis.conf设置端口号为6380 启动6379和6380目录下的redis-server程序： cd 6379 ./redis-server . /redis.conf cd 6380 ./redis-server . /redis.conf 查询当前redis的进程： ps aux | grep redis 5.4redis停止强行终止Redis进程可能会导致redis持久化数据丢失。 正确停止Redis的方式应该是向Redis发送SHUTDOWN命令， 方法为： cd /usr/local/redis ./bin/redis-cli shutdown 5.5redis客户端在redis的安装目录中有redis的客户端，即redis-cli（Redis Command Line Interface）， 它是Redis自带的基于命令行的Redis客户端。 5.5.1连接redis服务端 执行bin/redis-cli连接redis服务端： 从上图得知redis-cli默认连接本机的redis，本机的redis没有启动则报上图中的错误。 指定连接redis服务的ip和端口： 5.5.2向redis服务端发送命令 redis-cli连上redis服务后，可以在命令行发送命令。 ping Redis提供了PING命令来测试客户端与Redis的连接是否正常，如果连接正常会收到回复PONG set/get 使用set和get可以向redis设置数据、获取数据。 del 删除指定key的内容。 例如：del name Keys * 查看当前库中所有的key值 5.6redis多数据库5.6.1redis实例 一个redis进程就是一个redis实例，一台服务器可以同时有多个redis实例， 不同的redis实例提供不同的服务端口对外提供服务，每个redis实例之间互相影响。 每个redis实例都包括自己的数据库，数据库中可以存储自己的数据。 5.6.2多数据库测试 一个Redis实例可以包括多个数据库，客户端可以指定连接某个redis实例的哪个数据库， 就好比一个mysql中创建多个数据库，客户端连接时指定连接哪个数据库。 一个redis实例最多可提供16个数据库，下标从0到15，客户端默认连接第0号数据库， 也可以通过select选择连接哪个数据库，如下连接1号库： 在1号库中查询上节设置的数据，结果查询不到： 重新选择第0号数据库，查询数据： 如果选择一个不存在数据库则会报错： 注意：redis不支持修改数据库的名称，只能通过select 0、select 1...选择数据库。 5.6.3注意问题 在0号数据库存储数据，在1号数据库执行清空数据命令却把0号数据库的数据给清空了： 建议：不同的应用系统要使用不同的redis实例而不是使用同一个redis实例下的不同数据库。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>非关系型数据库</tag>
        <tag>缓存数据库</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis进阶篇]]></title>
    <url>%2F2018%2F12%2F12%2Fredis2%2F</url>
    <content type="text"><![CDATA[数据类型–stringredis string介绍redis中没有使用C语言的字符串表示，而是自定义一个数据结构叫SDS（simple dynamic string）即简单动态字符串。打开下载的redis源码包，找到src下的sds.h文件查看sds源码： struct sdshdr { //字符串长度 unsigned int len; //buf数组中未使用的字节数量 unsigned int free; //用于保存字符串 char buf[]; }; c语言对字符串的存储是使用字符数组，遇到’\0’字符则认为字符串结束，redis的字符串可以存储任何类型的数据，因为任何类型数据都可以表示成二进制，sds结构中的char buf[]就是存储了二进制数据。redis的字符串是二进制安全的，什么是二进制安全？简单理解就是存入什么数据取出的还是什么数据。redis中的sds不像c语言处理字符串那样遇到’\0’字符则认证字符串结束，它不会对存储进去的二进制数据进行处理，存入什么数据取出还是什么数据。 命令赋值SET key value: 127.0.0.1:6379&gt; set test 123 OK 取值：GET key: 127.0.0.1:6379&gt; get test &quot;123“ 当键不存在时返回空结果。 删除Del key: 127.0.0.1:6379&gt; del test (integer) 1 数值增减递增数字 INCR key: 当存储的字符串是整数时，Redis提供了一个实用的命令INCR，其作用是让当前键值递增，并返回递增后的值。 127.0.0.1:6379&gt; incr num (integer) 1 127.0.0.1:6379&gt; incr num (integer) 2 127.0.0.1:6379&gt; incr num (integer) 3 增加指定的整数 INCRBY key increment: 127.0.0.1:6379&gt; incrby num 2 (integer) 5 127.0.0.1:6379&gt; incrby num 2 (integer) 7 127.0.0.1:6379&gt; incrby num 2 (integer) 9 递减数值: DECR key 其它命令减少指定的整数 :DECRBY key decrement 127.0.0.1:6379&gt; decr num (integer) 6 127.0.0.1:6379&gt; decr num (integer) 5 127.0.0.1:6379&gt; decrby num 3 (integer) 2 127.0.0.1:6379&gt; decrby num 3 (integer) -1 向尾部追加值 :APPEND key valueAPPEND的作用是向键值的末尾追加value。如果键不存在则将该键的值设置为value，即相当于 SET key value。返回值是追加后字符串的总长度。 127.0.0.1:6379&gt; set str hello OK 127.0.0.1:6379&gt; append str &quot; world!&quot; (integer) 12 127.0.0.1:6379&gt; get str &quot;hello world!&quot; 获取字符串长度 :STRLEN keySTRLEN命令返回键值的长度，如果键不存在则返回0。 127.0.0.1:6379&gt; strlen str (integer) 0 127.0.0.1:6379&gt; set str hello OK 127.0.0.1:6379&gt; strlen str (integer) 5 同时设置/获取多个键值 :MSET key value [key value …]MGET key [key …] 127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3 OK 127.0.0.1:6379&gt; get k1 &quot;v1&quot; 127.0.0.1:6379&gt; mget k1 k3 1) &quot;v1&quot; 2) &quot;v3&quot; 应用自增主键商品编号、订单号采用string的递增数字特性生成。 定义商品编号key：items:id 192.168.101.3:7003&gt; INCR items:id (integer) 2 192.168.101.3:7003&gt; INCR items:id (integer) 3 数据类型–hash使用string的问题假设有User对象以JSON序列化的形式存储到Redis中，User对象有id，username、password、age、name等属性，存储的过程如下： 保存、更新： User对象 json(string) redis 如果在业务上只是更新age属性，其他的属性并不做更新我应该怎么做呢？ 如果仍然采用上边的方法在传输、处理时会造成资源浪费，下边讲的hash可以很好的解决这个问题。 redis hash介绍hash叫散列类型，它提供了字段和字段值的映射。字段值只能是字符串类型，不支持散列类型、集合类型等其它类型。如下： 命令赋值HSET key field value 一次只能设置一个字段值 127.0.0.1:6379&gt; hset user username zhangsan (integer) 1 HMSET key field value [field value …] 一次可以设置多个字段值 127.0.0.1:6379&gt; hmset user age 20 username lisi OK 取值HGET key field 一次只能获取一个字段值 127.0.0.1:6379&gt; hget user username &quot;zhangsan“ HMGET key field [field …] 一次可以获取多个字段值 127.0.0.1:6379&gt; hmget user age username 1) &quot;20&quot; 2) &quot;lisi&quot; HGETALL key 127.0.0.1:6379&gt; hgetall user 1) &quot;age&quot; 2) &quot;20&quot; 3) &quot;username&quot; 4) &quot;lisi&quot; HSET命令不区分插入和更新操作，当执行插入操作时HSET命令返回1，当执行更新操作时返回0. 删除字段可以删除一个或多个字段，返回值是被删除的字段个数HDEL key field [field …] 127.0.0.1:6379&gt; hdel user age (integer) 1 127.0.0.1:6379&gt; hdel user age name (integer) 0 127.0.0.1:6379&gt; hdel user age username (integer) 1 增加数字HINCRBY key field increment 127.0.0.1:6379&gt; hincrby user age 2 将用户的年龄加2 (integer) 22 127.0.0.1:6379&gt; hget user age 获取用户的年龄 &quot;22“ 其它命令判断字段是否存在HEXISTS key field 127.0.0.1:6379&gt; hexists user age 查看user中是否有age字段 (integer) 1 127.0.0.1:6379&gt; hexists user name 查看user中是否有name字段 (integer) 0 HSETNX key field value 当字段不存在时赋值，类似HSET，区别在于如果字段已经存在，该命令不执行任何操作。 127.0.0.1:6379&gt; hsetnx user age 30 如果user中没有age字段则设置age值为30，否则不做任何操作 (integer) 0 只获取字段名或字段值 HKEYS key HVALS key 127.0.0.1:6379&gt; hmset user age 20 name lisi OK 127.0.0.1:6379&gt; hkeys user 1) &quot;age&quot; 2) &quot;name&quot; 127.0.0.1:6379&gt; hvals user 1) &quot;20&quot; 2) &quot;lisi&quot; 获取字段数量HLEN key 127.0.0.1:6379&gt; hlen user (integer) 2 应用商品信息商品id、商品名称、商品描述、商品库存、商品好评 定义商品信息的key：商品1001的信息在 redis中的key为：items:1001 存储商品信息: 192.168.101.3:7003&gt; HMSET items:1001 id 3 name apple price 999.9 OK 获取商品信息: 192.168.101.3:7003&gt; HGET items:1001 id &quot;3&quot; .168.101.3:7003&gt; HGETALL items:1001 1) &quot;id&quot; 2) &quot;3&quot; 3) &quot;name&quot; 4) &quot;apple&quot; 5) &quot;price&quot; 6) &quot;999.9&quot; 数据类型–listArrayList与LinkedList的区别ArrayList使用数组方式存储数据，所以根据索引查询数据速度快，而新增或者删除元素时需要设计到位移操作，所以比较慢。LinkedList使用双向链接方式存储数据，每个元素都记录前后元素的指针，所以插入、删除数据时只是更改前后元素的指针指向即可，速度非常快，然后通过下标查询元素时需要从头开始索引，所以比较慢，但是如果查询前几个元素或后几个元素速度比较快。 redis list介绍列表类型（list）可以存储一个有序的字符串列表，常用的操作是向列表两端添加元素，或者获得列表的某一个片段。列表类型内部是使用双向链表（double linked list）实现的，所以向列表两端添加元素的时间复杂度为0(1)，获取越接近两端的元素速度就越快。这意味着即使是一个有几千万个元素的列表，获取头部或尾部的10条记录也是极快的。 命令向列表两端增加元素。LPUSH key value [value …] RPUSH key value [value …] 向列表左边增加元素 127.0.0.1:6379&gt; lpush list:1 1 2 3 (integer) 3 向列表右边增加元素 127.0.0.1:6379&gt; rpush list:1 4 5 6 (integer) 3 查看列表LRANGE key start stop LRANGE命令是列表类型最常用的命令之一，获取列表中的某一片段，将返回start、stop之间的所有元素（包含两端的元素），索引从0开始。索引可以是负数，如：“-1”代表最后边的一个元素。 127.0.0.1:6379&gt; lrange list:1 0 2 1) &quot;2&quot; 2) &quot;1&quot; 3) &quot;4&quot; 从列表两端弹出元素LPOP key RPOP key LPOP命令从列表左边弹出一个元素，会分两步完成，第一步是将列表左边的元素从列表中移除，第二步是返回被移除的元素值。 127.0.0.1:6379&gt; lpop list:1 &quot;3“ 127.0.0.1:6379&gt; rpop list:1 &quot;6“ 获取列表中元素的个数LLEN key 127.0.0.1:6379&gt; llen list:1 (integer) 2 ####其它命令删除列表中指定的值 : LREM key count value LREM命令会删除列表中前count个值为value的元素，返回实际删除的元素个数。根据count值的不同， 该命令的执行方式会有所不同： 当count&gt;0时， LREM会从列表左边开始删除。 当count&lt;0时， LREM会从列表后边开始删除。 当count=0时， LREM删除所有值为value的元素。 获得/设置指定索引的元素值 : LINDEX key index LSET key index value 127.0.0.1:6379&gt; lindex l:list 2 &quot;1&quot; 127.0.0.1:6379&gt; lset l:list 2 2 OK 127.0.0.1:6379&gt; lrange l:list 0 -1 1) &quot;6&quot; 2) &quot;5&quot; 3) &quot;2&quot; 4) &quot;2&quot; 只保留列表指定片段，指定范围和LRANGE一致 : LTRIM key start stop 127.0.0.1:6379&gt; lrange l:list 0 -1 1) &quot;6&quot; 2) &quot;5&quot; 3) &quot;0&quot; 4) &quot;2&quot; 127.0.0.1:6379&gt; ltrim l:list 0 2 OK 127.0.0.1:6379&gt; lrange l:list 0 -1 1) &quot;6&quot; 2) &quot;5&quot; 3) &quot;0&quot; 向列表中插入元素 : LINSERT key BEFORE|AFTER pivot value该命令首先会在列表中从左到右查找值为pivot的元素，然后根据第二个参数是BEFORE还是AFTER来决定将value插入到该元素的前面还是后面。 127.0.0.1:6379&gt; lrange list 0 -1 1) &quot;3&quot; 2) &quot;2&quot; 3) &quot;1&quot; 127.0.0.1:6379&gt; linsert list after 3 4 (integer) 4 127.0.0.1:6379&gt; lrange list 0 -1 1) &quot;3&quot; 2) &quot;4&quot; 3) &quot;2&quot; 4) &quot;1&quot; 将元素从一个列表转移到另一个列表中 : RPOPLPUSH source destination 127.0.0.1:6379&gt; rpoplpush list newlist &quot;1&quot; 127.0.0.1:6379&gt; lrange newlist 0 -1 1) &quot;1&quot; 127.0.0.1:6379&gt; lrange list 0 -1 1) &quot;3&quot; 2) &quot;4&quot; 3) &quot;2&quot; 应用商品评论列表思路： 在redis中创建商品评论列表 用户发布商品评论，将评论信息转成json存储到list中。 用户在页面查询评论列表，从redis中取出json数据展示到页面。 定义商品评论列表key： 商品编号为1001的商品评论key：items: comment:1001 192.168.101.3:7001&gt; LPUSH items:comment:1001 &apos;{&quot;id&quot;:1,&quot;name&quot;:&quot;商品不错，很好！！&quot;,&quot;date&quot;:1430295077289}&apos; 数据类型–setredis set介绍在集合中的每个元素都是不同的，且没有顺序。 集合类型和列表类型的对比： 集合类型的常用操作是向集合中加入或删除元素、判断某个元素是否存在等，由于集合类型的Redis内部是使用值为空的散列表实现，所有这些操作的时间复杂度都为0(1)。 Redis还提供了多个集合之间的交集、并集、差集的运算。 ###命令 增加/删除元素SADD key member [member …] SREM key member [member …] 127.0.0.1:6379&gt; sadd set a b c (integer) 3 127.0.0.1:6379&gt; sadd set a (integer) 0 127.0.0.1:6379&gt; srem set c d (integer) 1 获得集合中的所有元素SMEMBERS key 127.0.0.1:6379&gt; smembers set 1) &quot;b&quot; 2) &quot;a” 判断元素是否在集合中，无论集合中有多少元素都可以极速的返回结果。 SISMEMBER key member 127.0.0.1:6379&gt; sismember set a (integer) 1 127.0.0.1:6379&gt; sismember set h (integer) 0 其它命令集合的差集运算 A-B属于A并且不属于B的元素构成的集合。 SDIFF key [key …] 127.0.0.1:6379&gt; sadd setA 1 2 3 (integer) 3 127.0.0.1:6379&gt; sadd setB 2 3 4 (integer) 3 127.0.0.1:6379&gt; sdiff setA setB 1) &quot;1&quot; 127.0.0.1:6379&gt; sdiff setB setA 1) &quot;4&quot; 集合的交集运算 A ∩ B属于A且属于B的元素构成的集合。 SINTER key [key …] 127.0.0.1:6379&gt; sinter setA setB 1) &quot;2&quot; 2) &quot;3&quot; 集合的并集运算 A ∪ B属于A或者属于B的元素构成的集合 SUNION key [key …] 127.0.0.1:6379&gt; sunion setA setB 1) &quot;1&quot; 2) &quot;2&quot; 3) &quot;3&quot; 4) &quot;4&quot; 其它命令获得集合中元素的个数 SCARD key 127.0.0.1:6379&gt; smembers setA 1) &quot;1&quot; 2) &quot;2&quot; 3) &quot;3&quot; 127.0.0.1:6379&gt; scard setA (integer) 3 从集合中弹出一个元素 SPOP key 127.0.0.1:6379&gt; spop setA &quot;1“ 注意：由于集合是无序的，所有SPOP命令会从集合中随机选择一个元素弹出 数据类型–sorted setredis sorted set介绍在集合类型的基础上有序集合类型为集合中的每个元素都关联一个分数，这使得我们不仅可以完成插入、删除和判断元素是否存在在集合中，还能够获得分数最高或最低的前N个元素、获取指定分数范围内的元素等与分数有关的操作。 在某些方面有序集合和列表类型有些相似。 1、二者都是有序的。 2、二者都可以获得某一范围的元素。 但是，二者有着很大区别： 1、列表类型是通过链表实现的，获取靠近两端的数据速度极快，而当元素增多后，访问中间数据的速度会变慢。 2、有序集合类型使用散列表实现，所有即使读取位于中间部分的数据也很快。 3、列表中不能简单的调整某个元素的位置，但是有序集合可以（通过更改分数实现）4、有序集合要比列表类型更耗内存。 ###命令 ####增加元素向有序集合中加入一个元素和该元素的分数，如果该元素已经存在则会用新的分数替换原有的分数。返回值是新加入到集合中的元素个数，不包含之前已经存在的元素。 ZADD key score member [score member …] 127.0.0.1:6379&gt; zadd scoreboard 80 zhangsan 89 lisi 94 wangwu (integer) 3 127.0.0.1:6379&gt; zadd scoreboard 97 lisi (integer) 0 获取元素的分数 ZSCORE key member 127.0.0.1:6379&gt; zscore scoreboard lisi &quot;97&quot; 删除元素ZREM key member [member …] 移除有序集key中的一个或多个成员，不存在的成员将被忽略。 当key存在但不是有序集类型时，返回一个错误。 127.0.0.1:6379&gt; zrem scoreboard lisi (integer) 1 获得排名在某个范围的元素列表获得排名在某个范围的元素列表 ZRANGE key start stop [WITHSCORES]照元素分数从小到大的顺序返回索引从start到stop之间的所有元素（包含两端的元素） 127.0.0.1:6379&gt; zrange scoreboard 0 2 1) &quot;zhangsan&quot; 2) &quot;wangwu&quot; 3) &quot;lisi“ ZREVRANGE key start stop [WITHSCORES]照元素分数从大到小的顺序返回索引从start到stop之间的所有元素（包含两端的元素） 127.0.0.1:6379&gt; zrevrange scoreboard 0 2 1) &quot; lisi &quot; 2) &quot;wangwu&quot; 3) &quot; zhangsan “ 如果需要获得元素的分数的可以在命令尾部加上WITHSCORES参数 127.0.0.1:6379&gt; zrange scoreboard 0 1 WITHSCORES 1) &quot;zhangsan&quot; 2) &quot;80&quot; 3) &quot;wangwu&quot; 4) &quot;94&quot; 其它命令获得指定分数范围的元素 ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] 127.0.0.1:6379&gt; ZRANGEBYSCORE scoreboard 90 97 WITHSCORES 1) &quot;wangwu&quot; 2) &quot;94&quot; 3) &quot;lisi&quot; 4) &quot;97&quot; 127.0.0.1:6379&gt; ZRANGEBYSCORE scoreboard 70 100 limit 1 2 1) &quot;wangwu&quot; 2) &quot;lisi&quot; 增加某个元素的分数，返回值是更改后的分数 ZINCRBY key increment member 给lisi加4分 127.0.0.1:6379&gt; ZINCRBY scoreboard 4 lisi &quot;101“ 获得集合中元素的数量 ZCARD key 127.0.0.1:6379&gt; ZCARD scoreboard (integer) 3 获得指定分数范围内的元素个数 ZCOUNT key min max 127.0.0.1:6379&gt; ZCOUNT scoreboard 80 90 (integer) 1 按照排名范围删除元素 ZREMRANGEBYRANK key start stop 127.0.0.1:6379&gt; ZREMRANGEBYRANK scoreboard 0 1 (integer) 2 127.0.0.1:6379&gt; ZRANGE scoreboard 0 -1 1) &quot;lisi&quot; ZREMRANGEBYSCORE key min max 按照分数范围删除元素 127.0.0.1:6379&gt; zadd scoreboard 84 zhangsan (integer) 1 127.0.0.1:6379&gt; ZREMRANGEBYSCORE scoreboard 80 100 (integer) 1 获取元素的排名 ZRANK key member ZREVRANK key member 从小到大 127.0.0.1:6379&gt; ZRANK scoreboard lisi (integer) 0 从大到小 127.0.0.1:6379&gt; ZREVRANK scoreboard zhangsan (integer) 1 应用商品销售排行榜根据商品销售量对商品进行排行显示，定义sorted set集合，商品销售量为元素的分数。 定义商品销售排行榜key：items:sellsort 写入商品销售量： 商品编号1001的销量是9，商品编号1002的销量是10 192.168.101.3:7007&gt; ZADD items:sellsort 9 1001 10 1002 商品编号1001的销量加1 192.168.101.3:7001&gt; ZINCRBY items:sellsort 1 1001 商品销量前10名： 192.168.101.3:7001&gt; ZRANGE items:sellsort 0 9 withscores keys命令###设置key的生存时间Redis在实际使用过程中更多的用作缓存，然而缓存的数据一般都是需要设置生存时间的，即：到期后数据销毁。 EXPIRE key seconds 设置key的生存时间（单位：秒）key在多少秒后会自动删除 TTL key 查看key生于的生存时间 PERSIST key 清除生存时间 PEXPIRE key milliseconds 生存时间设置单位为：毫秒 例子： 192.168.101.3:7002&gt; set test 1 设置test的值为1 OK 192.168.101.3:7002&gt; get test 获取test的值 &quot;1&quot; 192.168.101.3:7002&gt; EXPIRE test 5 设置test的生存时间为5秒 (integer) 1 192.168.101.3:7002&gt; TTL test 查看test的生于生成时间还有1秒删除 (integer) 1 192.168.101.3:7002&gt; TTL test (integer) -2 192.168.101.3:7002&gt; get test 获取test的值，已经删除 (nil) 其它命令（自学）keys 返回满足给定pattern 的所有key redis 127.0.0.1:6379&gt; keys mylist* 1) &quot;mylist&quot; 2) &quot;mylist5&quot; 3) &quot;mylist6&quot; 4) &quot;mylist7&quot; 5) &quot;mylist8&quot; exists 确认一个key 是否存在 redis 127.0.0.1:6379&gt; exists HongWan (integer) 0 redis 127.0.0.1:6379&gt; exists age (integer) 1 redis 127.0.0.1:6379&gt; 从结果来数据库中不存在HongWan 这个key，但是age 这个key 是存在的 del删除一个key redis 127.0.0.1:6379&gt; del age (integer) 1 redis 127.0.0.1:6379&gt; exists age (integer) 0 redis 127.0.0.1:6379&gt; 从结果来数据库中不存在HongWan 这个key，但是age 这个key 是存在的 rename 重命名key redis 127.0.0.1:6379[1]&gt; keys * 1) &quot;age&quot; redis 127.0.0.1:6379[1]&gt; rename age age_new OK redis 127.0.0.1:6379[1]&gt; keys * 1) &quot;age_new&quot; redis 127.0.0.1:6379[1]&gt; age 成功的被我们改名为age_new 了 type返回值的类型 redis 127.0.0.1:6379&gt; type addr string redis 127.0.0.1:6379&gt; type myzset2 zset redis 127.0.0.1:6379&gt; type mylist list redis 127.0.0.1:6379&gt; ##服务器命令 ping测试连接是否存活 redis 127.0.0.1:6379&gt; ping PONG //执行下面命令之前，我们停止redis 服务器 redis 127.0.0.1:6379&gt; ping Could not connect to Redis at 127.0.0.1:6379: Connection refused //执行下面命令之前，我们启动redis 服务器 not connected&gt; ping PONG redis 127.0.0.1:6379&gt; 第一个ping 时，说明此连接正常 第二个ping 之前，我们将redis 服务器停止，那么ping 是失败的 第三个ping 之前，我们将redis 服务器启动，那么ping 是成功的 echo在命令行打印一些内容 redis 127.0.0.1:6379&gt; echo HongWan &quot;HongWan&quot; redis 127.0.0.1:6379&gt; select 选择数据库。Redis 数据库编号从0~15，我们可以选择任意一个数据库来进行数据的存取。 redis 127.0.0.1:6379&gt; select 1 OK redis 127.0.0.1:6379[1]&gt; select 16 (error) ERR invalid DB index redis 127.0.0.1:6379[16]&gt; 当选择16 时，报错，说明没有编号为16 的这个数据库 quit退出连接。 redis 127.0.0.1:6379&gt; quit dbsize返回当前数据库中key 的数目。 redis 127.0.0.1:6379&gt; dbsize (integer) 18 redis 127.0.0.1:6379&gt; 结果说明此库中有18 个key info获取服务器的信息和统计。 redis 127.0.0.1:6379&gt; info redis_version:2.2.12 redis_git_sha1:00000000 redis_git_dirty:0 arch_bits:32 multiplexing_api:epoll process_id:28480 uptime_in_seconds:2515 uptime_in_days:0 flushdb删除当前选择数据库中的所有key。 redis 127.0.0.1:6379&gt; dbsize (integer) 18 redis 127.0.0.1:6379&gt; flushdb OK redis 127.0.0.1:6379&gt; dbsize (integer) 0 redis 127.0.0.1:6379&gt; 在本例中我们将0 号数据库中的key 都清除了。 flushall删除所有数据库中的所有key。 redis 127.0.0.1:6379[1]&gt; dbsize (integer) 1 redis 127.0.0.1:6379[1]&gt; select 0 OK redis 127.0.0.1:6379&gt; flushall OK redis 127.0.0.1:6379&gt; select 1 OK redis 127.0.0.1:6379[1]&gt; dbsize (integer) 0 redis 127.0.0.1:6379[1]&gt; 在本例中我们先查看了一个1 号数据库中有一个key，然后我切换到0 号库执行flushall 命令，结果1 号库中的key 也被清除了，说是此命令工作正常。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>非关系型数据库</tag>
        <tag>缓存数据库</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot-redis.md]]></title>
    <url>%2F2018%2F12%2F12%2Fspringboot-redis%2F</url>
    <content type="text"><![CDATA[一. Springboot整合Redis(单机版 注解式开发)1.引入redis起步依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-redis&lt;/artifactId&gt; &lt;/dependency&gt; 2.在虚拟机中开启redis服务 启动server: ./redis-server redis.conf (启动客户端测试: ./redis-cli) 3.在applicaction.properties中配置redis 主机和端口号(这里为我的centos中的主机名以及redis端口号，可自行配置 spring.redis.host=192.168.66.66 spring.redis.port=6379 4.在启动类中加入注解@EnableCaching开启缓存 @EnableCaching @SpringBootApplication 5.在service实现类中利用@Cacheable设置缓存 /** * value : 缓存的名字 , * key ： 缓存map中的key * @param id * @return */ @Cacheable(value = { &quot;sampleCache&quot; },key=&quot;#id&quot;) public String getBook(int id) { System.out.println(&quot;Method executed..&quot;); if (id == 1) { return &quot;Book 1&quot;; } else { return &quot;Book 2&quot;; } } 二. Springboot整合Redis(集群版 注解式开发)1.在applicaction.properties中配置redis 集群 redis.cache.clusterNodes=192.168.66.66:7001,192.168.66.66:7002,192.168.66.66:7003,192.168.66.66:7004 2.自定义config对配置的集群节点进行解析 @Configuration //AaplicationContext.xml public class RedisClusterConfig { //注入集群节点信息 @Value(&quot;${redis.cache.clusterNodes}&quot;) private String clusterNodes; @Bean public JedisCluster getJedisCluster() { // 截取集群节点 String[] cluster = clusterNodes.split(&quot;,&quot;); // 创建set集合 Set&lt;HostAndPort&gt; nodes = new HashSet&lt;HostAndPort&gt;(); // 循环数组把集群节点添加到set集合中 for (String node : cluster) { String[] host = node.split(&quot;:&quot;); //添加集群节点 nodes.add(new HostAndPort(host[0], Integer.parseInt(host[1]))); } //创建集群节点对象 JedisCluster jc = new JedisCluster(nodes); return jc; } 3.在service实现类注入REDIS集群对象并实现缓存 @Autowired private JedisCluster jedisCluster; @Override public Map&lt;String, Object&gt; redisMap() { jedisCluster.set(&quot;user&quot;, &quot;张三丰&quot;); String value = jedisCluster.get(&quot;user&quot;); Map&lt;String, Object&gt; maps = newHashMap&lt;String,Object&gt;(); maps.put(&quot;redis&quot;, value); return maps; }]]></content>
      <categories>
        <category>springboot-redis</category>
      </categories>
      <tags>
        <tag>非关系型数据库</tag>
        <tag>redis</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
</search>
