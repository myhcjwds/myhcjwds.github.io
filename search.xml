<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SSH环境配置]]></title>
    <url>%2F2018%2F12%2F28%2Fssh-file%2F</url>
    <content type="text"><![CDATA[1.web.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&gt; &lt;display-name&gt;ssh&lt;/display-name&gt; &lt;!-- 配置Spring框架整合WEB的监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 解决hibernate延迟加载问题 --&gt; &lt;filter&gt; &lt;filter-name&gt;OpenSessionInViewFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.orm.hibernate5.support.OpenSessionInViewFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;OpenSessionInViewFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 配置Struts2框架的核心的过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;/web-app&gt; 2.spring核心配置文件（applicationContext.xml）&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!-- 编写bean，名称都是固定，加载hibernate.cfg.xml的配置文件 --&gt; &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:hibernate.cfg.xml&quot;/&gt; &lt;/bean&gt; &lt;!-- 先配置平台事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;&gt; &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&gt; &lt;/bean&gt; &lt;!-- 开启事务的注解 --&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; &lt;!-- 配置客户模块 --&gt; &lt;!-- 强调：以后配置Action，必须是多例的 --&gt; &lt;bean id=&quot;UserAction&quot; class=&quot;com.shuai.controller.UserAction&quot; scope=&quot;prototype&quot;&gt; &lt;property name=&quot;userService&quot; ref=&quot;userService&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.shuai.service.impl.UserServiceImpl&quot;&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; &lt;/bean&gt; &lt;!-- Dao都需要继承HibernateDaoSupport，注入sessionFactory --&gt; &lt;bean id=&quot;userDao&quot; class=&quot;com.shuai.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;CarAction&quot; class=&quot;com.shuai.controller.CarAction&quot; scope=&quot;prototype&quot;&gt; &lt;property name=&quot;carService&quot; ref=&quot;carService&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;carService&quot; class=&quot;com.shuai.service.impl.CarServiceImpl&quot;&gt; &lt;property name=&quot;carDao&quot; ref=&quot;carDao&quot;/&gt; &lt;/bean&gt; &lt;!-- Dao都需要继承HibernateDaoSupport，注入sessionFactory --&gt; &lt;bean id=&quot;carDao&quot; class=&quot;com.shuai.dao.impl.CarDaoImpl&quot;&gt; &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&gt; &lt;/bean&gt; &lt;!-- 如果不继承HibernateDaoSupport,则需要配置 --&gt; &lt;!-- &lt;bean id=&quot;hibernateTemplate&quot; class=&quot;org.springframework.orm.hibernate5.HibernateTemplate&quot;&gt; &lt;property name=&quot;sessionFactory&quot;&gt;&lt;/property&gt; &lt;/bean&gt; --&gt; &lt;/beans&gt; 3.struts2核心配置文件(struts.xml)&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE struts PUBLIC &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot; &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt; &lt;struts&gt; &lt;!-- 先配置包结构 --&gt; &lt;package name=&quot;ssh&quot; extends=&quot;struts-default&quot; namespace=&quot;/&quot;&gt; &lt;!-- 定义了拦截器 第一种方式 &lt;interceptors&gt; &lt;interceptor name=&quot;DemoInterceptor&quot; class=&quot;com.itheima.interceptor.DemoInterceptor&quot;/&gt; &lt;/interceptors&gt; --&gt; &lt;!-- 定义拦截器栈 &lt;interceptors&gt; &lt;interceptor name=&quot;loginFilter&quot; class=&quot;com.shuai.filter.LoginFilter&quot;/&gt; &lt;interceptor-stack name=&quot;myStack&quot;&gt; &lt;interceptor-ref name=&quot;loginFilter&quot;/&gt; &lt;interceptor-ref name=&quot;defaultStack&quot;/&gt; &lt;/interceptor-stack&gt; &lt;/interceptors&gt; --&gt; &lt;!-- 配置客户的Action，如果Action由Spring框架来管理，class标签上只需要编写ID值就OK --&gt; &lt;action name=&quot;user_*&quot; class=&quot;UserAction&quot; method=&quot;{1}&quot;&gt; &lt;!-- &lt;interceptor-ref name=&quot;myStack&quot;/&gt; --&gt; &lt;result name=&quot;overlogin&quot;&gt;main.jsp&lt;/result&gt; &lt;result name=&quot;tologin&quot;&gt;index.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name=&quot;car_*&quot; class=&quot;CarAction&quot; method=&quot;{1}&quot;&gt; &lt;result name=&quot;carlist&quot;&gt;carlist.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; &lt;/struts&gt; 4.hibernate核心配置文件(hibernate.cfg.xml)&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt; &lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 必须配置 --&gt; &lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;hibernate.connection.url&quot;&gt;jdbc:mysql:///ssh&lt;/property&gt; &lt;property name=&quot;hibernate.connection.username&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;hibernate.connection.password&quot;&gt;root&lt;/property&gt; &lt;!-- mysql方言 必须配置 --&gt; &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 可选配置 --&gt; &lt;property name=&quot;hibernate.show_sql&quot;&gt;true&lt;/property&gt; &lt;!-- 显示日志打印 --&gt; &lt;property name=&quot;hibernate.format_sql&quot;&gt;true&lt;/property&gt; &lt;!-- 格式化日志打印 --&gt; &lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/property&gt; &lt;!-- 关系映射自动更新数据库 --&gt; &lt;!-- 配置C3P0的连接池 --&gt; &lt;property name=&quot;connection.provider_class&quot;&gt;org.hibernate.connection.C3P0ConnectionProvider&lt;/property&gt; &lt;!-- 不能配置绑定当前的线程的操作 --&gt; &lt;!-- 映射配置文件 --&gt; &lt;mapping resource=&quot;com/shuai/domain/Car.hbm.xml&quot;/&gt; &lt;mapping resource=&quot;com/shuai/domain/User.hbm.xml&quot;/&gt; &lt;/session-factory&gt; &lt;/hibernate-configuration&gt; 5.pojo映射配置文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt; &lt;hibernate-mapping&gt; &lt;class name=&quot;com.shuai.domain.User&quot; table=&quot;user&quot;&gt; &lt;!-- 如果数据库字段名和持久化类 中字段名称一致，cloumn可不写--&gt; &lt;id name=&quot;user_id&quot; column=&quot;user_id&quot;&gt; &lt;!-- 如果是mysql则使用mysql提供的主键id自动递增，如果是oracle则利用oracle提供的序列递增--&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;!-- 属性映射 --&gt; &lt;property name=&quot;user_num&quot; column=&quot;user_num&quot;/&gt; &lt;property name=&quot;user_psw&quot; column=&quot;user_psw&quot;/&gt; &lt;property name=&quot;user_name&quot; column=&quot;user_name&quot;/&gt; &lt;property name=&quot;user_sex&quot; column=&quot;user_sex&quot;/&gt; &lt;property name=&quot;user_age&quot; column=&quot;user_age&quot;/&gt; &lt;set name=&quot;cars&quot;&gt; &lt;key column=&quot;user_car_id&quot;&gt;&lt;/key&gt; &lt;one-to-many class=&quot;com.shuai.domain.Car&quot;/&gt; &lt;/set&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; 6. log4j配置文件### direct log messages to stdout ### log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.Target=System.err log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%d{ABSOLUTE} %5p %c{1}:%L - %m%n ### direct messages to file mylog.log ### log4j.appender.file=org.apache.log4j.FileAppender log4j.appender.file.File=c\:mylog.log log4j.appender.file.layout=org.apache.log4j.PatternLayout log4j.appender.file.layout.ConversionPattern=%d{ABSOLUTE} %5p %c{1}:%L - %m%n ### set log levels - for more verbose logging change &apos;info&apos; to &apos;debug&apos; ### log4j.rootLogger=info, stdout 7.值栈的运用（action的书写格式以及三种值栈存值）package com.shuai.controller; import java.util.ArrayList; import java.util.HashSet; import java.util.List; import com.shuai.service.CarService; import com.opensymphony.xwork2.ActionContext; import com.opensymphony.xwork2.ActionSupport; import com.opensymphony.xwork2.ModelDriven; import com.opensymphony.xwork2.util.ValueStack; import com.shuai.domain.Car; public class CarAction extends ActionSupport { private static final long serialVersionUID = 113695314694166436L; private List&lt;Car&gt; list = new ArrayList&lt;Car&gt;(); public List&lt;Car&gt; getList() { return list; } private CarService carService; public void setCarService(CarService carService) { this.carService = carService; } public String list() { //ValueStack vs = ActionContext.getContext().getValueStack(); list = carService.list(); /** * 存入值栈的三种方法 * 1.调用值栈对象的set方法(通常 存 集合对象 时使用) * 2.调用值栈对象的push方法(通常 存 单个对象 使用) * 3.在action中生成变量(提供get方法) */ return &quot;carlist&quot;; } } 8.jsp取值栈(EL表达式/ognl表达式)&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot; %&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;ISO-8859-1&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;s:property value=&quot;list[0].car_name&quot;/&gt; &lt;s:property value=&quot;list[0].car_brand&quot;/&gt; ${list[1].car_name}--${list[1].car_id} &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>SSH</category>
      </categories>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH整合讲解(spring整合hibernate/spring整合structs2)]]></title>
    <url>%2F2018%2F12%2F26%2Fssh%2F</url>
    <content type="text"><![CDATA[一.技术分析之SSH三大框架需要的jar包1. Struts2框架 * struts-2.3.24\apps\struts2-blank\WEB-INF\lib\*.jar -- Struts2需要的所有jar包 * struts2-spring-plugin-2.3.24.jar ---Struts2整合Spring的插件包 2. Hibernate框架 * hibernate-release-5.0.7.Final\lib\required\*.jar -- Hibernate框架需要的jar包 * slf4j-api-1.6.1.jar -- 日志接口 * slf4j-log4j12-1.7.2.jar -- 日志实现 * mysql-connector-java-5.1.7-bin.jar -- MySQL的驱动包 3. Spring框架 * IOC核心包 * AOP核心包 * JDBC模板和事务核心包 * Spring整合JUnit测试包 * Spring整合Hibernate核心包 * Spring整合Struts2核心包 二.SSH三大框架需要的配置文件1. Struts2框架 * 在web.xml中配置核心的过滤器 &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; * 在src目录下创建struts.xml，用来配置Action 2. Hibernate框架 * 在src目录创建hibernate.cfg.xml配置文件 * 在JavaBean所在的包下映射的配置文件 3. Spring框架 * 在web.xml配置整合WEB的监听器 &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; * 在src目录下创建applicationContext.xml * 在src目录下log4j.proerties 三.Spring框架整合Struts2框架1. 导入CRM项目的UI页面，找到添加客户的页面，修改form表单，访问Action 2. 编写CustomerAction接收请求，在struts.xml中完成Action的配置 &lt;package name=&quot;crm&quot; extends=&quot;struts-default&quot; namespace=&quot;/&quot;&gt; &lt;action name=&quot;customer_*&quot; class=&quot;com.itheima.web.action.CustomerAction&quot; method=&quot;{1}&quot;&gt; &lt;/action&gt; &lt;/package&gt; 3. 在Action中获取到service（开发不会使用，因为麻烦） * 可以通过 WebApplicationContextUtils.getWebApplicationContext(ServletActionContext.getServletContext()); 来获取，但是这种方式编写代码太麻烦了！！ 4. Spring整合Struts2框架的第一种方式（Action由Struts2框架来创建） * 因为导入的struts2-spring-plugin-2.3.24.jar 包自带一个配置文件 struts-plugin.xml ，该配置文件中有如下代码 * &lt;constant name=&quot;struts.objectFactory&quot; value=&quot;spring&quot; /&gt; 开启一个常量，如果该常量开启，那么下面的常量就可以使用 * struts.objectFactory.spring.autoWire = name，该常量是可以让Action的类来自动装配Bean对象！！ 5. Spring整合Struts2框架的第二种方式（Action由Spring框架来创建）（推荐大家来使用的） * 把具体的Action类配置文件applicatonContext.xml的配置文件中，但是注意：struts.xml需要做修改 * applicationContext.xml * &lt;bean id=&quot;customerAction&quot; class=&quot;com.itheima.web.action.CustomerAction&quot; scope=&quot;prototype&quot;&gt; * struts.xml中的修改，把全路径修改成ID值 * &lt;action name=&quot;customer_*&quot; class=&quot;customerAction&quot; method=&quot;{1}&quot;&gt; * 第二种方式需要有两个注意的地方 * Spring框架默认生成CustomerAction是单例的，而Struts2框架是多例的。所以需要配置 scope=&quot;prototype&quot; * CustomerService现在必须自己手动注入了 四.Spring框架整合Hibernate框架（带有hibernate.cfg.xml的配置文件。强调：不能加绑定当前线程的配置）1. 编写CustomerDaoImpl的代码，加入配置并且在CustomerServiceImpl中完成注入 2. 编写映射的配置文件，并且在hibernate.cfg.xml的配置文件中引入映射的配置文件 3. 在applicationContext.xml的配置文件，配置加载hibernate.cfg.xml的配置 &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:hibernate.cfg.xml&quot;/&gt; &lt;/bean&gt; 4. 在CustomerDaoImpl中想完成数据的添加，Spring框架提供了一个HibernateDaoSupport的工具类，以后DAO都可以继承该类！！ public class CustomerDaoImpl extends HibernateDaoSupport implements CustomerDao { public void save(Customer c) { System.out.println(&quot;持久层...&quot;); this.getHibernateTemplate().save(c); } } &lt;bean id=&quot;customerDao&quot; class=&quot;com.itheima.dao.CustomerDaoImpl&quot;&gt; &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&gt; &lt;/bean&gt; 5. 开启事务的配置 * 先配置事务管理器，注意现在使用的是Hibernate框架，所以需要使用Hibernate框架的事务管理器 &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;&gt; &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&gt; &lt;/bean&gt; * 开启注解事务 &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; * 在Service类中添加事务注解 @Transactional 五.技术分析之Spring框架整合Hibernate框架（不带有hibernate.cfg.xml的配置文件）1. Hibernate配置文件中 * 数据库连接基本参数（4大参数） * Hibernate相关的属性 * 连接池 * 映射文件 2. 开始进行配置 * 先配置连接池相关的信息 &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql:///xxx&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/bean&gt; * 修改 LocalSessionFactoryBean 的属性配置，因为已经没有了hibernate.cfg.xml的配置文件，所以需要修改该配置，注入连接池 &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; * 继续在 LocalSessionFactoryBean 中配置，使用hibernateProperties属性继续来配置其他的属性，注意值是properties属性文件 &lt;!-- 配置其他的属性 --&gt; &lt;property name=&quot;hibernateProperties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/prop&gt; &lt;prop key=&quot;hibernate.show_sql&quot;&gt;true&lt;/prop&gt; &lt;prop key=&quot;hibernate.format_sql&quot;&gt;true&lt;/prop&gt; &lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- 配置映射 --&gt; &lt;property name=&quot;mappingResources&quot;&gt; &lt;list&gt; &lt;value&gt;com/itheima/domain/Customer.hbm.xml&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; 六.技术分析之Hibernate的模板的常用的方法1. 增删改的操作: * 添加: * save(Object obj); * 修改: * update(Object obj); * 删除: * delete(Object obj); 2. 查询的操作: * 查询一条记录: * Object get(Class c,Serializable id); * Object load(Class c,Serializable id); 3. 查询多条记录: * List find(String hql,Object... args); 七.延迟加载问题1. 使用延迟加载的时候，再WEB层查询对象的时候程序会抛出异常！ * 原因是延迟加载还没有发生SQL语句，在业务层session对象就已经销毁了，所以查询到的JavaBean对象已经变成了托管态对象！ * 注意：一定要先删除javassist-3.11.0.GA.jar包（jar包冲突了） 2. 解决办法非常简单，Spring框架提供了一个过滤器，让session对象在WEB层就创建，在WEB层销毁。只需要配置该过滤器即可 * 但是：要注意需要在struts2的核心过滤器之前进行配置 &lt;filter&gt; &lt;filter-name&gt;OpenSessionInViewFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.orm.hibernate5.support.OpenSessionInViewFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;OpenSessionInViewFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;]]></content>
      <categories>
        <category>SSH</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>spring整合hibernate</tag>
        <tag>spring整合structs2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring高级篇(AOP[注解方式]/spring AOP/Spring框架的JDBC模板/Spring的事务管理)]]></title>
    <url>%2F2018%2F12%2F25%2Fspring3%2F</url>
    <content type="text"><![CDATA[Spring框架的学习路线 1. Spring入门篇：Spring的IOC容器之XML的方式，Spring框架与Web项目整合 2. Spring进阶篇：Spring的IOC容器之注解的方式，Spring的AOP技术 3. Spring高级篇：Spring的事务管理、Spring框架的JDBC模板 本篇内容概述 一. Spring框架的AOP之注解的方式 二. Spring框架的JDBC模板 三. Spring框架的事务管理 一.技术分析之：Spring框架的AOP技术（注解方式）1.基本架构构建1. 步骤一：创建JavaWEB项目，引入具体的开发的jar包 * 先引入Spring框架开发的基本开发包 * 再引入Spring框架的AOP的开发包 * spring的传统AOP的开发的包 * spring-aop-4.2.4.RELEASE.jar * com.springsource.org.aopalliance-1.0.0.jar * aspectJ的开发包 * com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar * spring-aspects-4.2.4.RELEASE.jar 2. 步骤二：创建Spring的配置文件，引入具体的AOP的schema约束 &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;/beans&gt; 3. 步骤三：创建包结构，编写具体的接口和实现类 * com.itheima.demo1 * CustomerDao -- 接口 * CustomerDaoImpl -- 实现类 4. 步骤四：将目标类配置到Spring中 &lt;bean id=&quot;customerDao&quot; class=&quot;com.itheima.demo1.CustomerDaoImpl&quot;/&gt; 5. 步骤五：定义切面类 * 添加切面和通知的注解 * @Aspect -- 定义切面类的注解 * 通知类型（注解的参数是切入点的表达式） * @Before -- 前置通知 * @AfterReturing -- 后置通知 * @Around -- 环绕通知 * @After -- 最终通知 * @AfterThrowing -- 异常抛出通知 * 具体的代码如下 @Aspect public class MyAspectAnno { @Before(value=&quot;execution(public void com.itheima.demo1.CustomerDaoImpl.save())&quot;) public void log(){ System.out.println(&quot;记录日志...&quot;); } } 6. 步骤六：在配置文件中定义切面类 &lt;bean id=&quot;myAspectAnno&quot; class=&quot;com.itheima.demo1.MyAspectAnno&quot;/&gt; 7. 步骤七：在配置文件中开启自动代理 &lt;aop:aspectj-autoproxy/&gt; 8. 完成测试 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) public class Demo1 { @Resource(name=&quot;customerDao&quot;) private CustomerDao customerDao; @Test public void run1(){ customerDao.save(); customerDao.update(); } } 2.通知类型1. 通知类型 * @Before -- 前置通知 * @AfterReturing -- 后置通知 * @Around -- 环绕通知（目标对象方法默认不执行的，需要手动执行） * @After -- 最终通知 * @AfterThrowing -- 异常抛出通知 2. 配置通用的切入点 * 使用@Pointcut定义通用的切入点 @Aspect public class MyAspectAnno { @Before(value=&quot;MyAspectAnno.fn()&quot;) public void log(){ System.out.println(&quot;记录日志...&quot;); } @Pointcut(value=&quot;execution(public void com.itheima.demo1.CustomerDaoImpl.save())&quot;) public void fn(){} } 二.Spring框架的JDBC模板技术1.技术分析之Spring框架的JDBC模板技术概述1. Spring框架中提供了很多持久层的模板类来简化编程，使用模板类编写程序会变的简单 2. 提供了JDBC模板，Spring框架提供的 * JdbcTemplate类 3. Spring框架可以整合Hibernate框架，也提供了模板类 * HibernateTemplate类 2.技术分析之演示JDBC的模板类1. 步骤一：创建数据库的表结构 create database spring_day03; use spring_day03; create table t_account( id int primary key auto_increment, name varchar(20), money double ); 2. 引入开发的jar包 * 先引入IOC基本的6个jar包 * 再引入Spring-aop的jar包 * 最后引入JDBC模板需要的jar包 * MySQL数据库的驱动包 * Spring-jdbc.jar * Spring-tx.jar 3. 编写测试代码（自己来new对象的方式） @Test public void run1(){ // 创建连接池，先使用Spring框架内置的连接池 DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql:///spring_day03&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); // 创建模板类 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); // 完成数据的添加 jdbcTemplate.update(&quot;insert into t_account values (null,?,?)&quot;, &quot;测试&quot;,10000); } 3.技术分析之使用Spring框架来管理模板类1. 刚才编写的代码使用的是new的方式，应该把这些类交给Spring框架来管理。 2. 修改的步骤如下 * 步骤一：Spring管理内置的连接池 &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///spring_day03&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/bean&gt; * 步骤二：Spring管理模板类 &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; * 步骤三：编写测试程序 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) public class Demo2 { @Resource(name=&quot;jdbcTemplate&quot;) private JdbcTemplate jdbcTemplate; @Test public void run2(){ jdbcTemplate.update(&quot;insert into t_account values (null,?,?)&quot;, &quot;测试2&quot;,10000); } } 4.Spring框架管理开源的连接池1. 管理DBCP连接池 * 先引入DBCP的2个jar包 * com.springsource.org.apache.commons.dbcp-1.2.2.osgi.jar * com.springsource.org.apache.commons.pool-1.5.3.jar * 编写配置文件 &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///spring_day03&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/bean&gt; 2. 管理C3P0连接池 * 先引入C3P0的jar包 * com.springsource.com.mchange.v2.c3p0-0.9.1.2.jar * 编写配置文件 &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql:///spring_day03&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/bean&gt; 5.pring框架的JDBC模板的简单操作1. 增删改查的操作 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) public class SpringDemo3 { @Resource(name=&quot;jdbcTemplate&quot;) private JdbcTemplate jdbcTemplate; @Test // 插入操作 public void demo1(){ jdbcTemplate.update(&quot;insert into account values (null,?,?)&quot;, &quot;冠希&quot;,10000d); } @Test // 修改操作 public void demo2(){ jdbcTemplate.update(&quot;update account set name=?,money =? where id = ?&quot;, &quot;思雨&quot;,10000d,5); } @Test // 删除操作 public void demo3(){ jdbcTemplate.update(&quot;delete from account where id = ?&quot;, 5); } @Test // 查询一条记录 public void demo4(){ Account account = jdbcTemplate.queryForObject(&quot;select * from account where id = ?&quot;, new BeanMapper(), 1); System.out.println(account); } @Test // 查询所有记录 public void demo5(){ List&lt;Account&gt; list = jdbcTemplate.query(&quot;select * from t_account&quot;, new BeanMapper()); for (Account account : list) { System.out.println(account); } } } class BeanMapper implements RowMapper&lt;Account&gt;{ public Account mapRow(ResultSet rs, int arg1) throws SQLException { Account account = new Account(); account.setId(rs.getInt(&quot;id&quot;)); account.setName(rs.getString(&quot;name&quot;)); account.setMoney(rs.getDouble(&quot;money&quot;)); return account; } } 三.Spring框架的事务管理1.事务的回顾1. 事务：指的是逻辑上一组操作，组成这个事务的各个执行单元，要么一起成功,要么一起失败！ 2. 事务的特性 * 原子性 * 一致性 * 隔离性 * 持久性 3. 如果不考虑隔离性,引发安全性问题 * 读问题: * 脏读: * 不可重复读: * 虚读: * 写问题: * 丢失更新: 4. 如何解决安全性问题 * 读问题解决，设置数据库隔离级别 * 写问题解决可以使用 悲观锁和乐观锁的方式解决 2.Spring框架的事务管理相关的类和API1. PlatformTransactionManager接口 -- 平台事务管理器.(真正管理事务的类)。该接口有具体的实现类，根据不同的持久层框架，需要选择不同的实现类！ 2. TransactionDefinition接口 -- 事务定义信息.(事务的隔离级别,传播行为,超时,只读) 3. TransactionStatus接口 -- 事务的状态 4. 总结：上述对象之间的关系：平台事务管理器真正管理事务对象.根据事务定义的信息TransactionDefinition 进行事务管理，在管理事务中产生一些状态.将状态记录到TransactionStatus中 5. PlatformTransactionManager接口中实现类和常用的方法 1. 接口的实现类 * 如果使用的Spring的JDBC模板或者MyBatis框架，需要选择DataSourceTransactionManager实现类 * 如果使用的是Hibernate的框架，需要选择HibernateTransactionManager实现类 2. 该接口的常用方法 * void commit(TransactionStatus status) * TransactionStatus getTransaction(TransactionDefinition definition) * void rollback(TransactionStatus status) 6. TransactionDefinition 1. 事务隔离级别的常量 * static int ISOLATION_DEFAULT -- 采用数据库的默认隔离级别 * static int ISOLATION_READ_UNCOMMITTED * static int ISOLATION_READ_COMMITTED * static int ISOLATION_REPEATABLE_READ * static int ISOLATION_SERIALIZABLE 2. 事务的传播行为常量（不用设置，使用默认值） * 先解释什么是事务的传播行为：解决的是业务层之间的方法调用！！ * PROPAGATION_REQUIRED（默认值） -- A中有事务,使用A中的事务.如果没有，B就会开启一个新的事务,将A包含进来.(保证A,B在同一个事务中)，默认值！！ * PROPAGATION_SUPPORTS -- A中有事务,使用A中的事务.如果A中没有事务.那么B也不使用事务. * PROPAGATION_MANDATORY -- A中有事务,使用A中的事务.如果A没有事务.抛出异常. * PROPAGATION_REQUIRES_NEW（记）-- A中有事务,将A中的事务挂起.B创建一个新的事务.(保证A,B没有在一个事务中) * PROPAGATION_NOT_SUPPORTED -- A中有事务,将A中的事务挂起. * PROPAGATION_NEVER -- A中有事务,抛出异常. * PROPAGATION_NESTED（记） -- 嵌套事务.当A执行之后,就会在这个位置设置一个保存点.如果B没有问题.执行通过.如果B出现异常,运行客户根据需求回滚(选择回滚到保存点或者是最初始状态) 3.搭建事务管理转账案例的环境（强调：简化开发，以后DAO可以继承JdbcDaoSupport类）1. 步骤一：创建WEB工程，引入需要的jar包 * IOC的6个包 * AOP的4个包 * C3P0的1个包 * MySQL的驱动包 * JDBC目标2个包 * 整合JUnit测试包 2. 步骤二：引入配置文件 * 引入配置文件 * 引入log4j.properties * 引入applicationContext.xml &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql:///spring_day03&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/bean&gt; 3. 步骤三：创建对应的包结构和类 * com.itheima.demo1 * AccountService * AccountServlceImpl * AccountDao * AccountDaoImpl 4. 步骤四:引入Spring的配置文件,将类配置到Spring中 &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.demo1.AccountServiceImpl&quot;&gt; &lt;/bean&gt; &lt;bean id=&quot;accountDao&quot; class=&quot;com.itheima.demo1.AccountDaoImpl&quot;&gt; &lt;/bean&gt; 5. 步骤五：在业务层注入DAO ,在DAO中注入JDBC模板（强调：简化开发，以后DAO可以继承JdbcDaoSupport类） &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.demo1.AccountServiceImpl&quot;&gt; &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;accountDao&quot; class=&quot;com.itheima.demo1.AccountDaoImpl&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; 6. 步骤六：编写DAO和Service中的方法 public class AccountDaoImpl extends JdbcDaoSupport implements AccountDao { public void outMoney(String out, double money) { this.getJdbcTemplate().update(&quot;update t_account set money = money = ? where name = ?&quot;, money,out); } public void inMoney(String in, double money) { this.getJdbcTemplate().update(&quot;update t_account set money = money + ? where name = ?&quot;, money,in); } } 7. 步骤七：编写测试程序. @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) public class Demo1 { @Resource(name=&quot;accountService&quot;) private AccountService accountService; @Test public void run1(){ accountService.pay(&quot;冠希&quot;, &quot;美美&quot;, 1000); } } 4.Spring框架的事务管理的分类1. Spring的事务管理的分类 1. Spring的编程式事务管理（不推荐使用） * 通过手动编写代码的方式完成事务的管理（不推荐） 2. Spring的声明式事务管理（底层采用AOP的技术） * 通过一段配置的方式完成事务的管理（重点掌握注解的方式） 5.Spring框架的事务管理之编程式的事务管理（了解）1. 说明：Spring为了简化事务管理的代码:提供了模板类 TransactionTemplate，所以手动编程的方式来管理事务，只需要使用该模板类即可！！ 2. 手动编程方式的具体步骤如下： 1. 步骤一:配置一个事务管理器，Spring使用PlatformTransactionManager接口来管理事务，所以咱们需要使用到他的实现类！！ &lt;!-- 配置事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; 2. 步骤二:配置事务管理的模板 &lt;!-- 配置事务管理的模板 --&gt; &lt;bean id=&quot;transactionTemplate&quot; class=&quot;org.springframework.transaction.support.TransactionTemplate&quot;&gt; &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot;/&gt; &lt;/bean&gt; 3. 步骤三:在需要进行事务管理的类中,注入事务管理的模板. &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.demo1.AccountServiceImpl&quot;&gt; &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&gt; &lt;property name=&quot;transactionTemplate&quot; ref=&quot;transactionTemplate&quot;/&gt; &lt;/bean&gt; 4. 步骤四:在业务层使用模板管理事务: // 注入事务模板对象 private TransactionTemplate transactionTemplate; public void setTransactionTemplate(TransactionTemplate transactionTemplate) { this.transactionTemplate = transactionTemplate; } public void pay(final String out, final String in, final double money) { transactionTemplate.execute(new TransactionCallbackWithoutResult() { protected void doInTransactionWithoutResult(TransactionStatus status) { // 扣钱 accountDao.outMoney(out, money); int a = 10/0; // 加钱 accountDao.inMoney(in, money); } }); } 6.Spring框架的事务管理之声明式事务管理，即通过配置文件来完成事务管理(AOP思想)**1. 声明式事务管理又分成两种方式 * 基于AspectJ的XML方式（重点掌握） * 基于AspectJ的注解方式（重点掌握） 7.Spring框架的事务管理之基于AspectJ的XML方式（重点掌握）**1. 步骤一:恢复转账开发环境 2. 步骤二:引入AOP的开发包 3. 步骤三:配置事务管理器 &lt;!-- 配置事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; 4. 步骤四:配置事务增强 &lt;!-- 配置事务增强 --&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;!-- name ：绑定事务的方法名，可以使用通配符，可以配置多个。 propagation ：传播行为 isolation ：隔离级别 read-only ：是否只读 timeout ：超时信息 rollback-for：发生哪些异常回滚. no-rollback-for：发生哪些异常不回滚. --&gt; &lt;!-- 哪些方法加事务 --&gt; &lt;tx:method name=&quot;pay&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; 5. 步骤五:配置AOP的切面 &lt;!-- 配置AOP切面产生代理 --&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref=&quot;myAdvice&quot; pointcut=&quot;execution(* com.itheima.demo2.AccountServiceImpl.pay(..))&quot;/&gt; &lt;/aop:config&gt; * 注意：如果是自己编写的切面，使用&lt;aop:aspect&gt;标签，如果是系统制作的，使用&lt;aop:advisor&gt;标签。 6. 步骤六:编写测试类 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:applicationContext2.xml&quot;) public class Demo2 { @Resource(name=&quot;accountService&quot;) private AccountService accountService; @Test public void run1(){ accountService.pay(&quot;冠希&quot;, &quot;美美&quot;, 1000); } } 8.Spring框架的事务管理之基于AspectJ的注解方式（重点掌握，最简单的方式）1. 步骤一:恢复转账的开发环境 2. 步骤二:配置事务管理器 &lt;!-- 配置事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; 3. 步骤三:开启注解事务 &lt;!-- 开启注解事务 --&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; 4. 步骤四:在业务层上添加一个注解:@Transactional 5. 编写测试类 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:applicationContext3.xml&quot;) public class Demo3 { @Resource(name=&quot;accountService&quot;) private AccountService accountService; @Test public void run1(){ accountService.pay(&quot;冠希&quot;, &quot;美美&quot;, 1000); } }]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>spring高级篇</tag>
        <tag>spring AOP（控制反转[注解方式]）</tag>
        <tag>Spring的事务管理</tag>
        <tag>Spring框架的JDBC模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring进阶篇(IOC[注解方式]/spring AOP)]]></title>
    <url>%2F2018%2F12%2F24%2Fspring2%2F</url>
    <content type="text"><![CDATA[Spring框架的学习路线 1. Spring入门篇：Spring的IOC容器之XML的方式，Spring框架与Web项目整合 2. Spring进阶篇：Spring的IOC容器之注解的方式，Spring的AOP技术 3. Spring高级篇：Spring的事务管理、Spring框架的JDBC模板 本篇内容概述 一. Spring框架的IOC基于注解的方式 二. Spring框架整合JUnit单元测试 三. AOP的概述 四. AOP的底层实现原理（了解） 五. AOP功能基于AspectJ的配置文件方式 一.Spring框架的IOC功能之注解的方式1.Spring框架的IOC之注解方式的快速入门1. 步骤一：导入注解开发所有需要的jar包 * 引入IOC容器必须的6个jar包 * 多引入一个：Spring框架的AOP的jar包，spring-aop的jar包 2. 步骤二：创建对应的包结构，编写Java的类 * UserService -- 接口 * UserServiceImpl -- 具体的实现类 3. 步骤三：在src的目录下，创建applicationContext.xml的配置文件，然后引入约束。注意：因为现在想使用注解的方式，那么引入的约束发生了变化 * 需要引入context的约束，具体的约束如下 &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- bean definitions here --&gt; &lt;/beans&gt; 4. 步骤四：在applicationContext.xml配置文件中开启组件扫描 * Spring的注解开发:组件扫描 &lt;context:component-scan base-package=&quot;com.itheima.demo1&quot;/&gt; * 注意：可以采用如下配置 &lt;context:component-scan base-package=&quot;com.itheima&quot;/&gt; 这样是扫描com.itheima包下所有的内容 5. 步骤五：在UserServiceImpl的实现类上添加注解 * @Component(value=&quot;userService&quot;) -- 相当于在XML的配置方式中 &lt;bean id=&quot;userService&quot; class=&quot;...&quot;&gt; 6. 步骤六：编写测试代码 public class SpringDemo1 { @Test public void run1(){ ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserService us = (UserService) ac.getBean(&quot;userService&quot;); us.save(); } } 2.Spring框架中Bean管理的常用注解1. @Component:组件.(作用在类上) 2. Spring中提供@Component的三个衍生注解:(功能目前来讲是一致的) * @Controller -- 作用在WEB层 * @Service -- 作用在业务层 * @Repository -- 作用在持久层 * 说明：这三个注解是为了让标注类本身的用途清晰，Spring在后续版本会对其增强 3. 属性注入的注解(说明：使用注解注入的方式,可以不用提供set方法) * 如果是注入的普通类型，可以使用value注解 * @Value -- 用于注入普通类型 * 如果注入的是对象类型，使用如下注解 * @Autowired -- 默认按类型进行自动装配 * 如果想按名称注入 * @Qualifier -- 强制使用名称注入 * @Resource -- 相当于@Autowired和@Qualifier一起使用 * 强调：Java提供的注解 * 属性使用name属性 3.Bean的作用范围和生命周期的注解1. Bean的作用范围注解(同 xml IOC开发： &lt;bean id=&quot;&quot;,class=&quot;&quot;, scope=&quot;&quot;&gt;) * 注解为@Scope(value=&quot;prototype&quot;)，作用在类上。值如下： * singleton -- 单例，默认值 * prototype -- 多例 2. Bean的生命周期的配置（了解） * 注解如下： * @PostConstruct -- 相当于init-method * @PreDestroy -- 相当于destroy-method 二.Spring框架整合JUnit单元测试1. 为了简化了JUnit的测试，使用Spring框架也可以整合测试 2. 具体步骤 * 要求：必须先有JUnit的环境（即已经导入了JUnit4的开发环境）！！ * 步骤一：在程序中引入:spring-test.jar * 步骤二：在具体的测试类上添加注解 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) public class SpringDemo1 { @Resource(name=&quot;userService&quot;) private UserService userService; @Test public void demo2(){ userService.save(); } } 三.AOP的概述1. 什么是AOP的技术？ * 在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程 * AOP是一种编程范式，隶属于软工范畴，指导开发者如何组织程序结构 * AOP最早由AOP联盟的组织提出的,制定了一套规范.Spring将AOP思想引入到框架中,必须遵守AOP联盟的规范 * 通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术 * AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型 * 利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率 2. AOP:面向切面编程.(思想.---解决OOP遇到一些问题) 3. AOP采取横向抽取机制，取代了传统纵向继承体系重复性代码（性能监视、事务管理、安全检查、缓存） 4. 为什么要学习AOP * 可以在不修改源代码的前提下，对程序进行增强！！ 四.Spring框架的AOP的底层实现1.基本概述1. Srping框架的AOP技术底层也是采用的代理技术，代理的方式提供了两种 1. 基于JDK的动态代理 * 必须是面向接口的，只有实现了具体接口的类才能生成代理对象 2. 基于CGLIB动态代理 * 对于没有实现了接口的类，也可以产生代理，产生这个类的子类的方式 2. Spring的传统AOP中根据类是否实现接口，来采用不同的代理方式 1. 如果实现类接口，使用JDK动态代理完成AOP 2. 如果没有实现接口，采用CGLIB动态代理完成AOP 2.JDK的动态代理（代码了解，理解原理）1. 使用Proxy类来生成代理对象的一些代码如下： /** * 使用JDK的方式生成代理对象 * @author Administrator */ public class MyProxyUtils { public static UserDao getProxy(final UserDao dao) { // 使用Proxy类生成代理对象 UserDao proxy = (UserDao) Proxy.newProxyInstance(dao.getClass().getClassLoader(), dao.getClass().getInterfaces(), new InvocationHandler() { // 代理对象方法一直线，invoke方法就会执行一次 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { if(&quot;save&quot;.equals(method.getName())){ System.out.println(&quot;记录日志...&quot;); // 开启事务 } // 提交事务 // 让dao类的save或者update方法正常的执行下去 return method.invoke(dao, args); } }); // 返回代理对象 return proxy; } } 3.CGLIB的代理技术（代码了解）1. 引入CBLIB的开发包 * 如果想使用CGLIB的技术来生成代理对象，那么需要引入CGLIB的开发的jar包，在Spring框架核心包中已经引入了CGLIB的开发包了。所以直接引入Spring核心开发包即可！ 2. 编写相关的代码 public static OrderDaoImpl getProxy(){ // 创建CGLIB核心的类 Enhancer enhancer = new Enhancer(); // 设置父类 enhancer.setSuperclass(OrderDaoImpl.class); // 设置回调函数 enhancer.setCallback(new MethodInterceptor() { @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy methodProxy) throws Throwable { if(&quot;save&quot;.equals(method.getName())){ // 记录日志 System.out.println(&quot;记录日志了...&quot;); } return methodProxy.invokeSuper(obj, args); } }); // 生成代理对象 OrderDaoImpl proxy = (OrderDaoImpl) enhancer.create(); return proxy; } 五.Spring基于AspectJ的AOP的开发1.技术分析之AOP的相关术语1. Joinpoint(连接点) -- 所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法,因为spring只支持方法类型的连接点 2. Pointcut(切入点) -- 所谓切入点是指我们要对哪些Joinpoint进行拦截的定义 3. Advice(通知/增强) -- 所谓通知是指拦截到Joinpoint之后所要做的事情就是通知.通知分为前置通知,后置通知,异常通知,最终通知,环绕通知(切面要完成的功能) 4. Introduction(引介) -- 引介是一种特殊的通知在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或Field 5. Target(目标对象) -- 代理的目标对象 6. Weaving(织入) -- 是指把增强应用到目标对象来创建新的代理对象的过程 7. Proxy（代理） -- 一个类被AOP织入增强后，就产生一个结果代理类 8. Aspect(切面) -- 是切入点和通知的结合，以后咱们自己来编写和配置的 2.技术分析之AspectJ的XML方式完成AOP的开发1. 步骤一：创建JavaWEB项目，引入具体的开发的jar包 * 先引入Spring框架开发的基本开发包 * 再引入Spring框架的AOP的开发包 * spring的传统AOP的开发的包 * spring-aop-4.2.4.RELEASE.jar * com.springsource.org.aopalliance-1.0.0.jar * aspectJ的开发包 * com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar * spring-aspects-4.2.4.RELEASE.jar 2. 步骤二：创建Spring的配置文件，引入具体的AOP的schema约束 &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; 3. 步骤三：创建包结构，编写具体的接口和实现类 * com.itheima.demo2 * CustomerDao -- 接口 * CustomerDaoImpl -- 实现类 4. 步骤四：将目标类配置到Spring中 &lt;bean id=&quot;customerDao&quot; class=&quot;com.itheima.demo3.CustomerDaoImpl&quot;/&gt; 5. 步骤五：定义切面类 public class MyAspectXml { // 定义通知 public void log(){ System.out.println(&quot;记录日志...&quot;); } } 6. 步骤六：在配置文件中定义切面类 &lt;bean id=&quot;myAspectXml&quot; class=&quot;com.itheima.demo3.MyAspectXml&quot;/&gt; 7. 步骤七：在配置文件中完成aop的配置 &lt;aop:config&gt; &lt;!-- 引入切面类 --&gt; &lt;aop:aspect ref=&quot;myAspectXml&quot;&gt; &lt;!-- 定义通知类型：切面类的方法和切入点的表达式 --&gt; &lt;aop:before method=&quot;log&quot; pointcut=&quot;execution(public * com.itheima.demo3.CustomerDaoImpl.save(..))&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 8. 完成测试 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) public class Demo3 { @Resource(name=&quot;customerDao&quot;) private CustomerDao customerDao; @Test public void run1(){ customerDao.save(); customerDao.update(); customerDao.delete(); } } 3.切入点的表达式1. 再配置切入点的时候，需要定义表达式，重点的格式如下：execution(public * *(..))，具体展开如下： * 切入点表达式的格式如下： * execution([修饰符] 返回值类型 包名.类名.方法名(参数)) * 修饰符可以省略不写，不是必须要出现的。 * 返回值类型是不能省略不写的，根据你的方法来编写返回值。可以使用 * 代替。 * 包名例如：com.itheima.demo3.BookDaoImpl * 首先com是不能省略不写的，但是可以使用 * 代替 * 中间的包名可以使用 * 号代替 * 如果想省略中间的包名可以使用 .. * 类名也可以使用 * 号代替，也有类似的写法：*DaoImpl * 方法也可以使用 * 号代替 * 参数如果是一个参数可以使用 * 号代替，如果想代表任意参数使用 .. 4.AOP的通知类型1. 前置通知 * 在目标类的方法执行之前执行。 * 配置文件信息：&lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;myPointcut3&quot;/&gt; * 应用：可以对方法的参数来做校验 2. 最终通知 * 在目标类的方法执行之后执行，如果程序出现了异常，最终通知也会执行。 * 在配置文件中编写具体的配置：&lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;myPointcut3&quot;/&gt; * 应用：例如像释放资源 3. 后置通知 * 方法正常执行后的通知。 * 在配置文件中编写具体的配置：&lt;aop:after-returning method=&quot;afterReturning&quot; pointcut-ref=&quot;myPointcut2&quot;/&gt; * 应用：可以修改方法的返回值 4. 异常抛出通知 * 在抛出异常后通知 * 在配置文件中编写具体的配置：&lt;aop:after-throwing method=&quot;afterThorwing&quot; pointcut-ref=&quot;myPointcut3&quot;/&gt; * 应用：包装异常的信息 5. 环绕通知 * 方法的执行前后执行。 * 在配置文件中编写具体的配置：&lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;myPointcut2&quot;/&gt; * 要注意：目标的方法默认不执行，需要使用ProceedingJoinPoint对来让目标对象的方法执行。]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>spring进阶篇</tag>
        <tag>spring IOC（控制反转[注解方式]）</tag>
        <tag>spring AOP（面向切面）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux基础]]></title>
    <url>%2F2018%2F12%2F24%2Flinux1%2F</url>
    <content type="text"><![CDATA[一.Linux的概述：1.什么是Linux：1.学习Linux之前先了解UnixUnix是一个强大的多用户、多任务操作系统。于1969年在AT&amp;T的贝尔实验室开发。UNIX的商标权由国际开放标准组织（The Open Group）所拥有。UNIX操作系统是商业版，需要收费，价格比Microsoft Windows正版要贵一些。 2.Linux的概述：Linux是基于Unix的Linux是一种自由和开放源码的操作系统，存在着许多不同的Linux版本，但它们都使用了Linux内核。Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、台式计算机 诞生于1991 年10 月5 日。是由芬兰赫尔辛基大学学生Linus Torvalds和后来加入的众多爱好者共同开发完成 3.Linux的历史：Linux最初是由芬兰赫尔辛基大学学生Linus Torvalds由于自己不满意教学中使用的MINIX操作系统， 所以在1990年底由于个人爱好设计出了LINUX系统核心。后来发布于芬兰最大的ftp服务器上，用户可以免费下载，所以它的周边的程序越来越多，Linux本身也逐渐发展壮大起来，之后Linux在不到三年的时间里成为了一个功能完善，稳定可靠的操作系统. 4.Linux系统的应用：服务器系统Web应用服务器、数据库服务器、接口服务器、DNS、FTP等等；嵌入式系统路由器、防火墙、手机、PDA、IP 分享器、交换器、家电用品的微电脑控制器等等，高性能运算、计算密集型应用Linux有强大的运算能力。桌面应用系统移动手持系统 5.Linux的版本Linux的版本分为两种：内核版本和发行版本；内核版本是指在Linus领导下的内核小组开发维护的系统内核的版本号 ；发行版本是一些组织和公司根据自己发行版的不同而自定的 ； 6.Linux的主流版本 二.Linux的安装：1.虚拟机安装：1.什么是虚拟机虚拟机：一台虚拟的电脑. 虚拟机软件: * VmWare :收费的. * VirtualBox :免费的. 2.安装1.安装VmWare 参考《虚拟软件vmware安装.doc》 2.CentOS的安装 参考《CentOS6详细安装文档.doc》 3Linux的目录结构： root管理员的home目录root其他用户的home目录home目录中 三.Linux的常用命令1.切换目录命令cd：使用 cd app 切换到app目录 cd .. 切换到上一层目录 cd / 切换到系统根目录 cd ~ 切换到用户主目录 cd - 切换到上一个所在目录 2.列出文件列表：ls ll dir(*)ls(list)是一个非常有用的命令，用来显示当前目录下的内容。配合参数的使用，能以不同的方式显示目录内容。 格式：ls[参数] [路径或文件名] 常用：在linux中以 . 开头的文件都是隐藏的文件 * ls * ls -a 显示所有文件或目录（包含隐藏的文件） * ls -l 缩写成ll 3.创建目录和移除目录：mkdir rmdirmkdir(make directory)命令可用来创建子目录。 mkdir app  在当前目录下创建app目录 mkdir –p app2/test  级联创建aap2以及test目 rmdir(remove directory)命令可用来删除“空”的子目录： rmdir app  删除app目录 4.浏览文件【cat、more、less、tail】 1.cat用于显示文件的内容。 格式：cat[参数]&lt;文件名&gt; * cat yum.conf 2.more一般用于要显示的内容会超过一个画面长度的情况。按空格键显示下一个画面。 回车显示下一行内容。 按 q 键退出查看。 * more yum.conf * 空格显示下一页数据 回车显示下一行的数据 3.less用法和more类似，不同的是less可以通过PgUp、PgDn键来控制。 * less yum.conf * PgUp 和 PgDn 进行上下翻页. 4.tail命令是在实际使用过程中使用非常多的一个命令，它的功能是：用于显示文件后几行的内容。 用法: tail -10 /etc/passwd  查看后10行数据 tail -f catalina.log  动态查看日志(*****) 5.ctrl+c 结束查看 5.文件操作：1.【rm】rm 删除文件 用法：rm [选项]... 文件... rm a.txt  删除a.txt文件 删除需要用户确认，y/n rm 删除不询问 rm -f a.txt  不询问，直接删除 rm 删除目录 rm -r a  递归删除 不询问递归删除（慎用） rm -rf a  不询问递归删除 rm -rf *  删除所有文件 rm -rf /*  自杀 2.【cp、mv】cp(copy)命令可以将文件从一处复制到另一处。一般在使用cp命令时将一个文件复制成另一个文件或复制到某目录时，需要指定源文件名与目标文件名或目录。 cp a.txt b.txt  将a.txt复制为b.txt文件 cp a.txt ../  将a.txt文件复制到上一层目录中 mv 移动或者重命名 mv a.txt ../  将a.txt文件移动到上一层目录中 mv a.txt b.txt  将a.txt文件重命名为b.txt 3.【tar】命令:(* 打包或解压)tar命令位于/bin目录下，它能够将用户所指定的文件或目录打包成一个文件，但不做压缩。一般Linux上常用的压缩方式是选用tar将许多文件打包成一个文件，再以gzip压缩命令压缩成xxx.tar.gz(或称为xxx.tgz)的文件。 常用参数： -c：创建一个新tar文件 -v：显示运行过程的信息 -f：指定文件名 -z：调用gzip压缩命令进行压缩 -t：查看压缩文件的内容 -x：解开tar文件 打包： tar –cvf xxx.tar ./* 打包并且压缩： tar –zcvf xxx.tar.gz ./* 解压 tar –xvf xxx.tar tar -xvf xxx.tar.gz -C /usr/aaa 4.【grep】命令查找符合条件的字符串。 用法: grep [选项]... PATTERN [FILE]... 示例： grep lang anaconda-ks.cfg 在文件中查找lang grep lang anaconda-ks.cfg –color 高亮显示 6.其他常用命令1.【pwd】 显示当前所在目录 2.【touch】 创建一个空文件 * touch a.txt 3.【ll -h】 友好显示文件大小 4.【wget】 下载资料 * wget http://nginx.org/download/nginx-1.9.12.tar.gz 四.Vi和Vim编辑器1.Vim编辑器：在Linux下一般使用vi编辑器来编辑文件。 vi既可以查看文件也可以编辑文件。 三种模式：命令行、插入、底行模式。 切换到命令行模式：按Esc键； 切换到插入模式：按 i 、o、a键； i 在当前位置生前插入 I 在当前行首插入 a 在当前位置后插入 A 在当前行尾插入 o 在当前行之后插入一行 O 在当前行之前插入一行 切换到底行模式：按 :（冒号）； 更多详细用法，查询文档《Vim命令合集.docx》和《vi使用方法详细介绍.docx》 打开文件：vim file 退出：esc :q 修改文件：输入i进入插入模式 保存并退出：esc:wq 不保存退出：esc:q! 3中进入插入模式： i:在当前的光标所在处插入 o:在当前光标所在的行的下一行插入 a:在光标所在的下一个字符插入 快捷键： dd – 快速删除一行 R – 替换 2.重定向输出&gt;和&gt;&gt;&gt; 重定向输出，覆盖原有内容； &gt;&gt; 重定向输出，又追加功能； 示例： cat /etc/passwd &gt; a.txt 将输出定向到a.txt中 cat /etc/passwd &gt;&gt; a.txt 输出并且追加 ifconfig &gt; ifconfig.txt 3.管道 |管道是Linux命令中重要的一个概念，其作用是将一个命令的输出用作另一个命令的输入。 示例 ls --help | more 分页查询帮助信息 ps –ef | grep java 查询名称中包含java的进程 ifconfig | more cat index.html | more ps –ef | grep aio 4.&amp;&amp;命令执行控制：命令之间使用 &amp;&amp; 连接，实现逻辑与的功能。 只有在 &amp;&amp; 左边的命令返回真（命令返回值 $? == 0），&amp;&amp; 右边的命令才会被执行。 只要有一个命令返回假（命令返回值 $? == 1），后面的命令就不会被执行。 mkdir test &amp;&amp; cd test 5.网络通讯命令ifconfig 显示或设置网络设备。 ifconfig 显示网络设备 ifconfig eth0 up 启用eth0网卡 ifconfig eth0 down 停用eth0网卡 ping 探测网络是否通畅。 ping 192.168.0.1 netstat 查看网络端口。 netstat -an | grep 3306 查询3306端口占用情况 6.系统管理命令date 显示或设置系统时间 date 显示当前系统时间 date -s “2014-01-01 10:10:10“ 设置系统时间 df 显示磁盘信息 df –h 友好显示大小 free 显示内存状态 free –m 以mb单位显示内存组昂头 top 显示，管理执行中的程序 clear 清屏幕 ps 正在运行的某个进程的状态 ps –ef 查看所有进程 ps –ef | grep ssh 查找某一进程 kill 杀掉某一进程 kill 2868 杀掉2868编号的进程 kill -9 2868 强制杀死进程 du 显示目录或文件的大小。 du –h 显示当前目录的大小 who 显示目前登入系统的用户信息。 hostname 查看当前主机名 修改：vi /etc/sysconfig/network uname 显示系统信息。 uname -a 显示本机详细信息。 依次为：内核名称(类别)，主机名，内核版本号，内核版本，内核编译日期，硬件名，处理器类型，硬件平台类型，操作系统名称 五.Linux的用户和组1.用户的管理useradd 添加一个用户 useradd test 添加test用户 useradd test -d /home/t1 指定用户home目录 passwd 设置、修改密码 passwd test 为test用户设置密码 切换登录： ssh -l test -p 22 192.168.19.128 su – 用户名 userdel 删除一个用户 userdel test 删除test用户(不会删除home目录) userdel –r test 删除用户以及home目录 2.组管理：当在创建一个新用户user时，若没有指定他所属于的组，就建立一个和该用户同名的私有组 创建用户时也可以指定所在组 groupadd 创建组 groupadd public 创建一个名为public的组 useradd u1 –g public 创建用户指定组 groupdel 删除组，如果该组有用户成员，必须先删除用户才能删除组。 groupdel public 3.id，su命令【id命令】 功能：查看一个用户的UID和GID 用法：id [选项]... [用户名] 直接使用id 直接使用id 用户名 【su命令】 功能：切换用户。 用法：su [选项]... [-] [用户 [参数]... ] 示例： su - u1 切换到u1用户，并且将环境也切换到u1用户的环境（推荐使用） 【账户文件】 /etc/passwd 用户文件 /etc/shadow 密码文件 /etc/group 组信息文件 【用户文件】 root:x:0:0:root:/root:/bin/bash 账号名称： 在系统中是唯一的 用户密码： 此字段存放加密口令 用户标识码(User ID)： 系统内部用它来标示用户 组标识码(Group ID)： 系统内部用它来标识用户属性 用户相关信息： 例如用户全名等 用户目录： 用户登录系统后所进入的目录 用户环境: 用户工作的环境 【密码文件】 shadow文件中每条记录用冒号间隔的9个字段组成. 用户名：用户登录到系统时使用的名字，而且是惟一的 口令： 存放加密的口令 最后一次修改时间: 标识从某一时刻起到用户最后一次修改时间 最大时间间隔: 口令保持有效的最大天数，即多少天后必须修改口令 最小时间间隔： 再次修改口令之间的最小天数 警告时间：从系统开始警告到口令正式失效的天数 不活动时间： 口令过期少天后，该账号被禁用 失效时间：指示口令失效的绝对天数(从1970年1月1日开始计算) 标志：未使用 【组文件】 root:x:0: 组名：用户所属组 组口令：一般不用 GID：组ID 用户列表：属于该组的所有用户 六.Linux的权限命令1.文件权限 2.Linux三种文件类型：1.普通文件： 包括文本文件、数据文件、可执行的二进制程序文件等。 2.目录文件： Linux系统把目录看成是一种特殊的文件，利用它构成文件系统的树型结构。 3.设备文件： Linux系统把每一个设备都看成是一个文件 3.文件类型标识普通文件（-） 目录（d） 符号链接（l） 进入etc可以查看，相当于快捷方式 字符设备文件（c） 块设备文件（s） 套接字（s） 命名管道（p） 4.文件权限管理：chmod 变更文件或目录的权限。 chmod 755 a.txt chmod u=rwx,g=rx,o=rx a.txt chmod 000 a.txt / chmod 777 a.txt chown 变更文件或目录改文件所属用户和组 chown u1:public a.txt ：变更当前的目录或文件的所属用户和组 chown -R u1:public dir ：变更目录中的所有的子目录及文件的所属用户和组]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>linux 基础篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring入门篇(IOC[配置文件方式]/spring整合基础web)]]></title>
    <url>%2F2018%2F12%2F23%2Fspring1%2F</url>
    <content type="text"><![CDATA[Spring框架的学习路线 1. Spring入门篇：Spring的IOC容器之XML的方式，Spring框架与Web项目整合 2. Spring进阶：Spring的IOC容器之注解的方式，Spring的AOP技术 3. Spring高级：Spring的事务管理、Spring框架的JDBC模板 本篇内容概述 一. Spring框架的概述 二. SpringIOC的快速入门 三. IoC容器XML的方式以及依赖注入(DI) 四. 在web项目中集成Spring 一. Spring框架的概述1.什么是Spring框架* Spring是一个开源框架 * Spring是于2003 年兴起的一个轻量级的Java开发框架，由Rod Johnson在其著作Expert One-On-One J2EE Development and Design中阐述的部分理念和原型衍生而来。 * 它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。 * Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以 从Spring中受益。 * Spring的核心是控制反转（IoC）和面向切面（AOP）。简单来说，Spring是一个分层的JavaSE/EEfull-stack(一站式) 轻量级开源框架。 * EE开发分成三层结构 * WEB层 -- Spring MVC * 业务层 -- Bean管理:(IOC) * 持久层 -- Spring的JDBC模板.ORM模板用于整合其他的持久层框架 2.Spring框架的特点1. 为什么要学习Spring的框架 * 方便解耦，简化开发 * Spring就是一个大工厂，可以将所有对象创建和依赖关系维护，交给Spring管理 * AOP编程的支持 * Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能 * 声明式事务的支持 * 只需要通过配置就可以完成对事务的管理，而无需手动编程 * 方便程序的测试 * Spring对Junit4支持，可以通过注解方便的测试Spring程序 * 方便集成各种优秀框架 * Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts2、Hibernate、MyBatis、Quartz等）的直接支持 * 降低JavaEE API的使用难度 * Spring 对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低 2. Spring框架的版本 * Spring3.x和Spring4.x的版本 二.Spring IOC（控制反转）1.Spring框架的IOC核心功能快速入门1. 什么是IOC的功能？ * IoC -- Inverse of Control，控制反转，将对象的创建权反转给Spring！！ * 使用IOC可以解决的程序耦合性高的问题！！ 2. 步骤一：下载Spring框架的开发包 * 官网：http://spring.io/ * 下载地址：http://repo.springsource.org/libs-release-local/org/springframework/spring解压:(Spring目录结构:) * docs -- API和开发规范 * libs -- jar包和源码 * schema -- 约束 3. 步骤二：创建JavaWEB项目，引入Spring的开发包 * 引入Spring框架IOC核心功能需要的具体的jar包 * Spring框架的IOC的功能，那么根据Spring框架的体系结构图能看到，只需要引入如下的jar包 * Beans * Core * Context * Expression Language * Spring框架也需要引入日志相关的jar包 * 在spring-framework-3.0.2.RELEASE-dependencies/org.apache.commons/com.springsource.org.apache.commons.logging/1.1.1 * com.springsource.org.apache.commons.logging-1.1.1.jar * 还需要引入log4j的jar包 spring-framework-3.0.2.RELEASE-dependencies\org.apache.log4j\com.springsource.org.apache.log4j\1.2.15 * com.springsource.org.apache.log4j-1.2.15.jar 4. 步骤三：创建对应的包结构，编写Java的类，要注意：以后使用Spring框架做开发，都需要来编写接口与实现类！！ * com.itcast.demo1 * UserService -- 接口 * UserServiceImpl -- 具体的实现类 5. 步骤四：想把UserServiceImpl实现类的创建交给Spring框架来管理，需要创建Spring框架的配置文件，完成配置 * 在src目录下创建applicationContext.xml的配置文件，名称是可以任意的，但是一般都会使用默认名称！！ * 引入spring的约束，需要先找到具体的约束头信息！！ * spring-framework-3.2.0.RELEASE\docs\spring-framework-reference\html\xsd-config.html * 具体的约束如下： &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;/beans&gt; * 完成UserService的配置 &lt;!-- Spring的快速入门 --&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.itcast.demo1.UserServiceImpl&quot;/&gt; 6. 步骤五：编写测试程序，采用Spring框架的工厂方式来获取到UserService接口的具体实现类！！ public void demo2(){ // 使用Spring的工厂: ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); // 通过工厂获得类: UserService userService = (UserService) applicationContext.getBean(&quot;userService&quot;); userService.sayHello(); } 2.Spring框架中的工厂（了解）1. ApplicationContext接口 * 使用ApplicationContext工厂的接口，使用该接口可以获取到具体的Bean对象 * 该接口下有两个具体的实现类 * ClassPathXmlApplicationContext -- 加载类路径下的Spring配置文件 * FileSystemXmlApplicationContext -- 加载本地磁盘下的Spring配置文件 2. BeanFactory工厂（是Spring框架早期的创建Bean对象的工厂接口） * 使用BeanFactory接口也可以获取到Bean对象 public void run(){ BeanFactory factory = new XmlBeanFactory(new ClassPathResource(&quot;applicationContext.xml&quot;)); UserService us = (UserService) factory.getBean(&quot;us&quot;); us.sayHello(); } * BeanFactory和ApplicationContext的区别 * BeanFactory -- BeanFactory采取延迟加载，第一次getBean时才会初始化Bean * ApplicationContext -- 在加载applicationContext.xml时候就会创建具体的Bean对象的实例，还提供了一些其他的功能 * 事件传递 * Bean自动装配 * 各种不同应用层的Context实现 3.配置Spring框架编写XML的提示1. 步骤一：先复制， http://www.springframework.org/schema/beans/spring-beans.xsd 2. 步骤二：搜索XML Catalog，点击Add按钮 3. 步骤三：先选择Location的schema的约束地址 * E:\class\2016\JavaEE28\day35_Spring框架第一天\资料\spring-framework-4.2.4.RELEASE-schema\beans\spring-beans-4.2.xsd 4. 步骤四：注意：Key type要选择：Schema location 5. 步骤五：Key把http://www.springframework.org/schema/beans/spring-beans.xsd复制上 三.Spring框架的Bean管理的配置文件方式1.Spring框架中标签的配置1. id属性和name属性的区别 * id -- Bean起个名字，在约束中采用ID的约束，唯一 * 取值要求：必须以字母开始，可以使用字母、数字、连字符、下划线、句话、冒号 id:不能出现特殊字符 * name -- Bean起个名字，没有采用ID的约束（了解） * 取值要求：name:出现特殊字符.如果&lt;bean&gt;没有id的话 , name可以当做id使用 * Spring框架在整合Struts1的框架的时候，Struts1的框架的访问路径是以/开头的，例如：/bookAction 2. class属性 -- Bean对象的全路径 3. scope属性 -- scope属性代表Bean的作用范围 * singleton -- 单例（默认值） * prototype -- 多例，在Spring框架整合Struts2框架的时候，Action类也需要交给Spring做管理，配置把Action类配置成多例！！ * request -- 应用在Web项目中,每次HTTP请求都会创建一个新的Bean * session -- 应用在Web项目中,同一个HTTP Session 共享一个Bean * globalsession -- 应用在Web项目中,多服务器间的session 4. Bean对象的创建和销毁的两个属性配置（了解） * 说明：Spring初始化bean或销毁bean时，有时需要作一些处理工作，因此spring可以在创建和拆卸bean的时候调用bean的两个生命周期方法 * init-method -- 当bean被载入到容器的时候调用init-method属性指定的方法 * destroy-method -- 当bean从容器中删除的时候调用destroy-method属性指定的方法 * 想查看destroy-method的效果，有如下条件 * scope= singleton有效 * web容器中会自动调用，但是main函数或测试用例需要手动调用（需要使用ClassPathXmlApplicationContext的close()方法） 2.依赖注入（DI）1. IOC和DI的概念 * IOC -- Inverse of Control，控制反转，将对象的创建权反转给Spring！！ * DI -- Dependency Injection，依赖注入，在Spring框架负责创建Bean对象时，动态的将依赖对象注入到Bean组件中！！ 2. DI（依赖注入） * 例如：如果UserServiceImpl的实现类中有一个属性，那么使用Spring框架的IOC功能时，可以通过依赖注入把该属性的值传入进来！！ * 具体的配置如下 &lt;bean id=&quot;us&quot; class=&quot;com.itheima.demo1.UserServiceImpl&quot;&gt; &lt;property name=&quot;uname&quot; value=&quot;小风&quot;/&gt; &lt;/bean&gt; 3.Spring框架的属性注入1. 对于类成员变量，常用的注入方式有两种 * 构造函数注入 * 属性setter方法注入 2. 在Spring框架中提供了前两种的属性注入的方式 1. 构造方法的注入方式，两步 * 编写Java的类，提供构造方法 public class Car { private String name; private double money; public Car(String name, double money) { this.name = name; this.money = money; } @Override public String toString() { return &quot;Car [name=&quot; + name + &quot;, money=&quot; + money + &quot;]&quot;; } } * 编写配置文件 &lt;bean id=&quot;car&quot; class=&quot;com.itheima.demo4.Car&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;大奔&quot;/&gt; &lt;constructor-arg name=&quot;money&quot; value=&quot;100&quot;/&gt; &lt;/bean&gt; 2. 属性的setter方法的注入方式 * 编写Java的类，提供属性和对应的set方法即可 * 编写配置文件 3. 如果Java类的属性是另一个Java的类，那么需要怎么来注入值呢？ * &lt;property name=&quot;name&quot; rel=&quot;具体的Bean的ID或者name的值&quot;/&gt; * 例如： &lt;bean id=&quot;person&quot; class=&quot;com.itheima.demo4.Person&quot;&gt; &lt;property name=&quot;pname&quot; value=&quot;美美&quot;/&gt; &lt;property name=&quot;car2&quot; ref=&quot;car2&quot;/&gt; &lt;/bean&gt; 4.Spring的2.5版本中提供了一种:p名称空间的注入（了解）1. 步骤一：需要先引入 p 名称空间 * 在schema的名称空间中加入该行：xmlns:p=&quot;http://www.springframework.org/schema/p&quot; 2. 步骤二：使用p名称空间的语法 * p:属性名 = &quot;&quot; * p:属性名-ref = &quot;&quot; 3. 步骤三：测试 * &lt;bean id=&quot;person&quot; class=&quot;com.itheima.demo4.Person&quot; p:pname=&quot;老王&quot; p:car2-ref=&quot;car2&quot;/&gt; 5.Spring的3.0提供了一种:SpEL注入方式（了解）1. SpEL：Spring Expression Language是Spring的表达式语言，有一些自己的语法 2. 语法 * #{SpEL} 3. 例如如下的代码 &lt;!-- SpEL的方式 --&gt; &lt;bean id=&quot;person&quot; class=&quot;com.itheima.demo4.Person&quot;&gt; &lt;property name=&quot;pname&quot; value=&quot;#{&apos;小风&apos;}&quot;/&gt; &lt;property name=&quot;car2&quot; value=&quot;#{car2}&quot;/&gt; &lt;/bean&gt; 4. 还支持调用类中的属性或者方法 * 定义类和方法，例如 public class CarInfo { public String getCarname(){ return &quot;奇瑞QQ&quot;; } } 6.数组，集合(List,Set,Map)，Properties等的注入1. 如果是数组或者List集合，注入配置文件的方式是一样的 &lt;bean id=&quot;collectionBean&quot; class=&quot;com.itheima.demo5.CollectionBean&quot;&gt; &lt;property name=&quot;arrs&quot;&gt; &lt;list&gt; &lt;value&gt;美美&lt;/value&gt; &lt;value&gt;小风&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 2. 如果是Set集合，注入的配置文件方式如下： &lt;property name=&quot;sets&quot;&gt; &lt;set&gt; &lt;value&gt;哈哈&lt;/value&gt; &lt;value&gt;呵呵&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; 3. 如果是Map集合，注入的配置方式如下： &lt;property name=&quot;map&quot;&gt; &lt;map&gt; &lt;entry key=&quot;老王2&quot; value=&quot;38&quot;/&gt; &lt;entry key=&quot;凤姐&quot; value=&quot;38&quot;/&gt; &lt;entry key=&quot;如花&quot; value=&quot;29&quot;/&gt; &lt;/map&gt; &lt;/property&gt; 4. 如果是properties属性文件的方式，注入的配置如下： &lt;property name=&quot;pro&quot;&gt; &lt;props&gt; &lt;prop key=&quot;uname&quot;&gt;root&lt;/prop&gt; &lt;prop key=&quot;pass&quot;&gt;123&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; 7.Spring框架的配置文件分开管理（了解）例如：在src的目录下又多创建了一个配置文件，现在是两个核心的配置文件，那么加载这两个配置文件的方式有两种！ * 主配置文件中包含其他的配置文件: &lt;import resource=&quot;applicationContext2.xml&quot;/&gt; * 工厂创建的时候直接加载多个配置文件: ApplicationContext applicationContext = new ClassPathXmlApplicationContext( &quot;applicationContext.xml&quot;,&quot;applicationContext2.xml&quot;); 四.Spring框架整合基础WEB （不是最终的整合）1. 创建JavaWEB项目，引入Spring的开发包。编写具体的类和方法。 * 环境搭建好后，启动服务器来测试项目，发送每访问一次都会加载一次配置文件，这样效率会非常非常慢！！ 2. 解决上面的问题 * 将工厂创建好了以后放入到ServletContext域中.使用工厂的时候,从ServletContext中获得. * ServletContextListener:用来监听ServletContext对象的创建和销毁的监听器. * 当ServletContext对象创建的时候:创建工厂 , 将工厂存入到ServletContext 3. Spring整合Web项目 * 引入spring-web-4.2.4.RELEASE.jar包 * 配置监听器 &lt;!-- 配置Spring的核心监听器: --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; 4. 修改servlet的代码 * 从ServletContext中获得工厂 * 具体代码如下 ServletContext servletContext = ServletActionContext.getServletContext(); // 需要使用WEB的工厂的方式 WebApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(servletContext); CustomerService cs = (CustomerService) context.getBean(&quot;customerService&quot;); cs.save();]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>spring入门篇</tag>
        <tag>spring IOC（控制反转[配置文件方式]）</tag>
        <tag>spring DI（依赖注入）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[struts2完善篇(OGNL表达式/值栈/特殊符号[$,#,%])]]></title>
    <url>%2F2018%2F12%2F22%2Fstruts2-3%2F</url>
    <content type="text"><![CDATA[Struts2的学习路线 1.Struts2的入门篇：主要是学习Struts2的开发流程（Struts2的开发流程、常见的配置、Action类的编写） 2.Struts2的进阶篇: Struts2的Servlet的API、参数封装和拦截器 3.Struts2的完善篇: Struts2的值栈和OGNL表达式 一.技术分析之OGNL表达式1.OGNL表达式概述1. OGNL是Object Graphic Navigation Language（对象图导航语言）的缩写 * 所谓对象图，即以任意一个对象为根，通过OGNL可以访问与这个对象关联的其它对象 * 通过它简单一致的表达式语法，可以存取对象的任意属性，调用对象的方法，遍历整个对象的结构图，实现字段类型转化等功能。它使用相同的表达式去存取对象的属性 2. Struts2框架使用OGNL作为默认的表达式语言 * OGNL是一种比EL强大很多倍的语言 * xwork提供 OGNL表达式 * ognl-3.0.5.jar 3. OGNL 提供五大类功能 * 支持对象方法调用 * 支持类静态的方法调用和值访问 * 访问OGNL上下文（OGNL context）和ActionContext * 支持赋值操作和表达式串联 * 操作集合对象 4. 测试的代码 // 访问对象的方法 @Test public void run1() throws OgnlException{ OgnlContext context = new OgnlContext(); // 获取对象的方法 Object obj = Ognl.getValue(&quot;&apos;helloworld&apos;.length()&quot;, context, context.getRoot()); System.out.println(obj); } // 获取OGNL上下文件的对象 @Test public void run3() throws OgnlException{ OgnlContext context = new OgnlContext(); context.put(&quot;name&quot;, &quot;美美&quot;); // 获取对象的方法 Object obj = Ognl.getValue(&quot;#name&quot;, context, context.getRoot()); System.out.println(obj); } // 从root栈获取值 @Test public void demo3() throws OgnlException{ OgnlContext context = new OgnlContext(); Customer c = new Customer(); c.setCust_name(&quot;haha&quot;); context.setRoot(c); String name = (String) Ognl.getValue(&quot;cust_name&quot;, context, context.getRoot()); System.out.println(name); } 2.技术分析之在Struts2框架中使用OGNL表达式1. Struts2引入了OGNL表达式，主要是在JSP页面中获取值栈中的值 2. 具体在Struts2中怎么使用呢？如下步骤 * 需要先引入Struts2的标签库 &gt; &lt;%@ taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot; %&gt; * 使用Struts2提供的标签中的标签 &gt; &lt;s:property value=&quot;OGNL表达式&quot;/&gt; 3. 在JSP页面使用OGNL表达式 * 访问对象方法 &lt;s:property value=&quot;&apos;hello&apos;.length()&quot;/&gt; 二.技术分析之 值栈1.值栈的概述问题一：什么是值栈？ * 值栈就相当于Struts2框架的数据的中转站，向值栈存入一些数据。从值栈中获取到数据。 * ValueStack 是 struts2 提供一个接口，实现类 OgnlValueStack ---- 值栈对象 （OGNL是从值栈中获取数据的 ） * Action是多例的，有一起请求，创建Action实例，创建一个ActionContext对象，代表的是Action的上下文对象，还会创建一个ValueStack对象。 * 每个Action实例都有一个ValueStack对象 （一个请求 对应 一个ValueStack对象 ） * 在其中保存当前Action 对象和其他相关对象 * Struts 框架把 ValueStack 对象保存在名为 “struts.valueStack” 的请求属性中,request中 （值栈对象 是 request一个属性） * ValueStack vs = (ValueStack)request.getAttribute(&quot;struts.valueStack&quot;); 2.技术分析之值栈的内部结构问题二 ： 值栈的内部结构 ？ * 值栈由两部分组成 &gt; root -- Struts把动作和相关对象压入 ObjectStack 中--List &gt; context -- Struts把各种各样的映射关系(一些 Map 类型的对象) 压入 ContextMap 中 * Struts会默认把下面这些映射压入ContextMap（context）中 * 注意：request代表的是Map集合的key值，value的值其实也是一个Map集合。 &gt; parameters: 该 Map 中包含当前请求的请求参数 ?name=xxx&amp;password=123 &gt; request: 该 Map 中包含当前 request 对象中的所有属性 &gt; session: 该 Map 中包含当前 session 对象中的所有属性 &gt; application:该 Map 中包含当前 application 对象中的所有属性 &gt; attr: 该 Map 按如下顺序来检索某个属性: request, session, application * ValueStack中 存在root属性 (CompoundRoot) 、 context 属性 （OgnlContext ） &gt; CompoundRoot 就是ArrayList &gt; OgnlContext 就是 Map * context 对应Map 引入 root对象 &gt; context中还存在 request、 session、application、 attr、 parameters 对象引用 &gt; OGNL表达式访问值栈中的数据 * 访问root中数据时 不需要 # * 访问 request、 session、application、 attr、 parameters 对象数据 必须写 # &gt; 操作值栈 默认指 操作 root 元素 3.技术分析之值栈的创建和ActionContext对象的关系问题三 ： 值栈对象的创建，ValueStack 和 ActionContext 是什么关系？ * 值栈对象是请求时创建的 * ActionContext是绑定到当前的线程上，那么在每个拦截器或者Action中获取到的ActionContext是同一个。 * ActionContext中存在一个Map集合，该Map集合和ValueStack的context是同一个地址。 * ActionContext中可以获取到ValueStack的引用，以后再开发，使用ActionContext来获取到值栈对象 4.技术分析之获取到值栈的对象问题四 ： 如何获得值栈对象 * 获得值栈对象 有三种方法 * ValueStack vs1 = (ValueStack) ServletActionContext.getRequest().getAttribute(&quot;struts.valueStack&quot;); * ValueStack vs2 = (ValueStack) ServletActionContext.getRequest().getAttribute(ServletActionContext.STRUTS_VALUESTACK_KEY); * ValueStack vs3 = ActionContext.getContext().getValueStack(); 5.技术分析之向值栈中保存数据问题五： 向值栈保存数据 （主要针对root栈） &gt; valueStack.push(Object obj); * push方法的底层调用root对象的push方法（把元素添加到0位置） &gt; valueStack.set(String key, Object obj); * 源码获取map集合（map有可能是已经存在的，有可能是新创建的），把map集合push到栈顶，再把数据存入到map集合中。 &gt; 在jsp中 通过 &lt;s:debug /&gt; 查看值栈的内容 6.技术分析之从值栈中获取值问题六： 在JSP中获取值栈的数据 * 总结几个小问题： &gt; 访问root中数据 不需要# &gt; 访问context其它对象数据 加 # &gt; 如果向root中存入对象的话，优先使用push方法。 &gt; 如果向root中存入集合的话，优先要使用set方法。 * 在OgnlContext中获取数据 &gt; 在Action中向域对象中存入值 &gt; request:&lt;s:property value=&quot;#request.username&quot;/&gt; &gt; session:&lt;s:property value=&quot;#session.username&quot;/&gt; &gt; application:&lt;s:property value=&quot;#application.username&quot;/&gt; &gt; attr:&lt;s:property value=&quot;#attr.username&quot;/&gt; &gt; parameters:&lt;s:property value=&quot;#parameters.cid&quot;/&gt; 代码如下 &lt;!-- // vs.push(&quot;美美&quot;); // 获取到栈顶的值 &lt;s:property value=&quot;[0].top&quot;/&gt; --&gt; &lt;!-- // 栈顶是map集合，通过key获取值 vs.set(&quot;msg&quot;, &quot;小凤&quot;); &lt;s:property value=&quot;[0].top.msg&quot;/&gt; --&gt; &lt;!-- vs.push(user); // 栈顶放user对象 &lt;s:property value=&quot;[0].top.username&quot;/&gt; &lt;s:property value=&quot;[0].top.password&quot;/&gt; // [0].top 关键字是可以省略的 findValue() &lt;s:property value=&quot;username&quot;/&gt; --&gt; &lt;!-- vs.set(&quot;user&quot;, user); &lt;s:property value=&quot;[0].top.user.username&quot;/&gt; &lt;s:property value=&quot;[0].top.user.password&quot;/&gt; // 省略关键字 &lt;s:property value=&quot;user.username&quot;/&gt; --&gt; &lt;!-- // 在ValueStack1Action提供了成员的属性 private User user = new User(&quot;小泽&quot;,&quot;456&quot;); public User getUser() { return user; } public void setUser(User user) { this.user = user; } User user = new User(&quot;小苍&quot;,&quot;123&quot;); vs.set(&quot;user&quot;, user); // 从栈顶开始查找，找user的属性，显示名称 返回的小苍 &lt;s:property value=&quot;user.username&quot;/&gt; // [1].top获取ValueStack1Action [1].top.user返回user对象 [1].top.user.username获取对象的属性名称 &lt;s:property value=&quot;[1].top.user.username&quot;/&gt; --&gt; &lt;!-- 栈顶是list集合 vs.push(ulist); &lt;s:property value=&quot;[0].top[0].username&quot;/&gt; &lt;s:property value=&quot;[0].top[1].username&quot;/&gt; --&gt; &lt;!-- vs.set(&quot;ulist&quot;, ulist); &lt;s:property value=&quot;ulist[0].username&quot;/&gt; --&gt; &lt;!-- 迭代的标签 属性 * value 要迭代的集合，需要从值栈中获取 * var 迭代过程中，遍历的对象 * var编写上，把迭代产生的对象默认压入到context栈中，从context栈取值，加#号 * var不编写，默认把迭代产生的对象压入到root栈中 for(User user:ulist){} // 编写var的属性 &lt;s:iterator value=&quot;ulist&quot; var=&quot;u&quot;&gt; &lt;s:property value=&quot;#u.username&quot;/&gt; &lt;s:property value=&quot;#u.password&quot;/&gt; &lt;/s:iterator&gt; // 没有编写var关键字 &lt;s:iterator value=&quot;ulist&quot;&gt; &lt;s:property value=&quot;username&quot;/&gt; &lt;s:property value=&quot;password&quot;/&gt; &lt;/s:iterator&gt; --&gt; &lt;!-- 从context栈中获取值，加#号 HttpServletRequest request = ServletActionContext.getRequest(); request.setAttribute(&quot;msg&quot;, &quot;美美&quot;); request.getSession().setAttribute(&quot;msg&quot;, &quot;小风&quot;); &lt;s:property value=&quot;#request.msg&quot;/&gt; &lt;s:property value=&quot;#session.msg&quot;/&gt; &lt;s:property value=&quot;#parameters.id&quot;/&gt; &lt;s:property value=&quot;#attr.msg&quot;/&gt; --&gt; &lt;!-- 在JSP页面上，查看值栈的内部结构 --&gt; &lt;s:debug&gt;&lt;/s:debug&gt; 7.技术分析之EL表达式也会获取到值栈中的数据问题七：为什么EL也能访问值栈中的数据？ * StrutsPreparedAndExecuteFilter的doFilter代码中 request = prepare.wrapRequest(request); &gt; 对Request对象进行了包装 ，StrutsRequestWrapper &gt; 增强了request的 getAttribute Object attribute = super.getAttribute(s); if (attribute == null) { attribute = stack.findValue(s); } &gt; 访问request范围的数据时，如果数据找不到，去值栈中找 &gt; request对象 具备访问值栈数据的能力 （查找root的数据） 三.总结OGNL表达式的特殊的符号1. # 符号的用法* 获得contextMap中的数据 &gt; &lt;s:property value=&quot;#request.name&quot;/&gt; &gt; &lt;s:property value=&quot;#session.name&quot;/&gt; &gt; &lt;s:property value=&quot;#application.name&quot;/&gt; &gt; &lt;s:property value=&quot;#attr.name&quot;/&gt; &gt; &lt;s:property value=&quot;#parameters.id&quot;/&gt; &gt; &lt;s:property value=&quot;#parameters.name&quot;/&gt; * 构建一个map集合 * 例如： * &lt;s:radio name=&quot;sex&quot; list=&quot;{&apos;男&apos;,&apos;女&apos;}&quot;&gt;&lt;/s:radio&gt; * &lt;s:radio name=&quot;sex&quot; list=&quot;#{&apos;0&apos;:&apos;男&apos;,&apos;1&apos;:&apos;女&apos;}&quot;&gt;&lt;/s:radio&gt; 2. % 符号的用法* 强制字符串解析成OGNL表达式。 &gt; 例如：在request域中存入值，然后在文本框（&lt;s:textfield&gt;）中取值，现在到value上。 &gt; &lt;s:textfield value=&quot;%{#request.msg}&quot;/&gt; * { }中值用&apos;&apos;引起来,此时不再是ognl表达式,而是普通的字符串 &gt; 例如：&lt;s:property value=&quot;%{&apos;#request.msg&apos;}&quot;/&gt; 3. $ 符号的用法* 在配置文件中可以使用OGNL表达式，例如：文件下载的配置文件。 &lt;action name=&quot;download1&quot; class=&quot;cn.itcast.demo2.DownloadAction&quot;&gt; &lt;result name=&quot;success&quot; type=&quot;stream&quot;&gt; &lt;param name=&quot;contentType&quot;&gt;${contentType}&lt;/param&gt; &lt;param name=&quot;contentDisposition&quot;&gt;attachment;filename=${downFilename}&lt;/param&gt; &lt;/result&gt; &lt;/action&gt;]]></content>
      <categories>
        <category>struts2</category>
      </categories>
      <tags>
        <tag>struts2</tag>
        <tag>struts2完善篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[struts2进阶篇(Servlet的API/参数封装/拦截器的定义使用)]]></title>
    <url>%2F2018%2F12%2F21%2Fstruts2-2%2F</url>
    <content type="text"><![CDATA[Struts2的学习路线 1.Struts2的入门篇：主要是学习Struts2的开发流程（Struts2的开发流程、常见的配置、Action类的编写） 2.Struts2的进阶篇: Struts2的Servlet的API、参数封装和拦截器 3.Struts2的完善篇: Struts2的值栈和OGNL表达式 一.技术分析之在Struts2框架中使用Servlet的API1. 在Action类中也可以获取到Servlet一些常用的API * 需求：提供JSP的表单页面的数据，在Action中使用Servlet的API接收到，然后保存到三个域对象中，最后再显示到JSP的页面上。 * 提供JSP注册的页面，演示下面这三种方式 &lt;h3&gt;注册页面&lt;/h3&gt; &lt;form action=&quot;${ pageContext.request.contextPath }/xxx.action&quot; method=&quot;post&quot;&gt; 姓名:&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br/&gt; 密码:&lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;注册&quot; /&gt; &lt;/form&gt; 2. 完全解耦合的方式 * 如果使用该种方式，Struts2框架中提供了一个类，ActionContext类，该类中提供一些方法，通过方法获取Servlet的API * 一些常用的方法如下 * static ActionContext getContext() -- 获取ActionContext对象实例 * java.util.Map&lt;java.lang.String,java.lang.Object&gt; getParameters() -- 获取请求参数，相当于request.getParameterMap(); * java.util.Map&lt;java.lang.String,java.lang.Object&gt; getSession() -- 获取的代表session域的Map集合，就相当于操作session域。 * java.util.Map&lt;java.lang.String,java.lang.Object&gt; getApplication() -- 获取代表application域的Map集合 * void put(java.lang.String key, java.lang.Object value) -- 注意：向request域中存入值。 3. 使用原生Servlet的API的方式 * Struts2框架提供了一个类，ServletActionContext，该类中提供了一些静态的方法 * 具体的方法如下 * getPageContext() * getRequest() * getResponse() * getServletContext() 二.技术分析之结果页面的跳转1. 结果页面存在两种方式 * 全局结果页面 &gt; 条件：如果&lt;package&gt;包中的一些action都返回success，并且返回的页面都是同一个JSP页面，这样就可以配置全局的结果页面。 &gt; 全局结果页面针对的当前的包中的所有的Action，但是如果局部还有结果页面，会优先局部的。使用的标签是 &lt;global-results&gt; &lt;result&gt;/demo3/suc.jsp&lt;/result&gt; &lt;/global-results&gt; * 局部结果页面 &lt;result&gt;/demo3/suc.jsp&lt;/result&gt; 2. 结果页面的类型 * 结果页面使用&lt;result&gt;标签进行配置，包含两个属性 &gt; name -- 逻辑视图的名称 &gt; type -- 跳转的类型，值一些，需要掌握一些常用的类型。常见的结果类型去struts-default.xml中查找。 * dispatcher -- 转发.type的默认值.Action---&gt;JSP * redirect -- 重定向. Action---&gt;JSP * chain -- 多个action之间跳转.从一个Action转发到另一个Action. Action---Action * redirectAction -- 多个action之间跳转.从一个Action重定向到另一个Action. Action---Action * stream -- 文件下载时候使用的 三.技术分析之Struts2框架的数据封装 1. 为什么要使用数据的封装呢？ * 作为MVC框架，必须要负责解析HTTP请求参数，并将其封装到Model对象中 * 封装数据为开发提供了很多方便 * Struts2框架提供了很强大的数据封装的功能，不再需要使用Servlet的API完成手动封装了！！ 2. Struts2中提供了两类数据封装的方式？ * 第一种方式：属性驱动 &gt; 提供对应属性的set方法进行数据的封装。 * 表单的哪些属性需要封装数据，那么在对应的Action类中提供该属性的set方法即可。 * 表单中的数据提交，最终找到Action类中的setXxx的方法，最后赋值给全局变量。 * 注意0：Struts2的框架采用的拦截器完成数据的封装。 * 注意1：这种方式不是特别好:因为属性特别多,提供特别多的set方法,而且还需要手动将数据存入到对象中. * 注意2：这种情况下，Action类就相当于一个JavaBean，就没有体现出MVC的思想，Action类又封装数据，又接收请求处理，耦合性较高。 &gt; 在页面上，使用OGNL表达式进行数据封装。 * 在页面中使用OGNL表达式进行数据的封装，就可以直接把属性封装到某一个JavaBean的对象中。 * 在页面中定义一个JavaBean，并且提供set方法：例如：private User user; * 页面中的编写发生了变化，需要使用OGNL的方式，表单中的写法：&lt;input type=&quot;text&quot; name=&quot;user.username&quot;&gt; * 注意：只提供一个set方法还不够，必须还需要提供user属性的get和set方法！！！ &gt; 先调用get方法，判断一下是否有user对象的实例对象，如果没有，调用set方法把拦截器创建的对象注入进来， * 第二种方式：模型驱动 &gt; 使用模型驱动的方式，也可以把表单中的数据直接封装到一个JavaBean的对象中，并且表单的写法和之前的写法没有区别！ &gt; 编写的页面不需要任何变化，正常编写name属性的值 &gt; 模型驱动的编写步骤： * 手动实例化JavaBean，即：private User user = new User(); * 必须实现ModelDriven&lt;T&gt;接口，实现getModel()的方法，在getModel()方法中返回user即可！！ 四.技术分析之Struts2把数据封装到集合中1. 封装复杂类型的参数（集合类型 Collection 、Map接口等） 2. 需求：页面中有可能想批量添加一些数据，那么现在就可以使用上述的技术了。把数据封装到集合中 3. 把数据封装到Collection中 * 因为Collection接口都会有下标值，所有页面的写法会有一些区别，注意： &gt; &lt;input type=&quot;text&quot; name=&quot;products[0].name&quot; /&gt; * 在Action中的写法，需要提供products的集合，并且提供get和set方法。 4. 把数据封装到Map中 * Map集合是键值对的形式，页面的写法 &gt; &lt;input type=&quot;text&quot; name=&quot;map[&apos;one&apos;].name&quot; /&gt; * Action中提供map集合，并且提供get和set方法 五.案例总结之Struts2的拦截器技术1. 拦截器的概述 * 拦截器就是AOP（Aspect-Oriented Programming）的一种实现。（AOP是指用于在某个方法或字段被访问之前，进行拦截然后在之前或之后加入某些操作。） * 过滤器:过滤从客服端发送到服务器端请求的 * 拦截器:拦截对目标Action中的某些方法进行拦截 * 拦截器不能拦截JSP * 拦截到Action中某些方法 2. 拦截器和过滤器的区别 1）拦截器是基于JAVA反射机制的，而过滤器是基于函数回调的 2）过滤器依赖于Servlet容器，而拦截器不依赖于Servlet容器 3）拦截器只能对Action请求起作用（Action中的方法），而过滤器可以对几乎所有的请求起作用（CSS JSP JS） * 拦截器 采用 责任链 模式 &gt; 在责任链模式里,很多对象由每一个对象对其下家的引用而连接起来形成一条链 &gt; 责任链每一个节点，都可以继续调用下一个节点，也可以阻止流程继续执行 * 在struts2 中可以定义很多个拦截器，将多个拦截器按照特定顺序 组成拦截器栈 （顺序调用 栈中的每一个拦截器 ） 3. Struts2的核心是拦截器，看一下Struts2的运行流程 六.案例总结之自定义拦截器和配置1. 编写拦截器，需要实现Interceptor接口，实现接口中的三个方法 protected String doIntercept(ActionInvocation invocation) throws Exception { // 获取session对象 User user = (User) ServletActionContext.getRequest().getSession().getAttribute(&quot;existUser&quot;); if(user == null){ // 说明，没有登录，后面就不会执行了 return &quot;login&quot;; } return invocation.invoke(); } 2. 需要在struts.xml中进行拦截器的配置，配置一共有两种方式 &lt;!-- 定义了拦截器 第一种方式 &lt;interceptors&gt; &lt;interceptor name=&quot;DemoInterceptor&quot; class=&quot;com.itheima.interceptor.DemoInterceptor&quot;/&gt; &lt;/interceptors&gt; --&gt; &lt;!-- 第二种方式：定义拦截器栈 --&gt; &lt;interceptors&gt; &lt;interceptor name=&quot;DemoInterceptor&quot; class=&quot;com.itheima.interceptor.DemoInterceptor&quot;/&gt; &lt;!-- 定义拦截器栈 --&gt; &lt;interceptor-stack name=&quot;myStack&quot;&gt; &lt;interceptor-ref name=&quot;DemoInterceptor&quot;/&gt; &lt;interceptor-ref name=&quot;defaultStack&quot;/&gt; &lt;/interceptor-stack&gt; &lt;/interceptors&gt; &lt;action name=&quot;userAction&quot; class=&quot;com.itheima.demo3.UserAction&quot;&gt; &lt;!-- 只要是引用自己的拦截器，默认栈的拦截器就不执行了，必须要手动引入默认栈 &lt;interceptor-ref name=&quot;DemoInterceptor&quot;/&gt; &lt;interceptor-ref name=&quot;defaultStack&quot;/&gt; --&gt; &lt;!-- 引入拦截器栈就OK --&gt; &lt;interceptor-ref name=&quot;myStack&quot;/&gt; &lt;/action&gt;]]></content>
      <categories>
        <category>struts2</category>
      </categories>
      <tags>
        <tag>struts2</tag>
        <tag>struts2进阶篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[struts2入门篇(基础框架搭建)]]></title>
    <url>%2F2018%2F12%2F20%2Fstruts2-1%2F</url>
    <content type="text"><![CDATA[Struts2的学习路线 1.Struts2的入门篇：主要是学习Struts2的开发流程（Struts2的开发流程、常见的配置、Action类的编写） 2.Struts2的进阶篇: Struts2的Servlet的API、参数封装和拦截器 3.Struts2的完善篇: Struts2的值栈和OGNL表达式 一.技术分析之Struts2框架的概述 1. Struts2是一个基于MVC设计模式的Web层框架 * MVC和JavaEE的三层结构 * MVC设计模式:是由一些网站的开发人员提出来的 * JavaEE三层结构:SUN公司为EE开发划分的结构 2. 常见的Web层的框架 * Struts1 * Struts2 * Webwork * SpringMVC 3. Web层框架的特点 * 都是一个特点，前端控制器模式 * 记住：前端控制器（核心的控制器） * Struts2框架前端的控制器就是过滤器 二.技术分析之Struts2快速入门的环境准备1.基础环境搭建1. 创建WEB项目，编写JSP的页面，编写超链接，点击超链接发送请求，请求服务器，让服务器的方法去执行！！ &lt;h3&gt;Struts2的入门程序&lt;/h3&gt; &lt;a href=&quot;${ pageContext.request.contextPath }/hello.action&quot;&gt;Struts2入门程序&lt;/a&gt; 2. 下载Struts2的开发包 * https://struts.apache.org/ -- 官网地址 3. 解压struts-2.3.24-all.zip包 * 解压后会看到有包和一些文件，大家需要掌握包相关的信息 * apps -- Struts2框架提供了一些应用 * libs -- Struts2框架开发的jar包 * docs -- Struts2框架开发文档 * src -- Struts2框架源码 4. 引入需要开发的jar包（最基础的jar包为13个） * Struts2框架的开发jar包非常多，但是不是所有都是必须要引入的，有一些必须要导入的jar包，这些jar包可以从Struts2框架提供的应用中找到。 * 大家可以打开apps目录，然后找到struts2-blank.war应用。war包和zip包的压缩格式是一样的，所以可以自己修改后缀名，解压。 * 找到解压后的应用，打开WEB-INF/lib目录下所以的jar包。复制到工程中，就可以了。 5. 需要配置Struts2的前端控制器，注意：这一步是必须要做的操作，这是Struts2核心的控制器。 * Struts2的前端控制器就是一个过滤器，那么过滤器相关知识咱们都学习过，需要在web.xml中进行配置。 * 前端控制器的类的路径和名称：org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter * 具体配置如下 &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 2.技术分析之编写Action类1. Action类是动作类，是Struts2处理请求，封装数据，响应页面的核心控制器。需要自己编写。 package cn.itcast.action; public String sayHello(){ System.out.println(&quot;Hello Struts2!!&quot;); return null; } 3.技术分析之编写Struts的配置文件1. 配置文件名称是struts.xml（名称必须是struts.xml） 2. 在src下引入struts.xml配置文件（配置文件的路径必须是在src的目录下） 3. 配置如下 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE struts PUBLIC &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot; &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&gt; &lt;struts&gt; &lt;package name=&quot;default&quot; namespace=&quot;/&quot; extends=&quot;struts-default&quot;&gt; &lt;action name=&quot;hello&quot; class=&quot;com.itheima.action.HelloAction&quot; method=&quot;sayHello&quot;&gt; &lt;/action&gt; &lt;/package&gt; &lt;/struts&gt; 三.入门总结之Struts2的执行流程1. 执行的流程 * 编写的页面，点击超链接，请求提交到服务器端。 * 请求会先经过Struts2的核心过滤器（StrutsPrepareAndExecuteFilter） * 过滤器的功能是完成了一部分代码功能 * 就是一系列的拦截器执行了，进行一些处理工作。 * 咱们可以在struts-default.xml配置文件中看到有很多的拦截器。可以通过断点的方式来演示。 * 拦截器执行完后，会根据struts.xml的配置文件找到请求路径，找到具体的类，通过反射的方式让方法执行。 2. 总结 * JSP页面--&gt;StrutsPrepereAndExecuteFilter过滤器--&gt;执行一系列拦截器（完成了部分代码）--&gt;执行到目标Action--&gt;返回字符串--&gt;结果页面（result）--&gt;页面跳转 四.入门总结之struts.xml的配置文件1.xml引入 dtd 约束（标签语法提示）1. 先找到struts.xml的配置文件，复制http://struts.apache.org/dtds/struts-2.3.dtd，注意，不要有双引号。 * http://struts.apache.org/dtds/struts-2.3.dtd 2. 选择window -- 首选项 -- 搜索xml -- 选择xml Catalog 3. 选择添加按钮（add按钮） * key type 要选择URI * key的位置把刚才复制的路径拷贝进去。http://struts.apache.org/dtds/struts-2.3.dtd * Location要在本地能找到struts2-2.3.dtd的真实文件。点击File System，去资料中找到它 4. 如果想查看源代码 * 选择资料/struts2/struts-2.3.24-all.zip 2.入门总结之Struts2框架配置文件加载的顺序需要掌握 * 加载了哪些个配置文件（重点的） * 配置文件的名称是什么 * 配置文件的位置 * 配置文件的作用 1. Struts2框架的核心是StrutsPrepareAndExecuteFilter过滤器，该过滤器有两个功能 * Prepare -- 预处理，加载核心的配置文件 * Execute -- 执行，让部分拦截器执行 2. StrutsPrepareAndExecuteFilter过滤器会加载哪些配置文件呢？ * 通过源代码可以看到具体加载的配置文件和加载配置文件的顺序 * init_DefaultProperties(); -- 加载org/apache/struts2/default.properties * init_TraditionalXmlConfigurations(); -- 加载struts-default.xml,struts-plugin.xml,struts.xml * init_LegacyStrutsProperties(); -- 加载自定义的struts.properties. * init_CustomConfigurationProviders(); -- 加载用户自定义配置提供者 * init_FilterInitParameters() ; -- 加载web.xml 3. 重点了解的配置文件 * default.properties -- 在org/apache/struts2/目录下，代表的是配置的是Struts2的常量的值 * struts-default.xml -- 在Struts2的核心包下，代表的是Struts2核心功能的配置（Bean、拦截器、结果类型等） * struts.xml -- 重点中的重点配置，代表WEB应用的默认配置，在工作中，基本就配置它就可以了！！（可以配置常量） * web.xml -- 配置前端控制器（可以配置常量） * 注意： * 前3个配置文件是struts2框架的默认配置文件，基本不用修改。 * 后3个配置文件可以允许自己修改struts2的常量。但是有一个特点：后加载的配置文件修改的常量的值，会覆盖掉前面修改的常量的值。 4. 总结（重点掌握的配置文件） * 先加载default.properties文件，在org/apache/struts2/default.properties文件，都是常量。 * 又加载struts-default.xml配置文件，在核心的jar包最下方，struts2框架的核心功能都是在该配置文件中配置的。 * 再加载struts.xml的配置文件，在src的目录下，代表用户自己配置的配置文件 * 最后加载web.xml的配置文件 * 后加载的配置文件会覆盖掉之前加载的配置文件（在这些配置文件中可以配置常量） 5. 注意一个问题 * 哪些配置文件中可以配置常量？ * default.properties -- 默认值 * struts.xml -- 可以配置，开发中基本上都在该配置文件中配置常量 * struts.properties -- 可以配置，基本不会在该配置文件中配置 * web.xml -- 可以配置，基本不会在该配置文件中配置 * 后加载的配置文件会覆盖掉之前加载的配置！！ 4.入门总结之struts.xml配置文件的配置1. &lt;package&gt;标签，如果要配置&lt;Action&gt;的标签，那么必须要先配置&lt;package&gt;标签，代表的包的概念 * 包含的属性 * name -- 包的名称，要求是唯一的，管理action配置 * extends -- 继承，可以继承其他的包，只要继承了，那么该包就包含了其他包的功能，一般都是继承struts-default * namespace -- 名称空间，一般与&lt;action&gt;标签中的name属性共同决定访问路径（通俗话：怎么来访问action），常见的配置如下 * namespace=&quot;/&quot; -- 根名称空间 * namespace=&quot;/aaa&quot; -- 带有名称的名称空间 * abstract -- 抽象的。这个属性基本很少使用，值如果是true，那么编写的包是被继承的 2. &lt;action&gt;标签 * 代表配置action类，包含的属性 * name -- 和&lt;package&gt;标签的namespace属性一起来决定访问路径的 * class -- 配置Action类的全路径（默认值是ActionSupport类） * method -- Action类中执行的方法，如果不指定，默认值是execute 3. &lt;result&gt;标签 * action类中方法执行，返回的结果跳转的页面 * name -- 结果页面逻辑视图名称 * type -- 结果类型（默认值是转发，也可以设置其他的值） 5.入门总结之Struts2配置常量1. 可以在Struts2框架中的哪些配置文件中配置常量？ * struts.xml（必须要掌握，开发中基本上就在该配置文件中编写常量） * &lt;constant name=&quot;key&quot; value=&quot;value&quot;&gt;&lt;/constant&gt; * web.xml * 在StrutsPrepareAndExecuteFilter配置文件中配置初始化参数 * 注意：后加载的配置的文件的常量会覆盖之前加载的常量！！ 2. 需要大家了解的常量 * struts.i18n.encoding=UTF-8 -- 指定默认编码集,作用于HttpServletRequest的setCharacterEncoding方法 * struts.action.extension=action,, -- 该属性指定需要Struts 2处理的请求后缀，该属性的默认值是action，即所有匹配*.action的请求都由Struts2处理。如果用户需要指定多个请求后缀，则多个后缀之间以英文逗号（,）隔开 * struts.serve.static.browserCache=true -- 设置浏览器是否缓存静态内容,默认值为true(生产环境下使用),开发阶段最好关闭 * struts.configuration.xml.reload=false -- 当struts的配置文件修改后,系统是否自动重新加载该文件,默认值为false(生产环境下使用) * struts.devMode = false -- 开发模式下使用,这样可以打印出更详细的错误信息 6.入门总结之指定多个struts的配置文件（了解）1. 在大部分应用里，随着应用规模的增加，系统中Action的数量也会大量增加，导致struts.xml配置文件变得非常臃肿。 为了避免struts.xml文件过于庞大、臃肿，提高struts.xml文件的可读性，我们可以将一个struts.xml配置文件分解成多个配置文件，然后在struts.xml文件中包含其他配置文件。 2. 可以在&lt;package&gt;标签中，使用&lt;include&gt;标签来引入其他的struts_xx.xml的配置文件。例如： &lt;struts&gt; &lt;include file=&quot;struts-part1.xml&quot;/&gt; &lt;include file=&quot;struts-part2.xml&quot;/&gt; &lt;/struts&gt; 3. 注意注意注意（重要的事情说三遍）：&lt;include file=&quot;cn/itcast/demo2/struts-part1.xml&quot;/&gt; 五.技术分析之Action类的三种写法1. 配置文件学习完成，下面的重点是Action类的三种写法 * Action类就是一个POJO类 * 什么是POJO类，POJO（Plain Ordinary Java Object）简单的Java对象.简单记：没有继承某个类，没有实现接口，就是POJO的类。 * Action类可以实现Action接口 * Action接口中定义了5个常量，5个常量的值对应的是5个逻辑视图跳转页面（跳转的页面还是需要自己来配置），还定义了一个方法，execute方法。 * 大家需要掌握5个逻辑视图的常量 * SUCCESS -- 成功. * INPUT -- 用于数据表单校验.如果校验失败,跳转INPUT视图. * LOGIN -- 登录. * ERROR -- 错误. * NONE -- 页面不转向. * Action类可以去继承ActionSupport类（开发中这种方式使用最多） * 设置错误信息 六.技术分析之Action的访问1. 通过&lt;action&gt;标签中的method属性，访问到Action中的具体的方法。 * 传统的配置方式，配置更清晰更好理解！但是扩展需要修改配置文件等！ * 具体的实例如下： * 页面代码 * &lt;a href=&quot;${pageContext.request.contextPath}/addBook.action&quot;&gt;添加图书&lt;/a&gt; * &lt;a href=&quot;${pageContext.request.contextPath}/deleteBook.action&quot;&gt;删除图书&lt;/a&gt; * 配置文件的代码 &lt;package name=&quot;demo2&quot; extends=&quot;struts-default&quot; namespace=&quot;/&quot;&gt; &lt;action name=&quot;addBook&quot; class=&quot;cn.itcast.demo2.BookAction&quot; method=&quot;add&quot;&gt;&lt;/action&gt; &lt;action name=&quot;deleteBook&quot; class=&quot;cn.itcast.demo2.BookAction&quot; method=&quot;delete&quot;&gt;&lt;/action&gt; &lt;/package&gt; * Action的代码 public String add(){ System.out.println(&quot;添加图书&quot;); return NONE; } public String delete(){ System.out.println(&quot;删除图书&quot;); return NONE; } 2. 通配符的访问方式:(访问的路径和方法的名称必须要有某种联系.) 通配符就是 * 代表任意的字符 * 使用通配符的方式可以简化配置文件的代码编写，而且扩展和维护比较容易。 * 具体实例如下： * 页面代码 &lt;a href=&quot;${pageContext.request.contextPath}/order_add.action&quot;&gt;添加订单&lt;/a&gt; &lt;a href=&quot;${pageContext.request.contextPath}/order_delete.action&quot;&gt;删除订单&lt;/a&gt; * 配置文件代码 * &lt;action name=&quot;order_*&quot; class=&quot;cn.itcast.demo2.OrderAction&quot; method=&quot;{1}&quot;&gt;&lt;/action&gt; * Action的代码 public String add(){ System.out.println(&quot;添加订单&quot;); return NONE; } public String delete(){ System.out.println(&quot;删除订单&quot;); return NONE; } * 具体理解：在JSP页面发送请求，http://localhost/struts2_01/order_add.action，配置文件中的order_*可以匹配该请求，*就相当于变成了add，method属性的值使用{1}来代替，{1}就表示的是第一个*号的位置！！所以method的值就等于了add，那么就找到Action类中的add方法，那么add方法就执行了！ 3. 动态方法访问的方式（有的开发中也会使用这种方式） * 如果想完成动态方法访问的方式，需要开启一个常量，struts.enable.DynamicMethodInvocation = false，把值设置成true。 * 注意：不同的Struts2框架的版本，该常量的值不一定是true或者false，需要自己来看一下。如果是false，需要自己开启。 * 在struts.xml中开启该常量。 * &lt;constant name=&quot;struts.enable.DynamicMethodInvocation&quot; value=&quot;true&quot;&gt;&lt;/constant&gt; * 具体代码如下 * 页面的代码 * &lt;a href=&quot;${pageContext.request.contextPath}/product!add.action&quot;&gt;添加商品&lt;/a&gt; * &lt;a href=&quot;${pageContext.request.contextPath}/product!delete.action&quot;&gt;删除商品&lt;/a&gt; * 配置文件代码 * &lt;action name=&quot;product&quot; class=&quot;cn.itcast.demo2.ProductAction&quot;&gt;&lt;/action&gt; * Action的类的代码 public class ProductAction extends ActionSupport{ public String add(){ System.out.println(&quot;添加订单&quot;); return NONE; } public String delete(){ System.out.println(&quot;删除订单&quot;); return NONE; } }]]></content>
      <categories>
        <category>struts2</category>
      </categories>
      <tags>
        <tag>struts2</tag>
        <tag>struts2入门篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hibernate完善篇(HQL/QBC/查询策略)]]></title>
    <url>%2F2018%2F12%2F19%2Fhibernate-4%2F</url>
    <content type="text"><![CDATA[Hibernate框架的学习路线 学习的路线 * 入门篇：主要是学习框架的入门，自己搭建框架，完成增删改查的操作 * 进阶篇：主要学习一级缓存、事务管理和基本的查询 * 高级篇：主要学习一对多和多对多的操作等 * 完善篇：基本查询和查询的优化 本篇内容 1. Hibernate的查询方式 2. Hibernate的查询策略 一.Hibernate查询1.技术分析之Hibernate框架的查询方式1. 唯一标识OID的检索方式 * session.get(对象.class,OID) 2. 对象的导航的方式 3. HQL的检索方式 * Hibernate Query Language -- Hibernate的查询语言 4. QBC的检索方式 * Query By Criteria -- 条件查询 5. SQL检索方式（了解） * 本地的SQL检索 2.技术分析之HQL的查询方式概述1. HQL的介绍 * HQL(Hibernate Query Language) 是面向对象的查询语言, 它和 SQL 查询语言有些相似 * 在 Hibernate 提供的各种检索方式中, HQL 是使用最广的一种检索方式 2. HQL与SQL的关系 * HQL 查询语句是面向对象的,Hibernate负责解析HQL查询语句, 然后根据对象-关系映射文件中的映射信息, 把 HQL 查询语句翻译成相应的 SQL 语句. * HQL 查询语句中的主体是域模型中的类及类的属性 * SQL 查询语句是与关系数据库绑定在一起的. SQL查询语句中的主体是数据库表及表的字段 3.技术分析之HQL的查询演示1. HQL基本的查询格式 * 支持方法链的编程，即直接调用list()方法 * 简单的代码如下 * session.createQuery(&quot;from Customer&quot;).list(); 2. 使用别名的方式 * 可以使用别名的方式 * session.createQuery(&quot;from Customer c&quot;).list(); * session.createQuery(&quot;select c from Customer c&quot;).list(); 3. 排序查询 * 排序查询和SQL语句中的排序的语法是一样的 * 升序 * session.createQuery(&quot;from Customer order by cust_id&quot;).list(); * 降序 * session.createQuery(&quot;from Customer order by cust_id desc&quot;).list(); 4. 分页查询 * Hibernate框架提供了分页的方法，咱们可以调用方法来完成分页 * 两个方法如下 * setFirstResult(a) -- 从哪条记录开始，如果查询是从第一条开启，值是0 * setMaxResults(b) -- 每页查询的记录条数 * 演示代码如下 * List&lt;LinkMan&gt; list = session.createQuery(&quot;from LinkMan&quot;).setFirstResult(0).setMaxResults().list(); 5. 带条件的查询 * setParameter(&quot;?号的位置，默认从0开始&quot;,&quot;参数的值&quot;); 不用考虑参数的具体类型 * 按位置绑定参数的条件查询（指定下标值，默认从0开始） * 按名称绑定参数的条件查询（HQL语句中的 ? 号换成 :名称 的方式） * 例如代码如下 Query query = session.createQuery(&quot;from Linkman where lkm_name like ? order by lkm_id desc&quot;); query.setFirstResult(0).setMaxResults(3); query.setParameter(0, &quot;%熊%&quot;); List&lt;Linkman&gt; list = query.list(); for (Linkman linkman : list) { System.out.println(linkman); } 4.HQL的投影查询1. 投影查询就是想查询某一字段的值或者某几个字段的值 2. 投影查询的案例 * 如果查询多个字段，例如下面这种方式 List&lt;Object[]&gt; list = session.createQuery(&quot;select c.cust_name,c.cust_level from Customer c&quot;).list(); for (Object[] objects : list) { System.out.println(Arrays.toString(objects)); } * 如果查询两个字段，也可以把这两个字段封装到对象中 * 先在持久化类中提供对应字段的构造方法 * 使用下面这种HQL语句的方式 List&lt;Customer&gt; list = session.createQuery(&quot;select new Customer(c.cust_name,c.cust_level) from Customer c&quot;).list(); for (Customer customer : list) { System.out.println(customer); } 5.技术分析之聚合函数查询1. 获取总的记录数 Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); List&lt;Number&gt; list = session.createQuery(&quot;select count(c) from Customer c&quot;).list(); Long count = list.get(0).longValue(); System.out.println(count); tr.commit(); 2. 获取某一列数据的和 Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); List&lt;Number&gt; list = session.createQuery(&quot;select sum(c.cust_id) from Customer c&quot;).list(); Long count = list.get(0).longValue(); System.out.println(count); tr.commit(); 6.技术分析之QBC检索方式 QBC：Query By Criteria 按条件进行查询 1. 简单查询，使用的是Criteria接口 List&lt;Customer&gt; list = session.createCriteria(Customer.class).list(); for (Customer customer : list) { System.out.println(customer); } 2. 排序查询 * 需要使用addOrder()的方法来设置参数，参数使用org.hibernate.criterion.Order对象 * 具体代码如下： Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); Criteria criteria = session.createCriteria(Linkman.class); // 设置排序 criteria.addOrder(Order.desc(&quot;lkm_id&quot;)); List&lt;Linkman&gt; list = criteria.list(); for (Linkman linkman : list) { System.out.println(linkman); } tr.commit(); 3. 分页查询 * QBC的分页查询也是使用两个方法 * setFirstResult(); * setMaxResults(); * 代码如下; Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); Criteria criteria = session.createCriteria(Linkman.class); // 设置排序 criteria.addOrder(Order.desc(&quot;lkm_id&quot;)); criteria.setFirstResult(0); criteria.setMaxResults(3); List&lt;Linkman&gt; list = criteria.list(); for (Linkman linkman : list) { System.out.println(linkman); } tr.commit(); 4. 条件查询（Criterion是查询条件的接口，Restrictions类是Hibernate框架提供的工具类，使用该工具类来设置查询条件） * 条件查询使用Criteria接口的add方法，用来传入条件。 * 使用Restrictions的添加条件的方法，来添加条件，例如： * Restrictions.eq -- 相等 * Restrictions.gt -- 大于号 * Restrictions.ge -- 大于等于 * Restrictions.lt -- 小于 * Restrictions.le -- 小于等于 * Restrictions.between -- 在之间 * Restrictions.like -- 模糊查询 * Restrictions.in -- 范围 * Restrictions.and -- 并且 * Restrictions.or -- 或者 * 测试代码如下 Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); Criteria criteria = session.createCriteria(Linkman.class); // 设置排序 criteria.addOrder(Order.desc(&quot;lkm_id&quot;)); // 设置查询条件 criteria.add(Restrictions.or(Restrictions.eq(&quot;lkm_gender&quot;, &quot;男&quot;), Restrictions.gt(&quot;lkm_id&quot;, 3L))); List&lt;Linkman&gt; list = criteria.list(); for (Linkman linkman : list) { System.out.println(linkman); } tr.commit(); 5. 聚合函数查询（Projection的聚合函数的接口，而Projections是Hibernate提供的工具类，使用该工具类设置聚合函数查询） * 使用QBC的聚合函数查询，需要使用criteria.setProjection()方法 * 具体的代码如下 Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); Criteria criteria = session.createCriteria(Linkman.class); criteria.setProjection(Projections.rowCount()); List&lt;Number&gt; list = criteria.list(); Long count = list.get(0).longValue(); System.out.println(count); tr.commit(); 7.技术分析之离线条件查询1. 离线条件查询使用的是DetachedCriteria接口进行查询，离线条件查询对象在创建的时候，不需要使用Session对象，只是在查询的时候使用Session对象即可。 2. 创建离线条件查询对象 * DetachedCriteria criteria = DetachedCriteria.forClass(Linkman.class); 3. 具体的代码如下 Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); DetachedCriteria criteria = DetachedCriteria.forClass(Linkman.class); // 设置查询条件 criteria.add(Restrictions.eq(&quot;lkm_gender&quot;, &quot;男&quot;)); // 查询数据 List&lt;Linkman&gt; list = criteria.getExecutableCriteria(session).list(); for (Linkman linkman : list) { System.out.println(linkman); } tr.commit(); 8.技术分析之SQL查询方式（了解）基本语法 Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); SQLQuery sqlQuery = session.createSQLQuery(&quot;select * from cst_linkman where lkm_gender = ?&quot;); sqlQuery.setParameter(0,&quot;男&quot;); sqlQuery.addEntity(Linkman.class); List&lt;Linkman&gt; list = sqlQuery.list(); System.out.println(list); tr.commit(); 9.技术分析之HQL多表查询1. 多表的查询进来使用HQL语句进行查询，HQL语句和SQL语句的查询语法比较类似。 * 内连接查询 * 显示内连接 * select * from customers c inner join orders o on c.cid = o.cno; * 隐式内连接 * select * from customers c,orders o where c.cid = o.cno; * 外连接查询 * 左外连接 * select * from customers c left join orders o on c.cid = o.cno; * 右外连接 * select * from customers c right join orders o on c.cid = o.cno; 2. HQL的多表查询 * 迫切和非迫切： * 非迫切返回结果是Object[] * 迫切连接返回的结果是对象，把客户的信息封装到客户的对象中，把订单的信息封装到客户的Set集合中。 3. 内连接查询 * 内连接使用 inner join ，默认返回的是Object数组 Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); List&lt;Object[]&gt; list = session.createQuery(&quot;from Customer c inner join c.linkmans&quot;).list(); for (Object[] objects : list) { System.out.println(Arrays.toString(objects)); } tr.commit(); * 迫切内连接:inner join fetch ，返回的是实体对象 Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); List&lt;Customer&gt; list = session.createQuery(&quot;from Customer c inner join fetch c.linkmans&quot;).list(); Set&lt;Customer&gt; set = new HashSet&lt;Customer&gt;(list); for (Customer customer : set) { System.out.println(customer); } tr.commit(); 4. 左外连接查询 * 左外连接: 封装成List&lt;Object[]&gt; * 迫切左外连接 Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); List&lt;Customer&gt; list = session.createQuery(&quot;from Customer c left join fetch c.linkmans&quot;).list(); Set&lt;Customer&gt; set = new HashSet&lt;Customer&gt;(list); for (Customer customer : set) { System.out.println(customer); } tr.commit(); 二.查询功能优化1.技术分析之延迟加载1. 延迟加载先获取到代理对象，当真正使用到该对象中的属性的时候，才会发送SQL语句，是Hibernate框架提升性能的方式 2. 类级别的延迟加载 * Session对象的load方法默认就是延迟加载 * Customer c = session.load(Customer.class, 1L);没有发送SQL语句，当使用该对象的属性时，才发送SQL语句 * 使类级别的延迟加载失效 * 在&lt;class&gt;标签上配置lazy=”false” * Hibernate.initialize(Object proxy); 3. 关联级别的延迟加载（查询某个客户，当查看该客户下的所有联系人是是否是延迟加载） * 默认是延迟加载 Session session = HibernateUtils.getCurrentSession(); Transaction tr = session.beginTransaction(); Customer c = session.get(Customer.class, 1L); System.out.println(&quot;=============&quot;); System.out.println(c.getLinkmans().size()); tr.commit(); 2.技术分析之Hibernate框架的查询策略1. 查询策略：使用Hibernate查询一个对象的时候，查询其关联对象.应该如何查询.是Hibernate的一种优化手段!!! 2. Hibernate框架的检索策略解决的问题 * 查询的时机 Customer c1 = (Customer) session.get(Customer.class, 1); System.out.println(c1.getLinkmans().size()); * lazy属性解决查询的时机的问题，需要配置是否采用延迟加载！！ * 查询的语句形式 List&lt;Customer&gt; list = session.createQuery(&quot;from Customer&quot;).list(); for(Customer c : list){ System.out.println(c.getLinkmans()); } * fetch属性就可以解决查询语句的形式的问题！！ 3.技术分析之在set标签上配置策略1. 在&lt;set&gt;标签上使用fetch和lazy属性 * fetch的取值 -- 控制SQL语句生成的格式 * select -- 默认值.发送查询语句 * join -- 连接查询.发送的是一条迫切左外连接!!!配置了join.lazy就失效了 * subselect -- 子查询.发送一条子查询查询其关联对象.(需要使用list()方法进行测试) * lazy的取值 -- 查找关联对象的时候是否采用延迟! * true -- 默认.延迟 * false -- 不延迟 * extra -- 及其懒惰 2. set标签上的默认值是fetch=&quot;select&quot;和lazy=&quot;true&quot; 3. 总结：Hibernate框架都采用了默认值，开发中基本上使用的都是默认值。特殊的情况。 4.技术分析之在man-to-one标签上配置策略1. 在&lt;many-to-one&gt;标签上使用fetch和lazy属性 * fetch的取值 -- 控制SQL的格式. * select -- 默认。发送基本select语句查询 * join -- 发送迫切左外连接查询 * lazy的取值 -- 控制加载关联对象是否采用延迟. * false -- 不采用延迟加载. * proxy -- 默认值.代理.现在是否采用延迟. * 由另一端的&lt;class&gt;上的lazy确定.如果这端的class上的lazy=”true”.proxy的值就是true(延迟加载). * 如果class上lazy=”false”.proxy的值就是false(不采用延迟.) 2. 在&lt;many-to-one&gt;标签上的默认值是fetch=&quot;select&quot;和proxy]]></content>
      <categories>
        <category>hibernate</category>
      </categories>
      <tags>
        <tag>hibernate</tag>
        <tag>hibernate HQL/QBC</tag>
        <tag>hibernate完善篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hibernate高级篇(一对多/多对多)]]></title>
    <url>%2F2018%2F12%2F18%2Fhibernate-3%2F</url>
    <content type="text"><![CDATA[Hibernate框架的学习路线 学习的路线 * 入门篇：主要是学习框架的入门，自己搭建框架，完成增删改查的操作 * 进阶篇：主要学习一级缓存、事务管理和基本的查询 * 高级篇：主要学习一对多和多对多的操作等 * 完善篇：基本查询和查询的优化 今天内容 一. 一对多 二. 多对多 一.一对多1.技术分析之Hibernate的关联关系映射之 一对多 映射（重点）1. 编写客户和联系人的JavaBean程序（注意一对多的编写规则） * 客户的JavaBean如下 public class Customer { private Long cust_id; private String cust_name; private Long cust_user_id; private Long cust_create_id; private String cust_source; private String cust_industry; private String cust_level; private String cust_linkman; private String cust_phone; private String cust_mobile; private Set&lt;Linkman&gt; linkmans = new HashSet&lt;Linkman&gt;(); } * 联系人的JavaBean如下 public class Linkman { private Long lkm_id; private String lkm_name; private String lkm_gender; private String lkm_phone; private String lkm_mobile; private String lkm_email; private String lkm_qq; private String lkm_position; private String lkm_memo; private Customer customer; } 2. 编写客户和联系人的映射配置文件（注意一对多的配置编写） * 客户的映射配置文件如下 &lt;class name=&quot;com.itheima.domain.Customer&quot; table=&quot;cst_customer&quot;&gt; &lt;id name=&quot;cust_id&quot; column=&quot;cust_id&quot;&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;property name=&quot;cust_name&quot; column=&quot;cust_name&quot;/&gt; &lt;property name=&quot;cust_user_id&quot; column=&quot;cust_user_id&quot;/&gt; &lt;property name=&quot;cust_create_id&quot; column=&quot;cust_create_id&quot;/&gt; &lt;property name=&quot;cust_source&quot; column=&quot;cust_source&quot;/&gt; &lt;property name=&quot;cust_industry&quot; column=&quot;cust_industry&quot;/&gt; &lt;property name=&quot;cust_level&quot; column=&quot;cust_level&quot;/&gt; &lt;property name=&quot;cust_linkman&quot; column=&quot;cust_linkman&quot;/&gt; &lt;property name=&quot;cust_phone&quot; column=&quot;cust_phone&quot;/&gt; &lt;property name=&quot;cust_mobile&quot; column=&quot;cust_mobile&quot;/&gt; &lt;set name=&quot;linkmans&quot;&gt; &lt;key column=&quot;lkm_cust_id&quot;/&gt; &lt;one-to-many class=&quot;com.itheima.domain.Linkman&quot;/&gt; &lt;/set&gt; &lt;/class&gt; * 联系人的映射配置文件如下 &lt;class name=&quot;com.itheima.domain.Linkman&quot; table=&quot;cst_linkman&quot;&gt; &lt;id name=&quot;lkm_id&quot; column=&quot;lkm_id&quot;&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;property name=&quot;lkm_name&quot; column=&quot;lkm_name&quot;/&gt; &lt;property name=&quot;lkm_gender&quot; column=&quot;lkm_gender&quot;/&gt; &lt;property name=&quot;lkm_phone&quot; column=&quot;lkm_phone&quot;/&gt; &lt;property name=&quot;lkm_mobile&quot; column=&quot;lkm_mobile&quot;/&gt; &lt;property name=&quot;lkm_email&quot; column=&quot;lkm_email&quot;/&gt; &lt;property name=&quot;lkm_qq&quot; column=&quot;lkm_qq&quot;/&gt; &lt;property name=&quot;lkm_position&quot; column=&quot;lkm_position&quot;/&gt; &lt;property name=&quot;lkm_memo&quot; column=&quot;lkm_memo&quot;/&gt; &lt;many-to-one name=&quot;customer&quot; class=&quot;com.itheima.domain.Customer&quot; column=&quot;lkm_cust_id&quot;/&gt; &lt;/class&gt; 2.技术分析之保存客户和联系人的数据进行双向关联进行数据的保存 3.技术分析之级联保存1. 测试：如果现在代码只插入其中的一方的数据 * 如果只保存其中的一方的数据，那么程序会抛出异常。 * 如果想完成只保存一方的数据，并且把相关联的数据都保存到数据库中，那么需要配置级联！！ * 级联保存是方向性 2. 级联保存效果 * 级联保存：保存一方同时可以把关联的对象也保存到数据库中！！ * 使用cascade=&quot;save-update&quot; 4.技术分析之级联删除1. 先来给大家在数据库中演示含有外键的删除客户功能，那么SQL语句是会报出错误的 * 例如：delete from customers where cid = 1; 2. 如果使用Hibernate框架直接删除客户的时候，测试发现是可以删除的 3. 上述的删除是普通的删除，那么也可以使用级联删除，注意：级联删除也是有方向性的！！ * &lt;many-to-one cascade=&quot;delete&quot; /&gt; 5.技术分析之级联的取值（cascade的取值）和孤儿删除1. 需要大家掌握的取值如下 * none -- 不使用级联 * save-update -- 级联保存或更新 * delete -- 级联删除 * delete-orphan -- 孤儿删除.(注意：只能应用在一对多关系) * all -- 除了delete-orphan的所有情况.（包含save-update delete） * all-delete-orphan -- 包含了delete-orphan的所有情况.（包含save-update delete delete-orphan） 2. 孤儿删除（孤子删除），只有在一对多的环境下才有孤儿删除 * 在一对多的关系中,可以将一的一方认为是父方.将多的一方认为是子方.孤儿删除:在解除了父子关系的时候.将子方记录就直接删除。 * &lt;many-to-one cascade=&quot;delete-orphan&quot; /&gt; 6.技术分析之让某一方放弃外键的维护，为多对多做准备1. 先测试双方都维护外键的时候，会产生多余的SQL语句。 * 想修改客户和联系人的关系，进行双向关联，双方都会维护外键，会产生多余的SQL语句。 * 产生的原因：session的一级缓存中的快照机制，会让双方都更新数据库，产生了多余的SQL语句。 2. 如果不想产生多余的SQL语句，那么需要一方来放弃外键的维护！ * 在&lt;set&gt;标签上配置一个inverse=”true”.true:放弃.false:不放弃.默认值是false * &lt;inverse=&quot;true&quot;&gt; 7.技术分析之cascade和inverse的区别1. cascade用来级联操作（保存、修改和删除） 2. inverse用来维护外键的 二.Hibernate的关联关系映射之多对多映射1.技术分析之多对多JavaBean的编写1. 编写用户和角色的JavaBean * 用户的JavaBean代码如下 public class User { private Long user_id; private String user_code; private String user_name; private String user_password; private String user_state; private Set&lt;Role&gt; roles = new HashSet&lt;Role&gt;(); } * 角色的JavaBean代码如下 public class Role { private Long role_id; private String role_name; private String role_memo; private Set&lt;User&gt; users = new HashSet&lt;User&gt;(); } 2. 用户和角色的映射配置文件如下 * 用户的映射配置文件如下 &lt;class name=&quot;com.itheima.domain.User&quot; table=&quot;sys_user&quot;&gt; &lt;id name=&quot;user_id&quot; column=&quot;user_id&quot;&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;property name=&quot;user_code&quot; column=&quot;user_code&quot;/&gt; &lt;property name=&quot;user_name&quot; column=&quot;user_name&quot;/&gt; &lt;property name=&quot;user_password&quot; column=&quot;user_password&quot;/&gt; &lt;property name=&quot;user_state&quot; column=&quot;user_state&quot;/&gt; &lt;set name=&quot;roles&quot; table=&quot;sys_user_role&quot;&gt; &lt;key column=&quot;user_id&quot;/&gt; &lt;many-to-many class=&quot;com.itheima.domain.Role&quot; column=&quot;role_id&quot;/&gt; &lt;/set&gt; &lt;/class&gt; * 角色的映射配置文件如下 &lt;class name=&quot;com.itheima.domain.Role&quot; table=&quot;sys_role&quot;&gt; &lt;id name=&quot;role_id&quot; column=&quot;role_id&quot;&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;property name=&quot;role_name&quot; column=&quot;role_name&quot;/&gt; &lt;property name=&quot;role_memo&quot; column=&quot;role_memo&quot;/&gt; &lt;set name=&quot;users&quot; table=&quot;sys_user_role&quot;&gt; &lt;key column=&quot;role_id&quot;/&gt; &lt;many-to-many class=&quot;com.itheima.domain.User&quot; column=&quot;user_id&quot;/&gt; &lt;/set&gt; &lt;/class&gt; 3. 多对多进行双向关联的时候:必须有一方去放弃外键维护权 2.技术分析之多对多的级联保存级联保存 * &lt;set cascade=&quot;save-update&quot;&gt; 3.级联删除（在多对多中是很少使用的）]]></content>
      <categories>
        <category>hibernate</category>
      </categories>
      <tags>
        <tag>hibernate</tag>
        <tag>hibernate高级篇</tag>
        <tag>hibernate一对多</tag>
        <tag>hibernate多对多</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hibernate进阶篇(持久化对象/session/事务)]]></title>
    <url>%2F2018%2F12%2F17%2Fhibernate-2%2F</url>
    <content type="text"><![CDATA[Hibernate框架的学习路线 学习的路线 * 入门篇：主要是学习框架的入门，自己搭建框架，完成增删改查的操作 * 进阶篇：主要学习一级缓存、事务管理和基本的查询 * 高级篇：主要学习一对多和多对多的操作等 * 完善篇：基本查询和查询的优化 本篇内容（接hibernate入门篇 一. Hibernate持久化对象的状态 二. Hibernate的一级缓存 三. Hibernate的事务与并发 四. Hibernate的基本查询 一.Hibernate的持久化类1.什么是持久化类持久化类:就是一个Java类（JavaBean），这个Java类与表建立了映射关系就可以成为是持久化类。 持久化类 = JavaBean + xxx.hbm.xml 2.持久化类的编写规则1. 提供一个无参数 public访问控制符的构造器 -- 底层需要进行反射. 2. 提供一个标识属性，映射数据表主键字段 -- 唯一标识OID.数据库中通过主键.Java对象通过地址确定对象.持久化类通过唯一标识OID确定记录 3. 所有属性提供public访问控制符的 set或者get 方法 4. 标识属性应尽量使用基本数据类型的包装类型 3.区分自然主键和代理主键1. 创建表的时候 * 自然主键:对象本身的一个属性.创建一个人员表,每个人都有一个身份证号. (唯一的)使用身份证号作为表的主键.自然主键.（开发中不会使用这种方式） * 代理主键:不是对象本身的一个属性.创建一个人员表,为每个人员单独创建一个字段. 用这个字段作为主键.代理主键.（开发中推荐使用这种方式） 2. 创建表的时候尽量使用 代理主键 创建表 4.主键的生成策略1. increment:适用于short,int,long作为主键.不是使用的数据库自动增长机制. * Hibernate中提供的一种增长机制. * 先进行查询 :select max(id) from user; * 再进行插入 :获得最大值+1作为新的记录的主键. * 问题:不能在集群环境下或者有并发访问的情况下使用. 2. identity:适用于short,int,long作为主键。但是这个必须使用在有自动增长数据库中.采用的是数据库底层的自动增长机制. * 底层使用的是数据库的自动增长(auto_increment).像Oracle数据库没有自动增长. 3. sequence:适用于short,int,long作为主键.底层使用的是序列的增长方式. * Oracle数据库底层没有自动增长,想自动增长需要使用序列. 4. uuid:适用于char,varchar类型的作为主键. * 使用随机的字符串作为主键. 5. native:本地策略.根据底层的数据库不同,自动选择适用于该种数据库的生成策略.(short,int,long) * 如果底层使用的MySQL数据库:相当于identity. * 如果底层使用Oracle数据库:相当于sequence. 6. assigned:主键的生成不用Hibernate管理了.必须手动设置主键. 5.Hibernate持久化对象的状态1. Hibernate的持久化类 * 持久化类:Java类与数据库的某个表建立了映射关系.这个类就称为是持久化类. * 持久化类 = Java类 + hbm的配置文件 2. Hibernate的持久化类的状态 * Hibernate为了管理持久化类：将持久化类分成了三个状态 * 瞬时态:Transient Object * 没有持久化标识OID, 没有被纳入到Session对象的管理. * 持久态:Persistent Object * 有持久化标识OID,已经被纳入到Session对象的管理. * 脱管态:Detached Object * 有持久化标识OID,没有被纳入到Session对象的管理. 6.Hibernate持久化对象的状态的转换1. 瞬时态 -- 没有持久化标识OID, 没有被纳入到Session对象的管理 * 获得瞬时态的对象 * User user = new User() * 瞬时态对象转换持久态 * save()/saveOrUpdate(); * 瞬时态对象转换成脱管态 * user.setId(1) 2. 持久态 -- 有持久化标识OID,已经被纳入到Session对象的管理 * 获得持久态的对象 * get()/load(); * 持久态转换成瞬时态对象 * delete(); --- 比较有争议的，进入特殊的状态(删除态:Hibernate中不建议使用的) * 持久态对象转成脱管态对象 * session的close()/evict()/clear(); 3. 脱管态 -- 有持久化标识OID,没有被纳入到Session对象的管理 * 获得托管态对象:不建议直接获得脱管态的对象. * User user = new User(); * user.setId(1); * 脱管态对象转换成持久态对象 * update();/saveOrUpdate()/lock(); * 脱管态对象转换成瞬时态对象 * user.setId(null); 4. 注意：持久态对象有自动更新数据库的能力!!! 二.Hibernate的一级缓存1.Session对象的一级缓存（重点）1. 什么是缓存？ * 其实就是一块内存空间,将数据源（数据库或者文件）中的数据存放到缓存中.再次获取的时候 ,直接从缓存中获取.可以提升程序的性能！ 2. Hibernate框架提供了两种缓存 * 一级缓存 -- 自带的不可卸载的.一级缓存的生命周期与session一致.一级缓存称为session级别的缓存. * 二级缓存 -- 默认没有开启，需要手动配置才可以使用的.二级缓存可以在多个session中共享数据,二级缓存称为是sessionFactory级别的缓存. 3. Session对象的缓存概述 * Session接口中,有一系列的java的集合,这些java集合构成了Session级别的缓存(一级缓存).将对象存入到一级缓存中,session没有结束生命周期,那么对象在session中存放着 * 内存中包含Session实例 --&gt; Session的缓存（一些集合） --&gt; 集合中包含的是缓存对象！ 4. 证明一级缓存的存在，编写查询的代码即可证明 * 在同一个Session对象中两次查询，可以证明使用了缓存 5. Hibernate框架是如何做到数据发生变化时进行同步操作的呢？ * 使用get方法查询User对象 * 然后设置User对象的一个属性，注意：没有做update操作。发现，数据库中的记录也改变了。 * 利用快照机制来完成的（SnapShot） 2.控制Session的一级缓存（了解）1. 学习Session接口中与一级缓存相关的方法 * Session.clear() -- 清空缓存。 * Session.evict(Object entity) -- 从一级缓存中清除指定的实体对象。 * Session.flush() -- 刷出缓存 三.Hibernate中的事务与并发1.事务相关的概念1. 什么是事务 * 事务就是逻辑上的一组操作，组成事务的各个执行单元，操作要么全都成功，要么全都失败. * 转账的例子：冠希给美美转钱，扣钱，加钱。两个操作组成了一个事情！ 2. 事务的特性 * 原子性 -- 事务不可分割. * 一致性 -- 事务执行的前后数据的完整性保持一致. * 隔离性 -- 一个事务执行的过程中,不应该受到其他的事务的干扰. * 持久性 -- 事务一旦提交,数据就永久保持到数据库中. 3. 如果不考虑隔离性:引发一些读的问题 * 脏读 -- 一个事务读到了另一个事务未提交的数据. * 不可重复读 -- 一个事务读到了另一个事务已经提交的update数据,导致多次查询结果不一致. * 虚读 -- 一个事务读到了另一个事务已经提交的insert数据,导致多次查询结构不一致. 4. 通过设置数据库的隔离级别来解决上述读的问题 * 未提交读:以上的读的问题都有可能发生. * 已提交读:避免脏读,但是不可重复读，虚读都有可能发生. * 可重复读:避免脏读，不可重复读.但是虚读是有可能发生. * 串行化:以上读的情况都可以避免. 5. 如果想在Hibernate的框架中来设置隔离级别，需要在hibernate.cfg.xml的配置文件中通过标签来配置 * 通过：hibernate.connection.isolation = 4 来配置 * 取值 * 1—Read uncommitted isolation * 2—Read committed isolation * 4—Repeatable read isolation * 8—Serializable isolation 2.丢失更新的问题1. 如果不考虑隔离性，也会产生写入数据的问题，这一类的问题叫丢失更新的问题。 2. 例如：两个事务同时对某一条记录做修改，就会引发丢失更新的问题。 * A事务和B事务同时获取到一条数据，同时再做修改 * 如果A事务修改完成后，提交了事务 * B事务修改完成后，不管是提交还是回滚，如果不做处理，都会对数据产生影响 3. 解决方案有两种 * 悲观锁 * 采用的是数据库提供的一种锁机制，如果采用做了这种机制，在SQL语句的后面添加 for update 子句 * 当A事务在操作该条记录时，会把该条记录锁起来，其他事务是不能操作这条记录的。 * 只有当A事务提交后，锁释放了，其他事务才能操作该条记录 * 乐观锁 * 采用版本号的机制来解决的。会给表结构添加一个字段version=0，默认值是0 * 当A事务在操作完该条记录，提交事务时，会先检查版本号，如果发生版本号的值相同时，才可以提交事务。同时会更新版本号version=1. * 当B事务操作完该条记录时，提交事务时，会先检查版本号，如果发现版本不同时，程序会出现错误。 4. 使用Hibernate框架解决丢失更新的问题 * 悲观锁 * 使用session.get(Customer.class, 1,LockMode.UPGRADE); 方法 * 乐观锁 * 1.在对应的JavaBean中添加一个属性，名称可以是任意的。例如：private Integer version; 提供get和set方法 * 2.在映射的配置文件中，提供&lt;version name=&quot;version&quot;/&gt;标签即可。 3.绑定本地的Session1. 之前在讲JavaWEB的事务的时候，需要在业务层使用Connection来开启事务， * 一种是通过参数的方式传递下去 * 另一种是把Connection绑定到ThreadLocal对象中 2. 现在的Hibernate框架中，使用session对象开启事务，所以需要来传递session对象，框架提供了ThreadLocal的方式 * 需要在hibernate.cfg.xml的配置文件中提供配置 * &lt;property name=&quot;hibernate.current_session_context_class&quot;&gt;thread&lt;/property&gt; * 重新HibernateUtil的工具类，使用SessionFactory的getCurrentSession()方法，获取当前的Session对象。并且该Session对象不用手动关闭，线程结束了，会自动关闭。 public static Session getCurrentSession(){ return factory.getCurrentSession(); } * 注意：想使用getCurrentSession()方法，必须要先配置才能使用。 四.Hibernate框架的查询方式1.Query查询接口具体的查询代码如下: // 1.查询所有记录 /*Query query = session.createQuery(&quot;from Customer&quot;); List&lt;Customer&gt; list = query.list(); System.out.println(list);*/ // 2.条件查询: /*Query query = session.createQuery(&quot;from Customer where name = ?&quot;); query.setString(0, &quot;李健&quot;); List&lt;Customer&gt; list = query.list(); System.out.println(list);*/ // 3.条件查询: /*Query query = session.createQuery(&quot;from Customer where name = :aaa and age = :bbb&quot;); query.setString(&quot;aaa&quot;, &quot;李健&quot;); query.setInteger(&quot;bbb&quot;, 38); List&lt;Customer&gt; list = query.list(); System.out.println(list);*/ 2.Criteria查询接口（做条件查询非常合适）具体的查询代码如下 // 1.查询所有记录 /*Criteria criteria = session.createCriteria(Customer.class); List&lt;Customer&gt; list = criteria.list(); System.out.println(list);*/ // 2.条件查询 /*Criteria criteria = session.createCriteria(Customer.class); criteria.add(Restrictions.eq(&quot;name&quot;, &quot;李健&quot;)); List&lt;Customer&gt; list = criteria.list(); System.out.println(list);*/ // 3.条件查询 /*Criteria criteria = session.createCriteria(Customer.class); criteria.add(Restrictions.eq(&quot;name&quot;, &quot;李健&quot;)); criteria.add(Restrictions.eq(&quot;age&quot;, 38)); List&lt;Customer&gt; list = criteria.list(); System.out.println(list);*/]]></content>
      <categories>
        <category>hibernate</category>
      </categories>
      <tags>
        <tag>hibernate</tag>
        <tag>hibernate进阶篇</tag>
        <tag>hibernate session</tag>
        <tag>hibernate 持久化</tag>
        <tag>hibernate 事务</tag>
        <tag>hibernate 一级缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx介绍篇(反向代理/负载均衡/动静分离/session共享)]]></title>
    <url>%2F2018%2F12%2F17%2Fnginx-introduce%2F</url>
    <content type="text"><![CDATA[一.nginx概述1.什么是nginxNginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。 2.为什么使用Nginx?背景:互联网飞速发展的今天,大用户量高并发已经成为互联网的主体.怎样能让一个网站能够承载几万个或几十万个用户的持续访问呢？这是一些中小网站急需解决的问题。用单机tomcat搭建的网站，在比较理想的状态下能够承受的并发访问量在150到200左右。按照并发访问量占总用户数量的5%到10%这样计算，单点tomcat网站的用户人数在1500到4000左右。对于一个为全国范围提供服务的网站显然是不够用的，为了解决这个问题引入了负载均衡方法。负载均衡就是一个web服务器解决不了的问题可以通过多个web服务器来平均分担压力来解决，并发过来的请求被平均分配到多个后台web服务器来处理，这样压力就被分解开来。 负载均衡服务器分为两种一种是通过硬件实现的负载均衡服务器，简称硬负载例如：f5。另一种是通过软件来实现的负载均衡，简称软负载:例如apache和nginx。硬负载和软负载相比前者作用的网络层次比较多可以作用到socket接口的数据链路层对发出的请求进行分组转发但是价格成本比较贵，而软负载作用的层次在http协议层之上可以对http请求进行分组转发并且因为是开源的所以几乎是0成本，并且阿里巴巴，京东等电商网站使用的都是Nginx服务器。 二.nginx的功能实现完成Nginx负载均衡,那么需要先来介绍Tomcat的安装和配置,我们首先要来配置Tomcat完成集群的配置.因为我们没有多台服务器运行Tomcat.那么我们可以模拟在一台服务器上运行多个Tomcat程序. 1.使用Tomcat配置Tomcat集群:修改 nginx/conf/nginx.conf 文件： 2session共享问题问题:通过以上的配置我们已经可以通过访问http://192.168.93.88/project访问到不同的tomcat来分担服务器端的压力.请求负载过程中会话信息不能丢失.那么需要在多个tomcat中session需要共享. 配置Tomcat的session共享可以有三种解决方案: 第一种是以负载均衡服务器本身提供的session共享策略，每种服务期的配置是不一样的并且nginx本身是没有的。（linux常用 一个ip只能始终访问一台服务器） 第二种是利用web容器本身的session共享策略来配置共享。针对于weblogic这种方式还是靠普的。但是针对于tomcat这种方式存在很大的缺陷，主要因为是依靠广播方式来实现的session复制，会浪费很多带宽导致整个网络反映缓慢。官网也建议这种方式最好不要超过4台tomcat,具体的内容可参考/webapps/docs/cluster-howto.html里面有详细的说明。下面是具体的配置过程（windows常用） 第三种是Tomcat集群+redis的Session共享配置方法. 二.nginx反向代理/负载均衡/动静分离 理解1.nginx反向代理反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。 2.nginx负载均衡负载均衡，英文名称为Load Balance，是指建立在现有网络结构之上，并提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。其原理就是数据流量分摊到多个服务器上执行，减轻每台服务器的压力，多台服务器共同完成工作任务，从而提高了数据的吞吐量。 3.nginx动静分离为了提高网站的响应速度，减轻程序服务器（Tomcat，Jboss等）的负载，对于静态资源比如图片，js，css等文件，我们可以在反向代理服务器中进行缓存，这样浏览器在请求一个静态资源时，代理服务器就可以直接处理，而不用将请求转发给后端服务器。用户请求的动态文件比如servlet,jsp则转发给Tomcat，Jboss服务器处理，这就是动静分离。]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>nginx 功能概述</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hibernate入门篇(框架搭建)]]></title>
    <url>%2F2018%2F12%2F16%2Fhibernate-1%2F</url>
    <content type="text"><![CDATA[Hibernate框架的学习路线 学习的路线 * 入门篇：主要是学习框架的入门，自己搭建框架，完成增删改查的操作 * 进阶篇：主要学习一级缓存、事务管理和基本的查询 * 高级篇：主要学习一对多和多对多的操作等 * 完善篇：基本查询和查询的优化 一.Hibernate框架的概述1. Hibernate框架的概述 * Hibernate称为 * Hibernate是一个开放源代码的对象关系映射（ORM）框架，它对JDBC进行了非常轻量级的对象封装，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 * Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用。 * Hibernate是轻量级JavaEE应用的持久层解决方案，是一个关系数据库ORM框架 2. 记住：Hibernate是一个持久层的ORM框架！！！ 二.什么是ORM（对象关系映射） 1. ORM映射：Object Relational Mapping * O：面向对象领域的Object（JavaBean对象） * R：关系数据库领域的Relational（表的结构） * M：映射Mapping（XML的配置文件） 2. 简单一句话：Hibernate使程序员通过操作对象的方式来操作数据库表记录 三.Hibernate优点1. 优点 * Hibernate对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码 * Hibernate是一个基于jdbc的主流持久化框架，是一个优秀的orm实现，它很大程度的简化了dao层编码工作 * Hibernate的性能非常好，因为它是一个轻量级框架。映射的灵活性很出色。它支持很多关系型数据库，从一对一到多对多的各种复杂关系 四.技术分析之Hibernate框架的快速入门1.第一步：下载Hibernate5的运行环境1. 下载相应的jar包等 * http://sourceforge.net/projects/hibernate/files/hibernate-orm/5.0.7.Final/hibernate-release-5.0.7.Final.zip/download 2. 解压后对目录结构有一定的了解 2.第二步：创建表结构**1. 建表语句如下 Create database hibernate_day01; Use hibernate_day01; CREATE TABLE `cst_customer` ( `cust_id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT &apos;客户编号(主键)&apos;, `cust_name` varchar(32) NOT NULL COMMENT &apos;客户名称(公司名称)&apos;, `cust_user_id` bigint(32) DEFAULT NULL COMMENT &apos;负责人id&apos;, `cust_create_id` bigint(32) DEFAULT NULL COMMENT &apos;创建人id&apos;, `cust_source` varchar(32) DEFAULT NULL COMMENT &apos;客户信息来源&apos;, `cust_industry` varchar(32) DEFAULT NULL COMMENT &apos;客户所属行业&apos;, `cust_level` varchar(32) DEFAULT NULL COMMENT &apos;客户级别&apos;, `cust_linkman` varchar(64) DEFAULT NULL COMMENT &apos;联系人&apos;, `cust_phone` varchar(64) DEFAULT NULL COMMENT &apos;固定电话&apos;, `cust_mobile` varchar(16) DEFAULT NULL COMMENT &apos;移动电话&apos;, PRIMARY KEY (`cust_id`) ) ENGINE=InnoDB AUTO_INCREMENT=94 DEFAULT CHARSET=utf8; 3.第三步：搭建Hibernate的开发环境1. 创建WEB工程，引入Hibernate开发所需要的jar包 * MySQL的驱动jar包 * Hibernate开发需要的jar包（资料/hibernate-release-5.0.7.Final/lib/required/所有jar包） * 日志jar包（资料/jar包/log4j/所有jar包） 4.第四步：编写JavaBean实体类1. Customer类的代码如下： public class Customer { private Long cust_id; private String cust_name; private Long cust_user_id; private Long cust_create_id; private String cust_source; private String cust_industry; private String cust_level; private String cust_linkman; private String cust_phone; private String cust_mobile; // 省略get和set方法 } 5.第五步：创建类与表结构的映射1. 在JavaBean所在的包下创建映射的配置文件 * 默认的命名规则为：实体类名.hbm.xml * 在xml配置文件中引入约束（引入的是hibernate3.0的dtd约束，不要引入4的约束） &lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt; 2. 如果不能上网，编写配置文件是没有提示的，需要自己来配置 * 先复制http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd --&gt; window --&gt; preferences --&gt; 搜索xml --&gt; 选择xml catalog --&gt; 点击add --&gt; 现在URI --&gt; 粘贴复制的地址 --&gt; 选择location，选择本地的DTD的路径 3. 编写映射的配置文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt; &lt;hibernate-mapping&gt; &lt;class name=&quot;com.itheima.domain.Customer&quot; table=&quot;cst_customer&quot;&gt; &lt;id name=&quot;cust_id&quot; column=&quot;cust_id&quot;&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;property name=&quot;cust_name&quot; column=&quot;cust_name&quot;/&gt; &lt;property name=&quot;cust_user_id&quot; column=&quot;cust_user_id&quot;/&gt; &lt;property name=&quot;cust_create_id&quot; column=&quot;cust_create_id&quot;/&gt; &lt;property name=&quot;cust_source&quot; column=&quot;cust_source&quot;/&gt; &lt;property name=&quot;cust_industry&quot; column=&quot;cust_industry&quot;/&gt; &lt;property name=&quot;cust_level&quot; column=&quot;cust_level&quot;/&gt; &lt;property name=&quot;cust_linkman&quot; column=&quot;cust_linkman&quot;/&gt; &lt;property name=&quot;cust_phone&quot; column=&quot;cust_phone&quot;/&gt; &lt;property name=&quot;cust_mobile&quot; column=&quot;cust_mobile&quot;/&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; 6.第六步：编写Hibernate核心的配置文件1. 在src目录下，创建名称为hibernate.cfg.xml的配置文件 2. 在XML中引入DTD约束 &lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt; 3. 打开：资料/hibernate-release-5.0.7.Final/project/etc/hibernate.properties，可以查看具体的配置信息 * 必须配置的4大参数 #hibernate.connection.driver_class com.mysql.jdbc.Driver #hibernate.connection.url jdbc:mysql:///test #hibernate.connection.username gavin #hibernate.connection.password * 数据库的方言（必须配置的） #hibernate.dialect org.hibernate.dialect.MySQLDialect * 可选的配置 #hibernate.show_sql true #hibernate.format_sql true #hibernate.hbm2ddl.auto update * 引入映射配置文件（一定要注意，要引入映射文件，框架需要加载映射文件） * &lt;mapping resource=&quot;com/itheima/domain/Customer.hbm.xml&quot;/&gt; 4. 具体的配置如下 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt; &lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;hibernate.connection.url&quot;&gt;jdbc:mysql:///hibernate_day01&lt;/property&gt; &lt;property name=&quot;hibernate.connection.username&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;hibernate.connection.password&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;mapping resource=&quot;com/itheima/domain/Customer.hbm.xml&quot;/&gt; &lt;/session-factory&gt; &lt;/hibernate-configuration&gt; 7.第七步：编写Hibernate入门代码1. 具体的代码如下 /** * 测试保存客户 */ @Test public void testSave(){ // 先加载配置文件 Configuration config = new Configuration(); // 默认加载src目录下的配置文件 config.configure(); // 创建SessionFactory对象 SessionFactory factory = config.buildSessionFactory(); // 创建session对象 Session session = factory.openSession(); // 开启事务 Transaction tr = session.beginTransaction(); // 编写保存代码 Customer c = new Customer(); // c.setCust_id(cust_id); 已经自动递增 c.setCust_name(&quot;测试名称&quot;); c.setCust_mobile(&quot;110&quot;); // 保存客户 session.save(c); // 提交事务 tr.commit(); // 释放资源 session.close(); factory.close(); } 五.Hibernate具体配置文件(初阶段)1.ibernate配置文件之映射配置文件1. 映射文件，即Stu.hbm.xml的配置文件 * &lt;class&gt;标签 -- 用来将类与数据库表建立映射关系 * name -- 类的全路径 * table -- 表名.(类名与表名一致,那么table属性也可以省略) * catalog -- 数据库的名称，基本上都会省略不写 * &lt;id&gt;标签 -- 用来将类中的属性与表中的主键建立映射，id标签就是用来配置主键的。 * name -- 类中属性名 * column -- 表中的字段名.(如果类中的属性名与表中的字段名一致,那么column可以省略.) * length -- 字段的程度，如果数据库已经创建好了，那么length可以不写。如果没有创建好，生成表结构时，length最好指定。 * &lt;property&gt; -- 用来将类中的普通属性与表中的字段建立映射. * name -- 类中属性名 * column -- 表中的字段名.(如果类中的属性名与表中的字段名一致,那么column可以省略.) * length -- 数据长度 * type -- 数据类型（一般都不需要编写，如果写需要按着规则来编写） * Hibernate的数据类型 type=&quot;string&quot; * Java的数据类型 type=&quot;java.lang.String&quot; * 数据库字段的数据类型 &lt;column name=&quot;name&quot; sql-type=&quot;varchar&quot;/&gt; 2.Hibernate配置文件之核心配置文件1. 核心配置文件的两种方式 * 第一种方式是属性文件的形式，即properties的配置文件 * hibernate.properties * hibernate.connection.driver_class=com.mysql.jdbc.Driver * 缺点 * 不能加载映射的配置文件，需要手动编写代码去加载 * 第二种方式是XML文件的形式，开发基本都会选择这种方式 * hibernate.cfg.xml * &lt;property name=&quot;hibernate.connection.driver_class&quot; &gt;com.mysql.jdbc.Driver&lt;/property&gt; * 优点 * 格式比较清晰 * 编写有提示 * 可以在该配置文件中加载映射的配置文件（最主要的） 2. 关于hibernate.cfg.xml的配置文件方式 * 必须有的配置 * 数据库连接信息: hibernate.connection.driver_class -- 连接数据库驱动程序 hibernate.connection.url -- 连接数据库URL hibernate.connection.username -- 数据库用户名 hibernate.connection.password -- 数据库密码 * 方言: hibernate.dialect -- 操作数据库方言 * 可选的配置 * hibernate.show_sql -- 显示SQL * hibernate.format_sql -- 格式化SQL * hibernate.hbm2ddl.auto -- 通过映射转成DDL语句 * create -- 每次都会创建一个新的表.---测试的时候 * create-drop -- 每次都会创建一个新的表,当执行结束之后,将创建的这个表删除.---测试的时候 * update -- 如果有表,使用原来的表.没有表,创建一个新的表.同时更新表结构. * validate -- 如果有表,使用原来的表.同时校验映射文件与表中字段是否一致如果不一致就会报错. * 加载映射 * 如果XML方式：&lt;mapping resource=&quot;cn/itcast/hibernate/domain/User.hbm.xml&quot; /&gt; 六.技术分析之Hibernate常用的接口和类1.Configuration类和作用1. Configuration类 * Configuration对象用于配置并且启动Hibernate。 * Hibernate应用通过该对象来获得对象-关系映射文件中的元数据，以及动态配置Hibernate的属性，然后创建SessionFactory对象。 * 简单一句话：加载Hibernate的配置文件，可以获取SessionFactory对象。 2. Configuration类的其他应用（了解） * 加载配置文件的种类，Hibernate支持xml和properties类型的配置文件，在开发中基本都使用XML配置文件的方式。 * 如果采用的是properties的配置文件，那么通过Configuration configuration = new Configuration();就可以假装配置文件 * 但是需要自己手动加载映射文件 * 例如：config.addResource(&quot;cn/itcast/domain/Student.hbm.xml&quot;); * 如果采用的XML的配置文件，通过Configuration configuration = new Configuration().configure();加载配置文件 2.SessionFactory(重要)1. 是工厂类，是生成Session对象的工厂类 2. SessionFactory类的特点 * 由Configuration通过加载配置文件创建该对象。 * SessionFactory对象中保存了当前的数据库配置信息和所有映射关系以及预定义的SQL语句。同时，SessionFactory还负责维护Hibernate的二级缓存。 * 预定义SQL语句 * 使用Configuration类创建了SessionFactory对象是，已经在SessionFacotry对象中缓存了一些SQL语句 * 常见的SQL语句是增删改查（通过主键来查询） * 这样做的目的是效率更高 * 一个SessionFactory实例对应一个数据库，应用从该对象中获得Session实例。 * SessionFactory是线程安全的，意味着它的一个实例可以被应用的多个线程共享。 * SessionFactory是重量级的，意味着不能随意创建或销毁它的实例。如果只访问一个数据库，只需要创建一个SessionFactory实例，且在应用初始化的时候完成。 * SessionFactory需要一个较大的缓存，用来存放预定义的SQL语句及实体的映射信息。另外可以配置一个缓存插件，这个插件被称之为Hibernate的二级缓存，被多线程所共享 3. 总结 * 一般应用使用一个SessionFactory,最好是应用启动时就完成初始化。 3.编写HibernateUtil的工具类1. 具体代码如下 public class HibernateUtil { private static final Configuration cfg; private static final SessionFactory factory; static{ // 给常量赋值 // 加载配置文件 cfg = new Configuration().configure(); // 生成factory对象 factory = cfg.buildSessionFactory(); } // 获取Session对象 public static Session openSession(){ return factory.openSession(); } } 4.Session接口1. 概述 * Session是在Hibernate中使用最频繁的接口。也被称之为持久化管理器。它提供了和持久化有关的操作，比如添加、修改、删除、加载和查询实体对象 * Session 是应用程序与数据库之间交互操作的一个单线程对象，是 Hibernate 运作的中心 * Session是线程不安全的 * 所有持久化对象必须在 session 的管理下才可以进行持久化操作 * Session 对象有一个一级缓存，显式执行 flush 之前，所有的持久化操作的数据都缓存在 session 对象处 * 持久化类与 Session 关联起来后就具有了持久化的能力 2. 特点 * 不是线程安全的。应避免多个线程使用同一个Session实例 * Session是轻量级的，它的创建和销毁不会消耗太多的资源。应为每次客户请求分配独立的Session实例 * Session有一个缓存，被称之为Hibernate的一级缓存。每个Session实例都有自己的缓存 3. 常用的方法 * save(obj) * delete(obj) * get(Class,id) * update(obj) * saveOrUpdate(obj) -- 保存或者修改（如果没有数据，保存数据。如果有，修改数据） * createQuery() -- HQL语句的查询的方式 5.Transaction接口1. Transaction是事务的接口 2. 常用的方法 * commit() -- 提交事务 * rollback() -- 回滚事务 3. 特点 * Hibernate框架默认情况下事务不自动提交.需要手动提交事务 * 如果没有开启事务，那么每个Session的操作，都相当于一个独立的事务 七.本阶段总结回忆：快速入门hibernate1. 下载Hibernate框架的开发包 2. 编写数据库和表结构 3. 创建WEB的项目，导入了开发的jar包 * MySQL驱动包、Hibernate开发的必须要有的jar包、日志的jar包 4. 编写JavaBean，以后不使用基本数据类型，使用包装类 5. 编写映射的配置文件（核心），先导入开发的约束，里面正常配置标签 6. 编写hibernate的核心的配置文件，里面的内容是固定的 7. 编写代码，使用的类和方法]]></content>
      <categories>
        <category>hibernate</category>
      </categories>
      <tags>
        <tag>hibernate</tag>
        <tag>hibernate入门篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle索引]]></title>
    <url>%2F2018%2F12%2F16%2Foracle-index%2F</url>
    <content type="text"><![CDATA[一.说明1）索引是数据库对象之一，用于加快数据的检索，类似于书籍的索引。在数据库中索引可以减少数据库程序查询结果时需要读取的数据量，类似于在书籍中我们利用索引可以不用翻阅整本书即可找到想要的信息。2）索引是建立在表上的可选对象；索引的关键在于通过一组排序后的索引键来取代默认的全表扫描检索方式，从而提高检索效率3）索引在逻辑上和物理上都与相关的表和数据无关，当创建或者删除一个索引时，不会影响基本的表；4）索引一旦建立，在表上进行DML操作时（例如在执行插入、修改或者删除相关操作时），oracle会自动管理索引，索引删除，不会对表产生影响5）索引对用户是透明的，无论表上是否有索引，sql语句的用法不变6）oracle创建主键时会自动在该列上创建索引二.索引原理1. 若没有索引，搜索某个记录时（例如查找name=’wish’）需要搜索所有的记录，因为不能保证只有一个wish，必须全部搜索一遍2. 若在name上建立索引，oracle会对全表进行一次搜索，将每条记录的name值哪找升序排列，然后构建索引条目（name和rowid），存储到索引段中，查询name为wish时即可直接查找对应地方3.创建了索引并不一定就会使用，oracle自动统计表的信息后，决定是否使用索引，表中数据很少时使用全表扫描速度已经很快，没有必要使用索引三.索引使用（创建、修改、删除、查看）1.创建索引语法CREATE [UNIQUE] | [BITMAP] INDEX index_name –unique表示唯一索引 ON table_name([column1 [ASC|DESC],column2 –bitmap，创建位图索引 [ASC|DESC],…] | [express]) [TABLESPACE tablespace_name] [PCTFREE n1] –指定索引在数据块中空闲空间 [STORAGE (INITIAL n2)] [NOLOGGING] –表示创建和重建索引时允许对表做DML操作，默认情况下不应该使用 [NOLINE] [NOSORT]; –表示创建索引时不进行排序，默认不适用，如果数据已经是按照该索引顺序排列的可以使用 2.修改索引1）重命名索引alter index index_sno rename to bitmap_index; 2) 合并索引（表使用一段时间后在索引中会产生碎片，此时索引效率会降低，可以选择重建索引或者合并索引,合并索引方式更好些，无需额外存储空间，代价较低）alter index index_sno coalesce; 3)重建索引方式一：删除原来的索引，重新建立索引 方式二： alter index index_sno rebuild; 3.删除索引drop index index_sno; 4.查看索引复制代码复制代码 select index_name,index-type, tablespace_name, uniqueness from all_indexes where table_name =’tablename’; – eg:create index index_sno on student(‘name’);select * from all_indexes where table_name=’student’; 四.索引分类1. B树索引（默认索引，保存讲过排序过的索引列和对应的rowid值）1）说明： 1.oracle中最常用的索引；B树索引就是一颗二叉树；叶子节点（双向链表）包含索引列和指向表中每个匹配行的ROWID值 2.所有叶子节点具有相同的深度，因而不管查询条件怎样，查询速度基本相同 3.能够适应精确查询、模糊查询和比较查询 2）分类： UNIQUE,NON-UNIQUE(默认),REVERSE KEY（数据列中的数据是反向存储的） 3）创建例子craete index index_sno on student(‘sno’); 4）适合使用场景： 列基数（列不重复值的个数）大时适合使用B数索引 2. 位图索引1）说明： 创建位图索引时，oracle会扫描整张表，并为索引列的每个取值建立一个位图（位图中，对表中每一行 使用一位（bit，0或者1）来标识该行是否包含该位图的索引列的取值，如果为1，表示对应的rowid所在的记录包含该位图索引列值），最后通过位图索 引中的映射函数完成位到行的ROWID的转换 2)创建例子create bitmap index index_sno on student(sno); 3) 适合场景：对于基数小的列适合简历位图索引（例如性别等） 3.单列索引和复合索引（基于多个列创建）注意： 即如果索引建立在多个列上，只有它的第一个列被where子句引用时，优化器才会使用该索引，即至少要包含组合索引的第一列 4. 函数索引1)说明： 1. 当经常要访问一些函数或者表达式时，可以将其存储在索引中，这样下次访问时，该值已经计算出来了，可以加快查询速度 2. 函数索引既可以使用B数索引，也可以使用位图索引；当函数结果不确定时采用B树索引，结果是固定的某几个值时使用位图索引 3. 函数索引中可以水泥用len、trim、substr、upper（每行返回独立结果），不能使用如sum、max、min、avg等 2）例子：create index fbi on student (upper(name)); select * from student where upper(name) =’WISH’; 五.索引建立原则总结1. 如果有两个或者以上的索引，其中有一个唯一性索引，而其他是非唯一，这种情况下oracle将使用唯一性索引而完全忽略非唯一性索引2. 至少要包含组合索引的第一列（即如果索引建立在多个列上，只有它的第一个列被where子句引用时，优化器才会使用该索引）3. 小表不要简历索引4. 对于基数大的列适合建立B树索引，对于基数小的列适合简历位图索引5. 列中有很多空值，但经常查询该列上非空记录时应该建立索引6. 经常进行连接查询的列应该创建索引7. 使用create index时要将最常查询的列放在最前面8. LONG（可变长字符串数据，最长2G）和LONG RAW（可变长二进制数据，最长2G）列不能创建索引9.限制表中索引的数量（创建索引耗费时间，并且随数据量的增大而增大；索引会占用物理空间；当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度）六.注意事项1. 通配符在搜索词首出现时，oracle不能使用索引，eg：复制代码复制代码 –我们在name上创建索引； create index index_name on student(‘name’); –下面的方式oracle不适用name索引 select * from student where name like ‘%wish%’; –如果通配符出现在字符串的其他位置时，优化器能够利用索引；如下： select * from student where name like ‘wish%’; 复制代码复制代码 2. 不要在索引列上使用not，可以采用其他方式代替如下：（oracle碰到not会停止使用索引，而采用全表扫描）复制代码复制代码 select * from student where not (score=100); select * from student where score &lt;&gt; 100; –替换为 select * from student where score&gt;100 or score &lt;100 复制代码复制代码 3. 索引上使用空值比较将停止使用索引， eg：select * from student where score is not null;]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
        <tag>oracle索引</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle 数据库 实例 用户 表空间 之间的关系（转）]]></title>
    <url>%2F2018%2F12%2F13%2Foracle-framework%2F</url>
    <content type="text"><![CDATA[数据库：Oracle数据库是数据的物理存储。这就包括（数据文件ORA或者DBF、控制文件、联机日志、参数文件）。其实Oracle数据库的概念和其它数据库不一样，这里的数据库是一个操作系统只有一个库。可以看作是Oracle就只有一个大数据库。 实例：一个Oracle实例（Oracle Instance）有一系列的后台进程（Backguound Processes)和内存结构（Memory Structures)组成。一个数据库可以有n个实例。 用户：用户是在实例下建立的。不同实例可以建相同名字的用户。 表空间：表空间是一个用来管理数据存储逻辑概念，表空间只是和数据文件（ORA或者DBF文件）发生关系，数据文件是物理的，一个表空间可以包含多个数据文件，而一个数据文件只能隶属一个表空间。 数据文件（dbf、ora）： 数据文件是数据库的物理存储单位。数据库的数据是存储在表空间中的，真 正是在某一个或者多个数据文件中。而一个表空间可以由一个或多个数据文件组成，一个数据文件只能属于一个表空间。一旦数据文件被加入到某个表空间后，就不能删除这个文件，如果要删除某个数据文件，只能删除其所属于的表空间才行。 注：表的数据，是有用户放入某一个表空间的，而这个表空间会随机把这些表数据放到一个或者多个数据文件中。由于oracle的数据库不是普通的概念，oracle是有用户和表空间对数据进行管理和存放的。但是表不是有表空间去查询的，而是由用户去查的。因为不同用户可以在同一个表空间建立同一个名字的表！这里区分就是用户了！ 关系示意图： 理解1：Oracle数据库可以创建多个实例，每个实例可以创建多个表空间，每个表空间下可以创建多个用户（同时用户也属于表空间对应的实例）和数据库文件，用户可以创建多个表（每个表随机存储在一个或多个数据库文件中），如下图：理解2：理解1MS有误。实例下有和，授权访问，是管理的，经授权在中创建，随机存储到不同的中。如下图所示：操作1：安装Oracle后会有默认的实例，即ORCL。一般不创建多个实例，在默认实例下创建表空间和用户等。 1，运行CMD进入DOS界面，首先输入：sqlplus，回车；再输入：sys/sys as sysdba，回车，即进入“SQL〉”操作状态。 2，输入：CREATE TABLESPACE 表空间名称 LOGGING DATAFILE ‘c:\表空间数据文件.ora’ SIZE 500M autoextend on next 200m maxsize 2048m;，表空间创建完成。 3，输入：CREATE USER 用户名称 PROFILE default IDENTIFIED BY 用户密码 DEFAULT TABLESPACE 授权访问的表空间名称 TEMPORARY TABLESPACE temp ACCOUNT UNLOCK;，用户创建完成，并授权用户访问某表空间。 具体操作如下图所示： 操作2： 创建表和插入数据，并查询浏览插入的数据。 1，创建表，输入： create table 表名( 字段名称1 字段类型, 字段名称2 字段类型, 字段名称3 字段类型 );，回车。 2，插入数据，输入：insert into 表名(字段1,字段2,字段3) VALUES (值1,值2,值3);，回车。 3，查询数据，输入：select * from 表名;，回车。 具体操作如下图所示： 基本操作流程1.创建数据表空间 create tablespace CICI logging datafile ‘D:\oraclexe\app\oracle\oradata\CICI\CICI.DBF’ size 32m autoextend on next 32m maxsize 2048m extent management local; 2.创建用户并指定表空间 CREATE USER cici IDENTIFIED BY cici PROFILE DEFAULT DEFAULT TABLESPACE CICI ACCOUNT UNLOCK; – 为用户赋予权限 GRANT connect, resource TO cici; grant create session to cici; 3.登录用户 sql&gt;conn 请输入用户名 cici 请输入密码 XXXXXX 4.建立表 create table aa(name varchar2(100),age number(4)); insert into aa values(‘wo’,29); 5.查询表 select * from cici.A;]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
        <tag>oracle结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle函数]]></title>
    <url>%2F2018%2F12%2F13%2Foracle-function%2F</url>
    <content type="text"><![CDATA[函数的分类: 单行函数分为五种类型：字符函数、数值函数、日期函数、转换函数、通用函数 单行函数:大小写控制函数select lower(‘Hello World’) 转小写, upper(‘Hello World’) 转大写 from dual;–initcap: 首字母大写select initcap(‘hello world’) 首字符大写 from dual; 字符控制函数concat: 字符连接函数, 等同于 ||select concat(‘Hello’,’ World’) from dual; substr:求母串中的某个子串select substr(‘Hello World’,3) from dual;select substr(‘Hello World’,3,4) from dual; length和lengthb: 字符数和字节数select length(‘China’) 字符数, lengthb(‘China’) 字节数 from dual; instr:在母串中，查找子串的位置select instr(‘Hello World’,’ll’) from dual; lpad,rpad: 左右填充,将abcd用*填充到10位select lpad(‘abcd’,10,’‘) 左填充, rpad(‘abcd’,10,’‘) 右填充 from dual; trim: 去掉字符串前后指定的字符select trim(‘H’ from ‘Hello WorldH’) from dual; replace:字符串替换函数select replace(‘Hello Wordl’,’l’,’*’) from dual; 数字函数select round(45.926,2) 四舍五入, trunc(45.926,2) 截断 ,mod(1600,300) 求于 from dual; ROUND函数select round(45.923,0) 整数位, round(45.923,-1) 十位,round(45.923,-2) 百位 from dual; 日期函数显示当前日期select sysdate from dual; 显示时间部分select to_char(sysdate,’yyyy-mm-dd hh24:mi:ss’) from dual; 显示昨天，今天和明天，加减数字仍未日期select sysdate-1 昨天, sysdate 今天, sysdate+1 明天 from dual; 两个日期相减，结果为相差的天数，查询员工信息，显示员工工龄。两个日期不能相加select empno,ename, sysdate-hiredate 天 from emp; 查询员工信息，显示员工工龄,分别按照天，星期，月显示select empno,ename,sysdate-hiredate 天,(sysdate-hiredate)/7 星期, (sysdate-hiredate)/30 月 from emp; months_between:两个日期相差的月数select (sysdate-hiredate)/30 方式一, months_between(sysdate,hiredate) 方式二 from emp; add_months:在指定日期上加上若干个月select add_months(sysdate,1) 下个月, add_months(sysdate,123) “123个月后” from dual last_day: 某个日期当月的最后一天select last_day(sysdate) from dual; next_day:下周六select next_day(sysdate,’星期五’) from dual; 对日期进行四舍五入select round(sysdate,’MONTH’) 月,round(sysdate,’YEAR’) from dual; 对日期进行截断select trunc(sysdate,’MONTH’) 月,trunc(sysdate,’YEAR’) from dual; 日期格式select * from emp where hiredate=to_date(‘1982-01-23’,’yyyy-mm-dd’); 查询当前日期：显示: 2011-09-17 15:12:15今天是星期六select to_char(sysdate,’yyyy-mm-dd hh24:mi:ss”今天是”day’) from dual; 查询员工信息，显示员工的编号，姓名，月薪,要求有货币代码(L)，千位符(,)，小数点(.),select empno,ename,to_char(sal,’L9,999.99’) from emp; 大小写控制函数select lower(‘Hello World’) 转小写, upper(‘Hello World’) 转大写 from dual; initcap: 首字母大写select initcap(‘hello world’) 首字符大写 from dual; 通用函数nvl(exp1,exp2):当exp1为空时，返回exp2nvl2(exp1,exp2,exp3):当exp1为空时，返回exp3；否则返回exp2select ename,sal*12+nvl2(comm,comm,0) 年收入 from emp; NULLIF (expr1, expr2),如果expr1=expr2,返回null;否则,返回expr1select nullif(‘abc’,’abc’) from dual;select nullif(‘abc’,’abcaa’) from dual; COALESCE :找到参数列表中，第一个不为空的值select ename,comm,sal,COALESCE(comm,sal) from emp; 例子:给员工涨工资,根据职位涨，总裁涨1000，经理涨600 其他人员涨400select ename,job,sal 涨前工资,case job when ‘PRESIDENT’ then sal+1000 when ‘MANAGER’ then sal+600 else sal+400 end 涨后工资from emp; select ename,job,sal 涨前工资, decode(job,’PRESIDENT’,sal+1000,’MANAGER’,sal+600,sal+400) 涨后工资 转换函数(Conversion Functions)转换函数将指定字符从一种类型转换为另一种，通常这类函数遵循如下惯例：函数名称后面跟着待转换类型以及输出类型。 TO_CHAR() 本函数又可以分三小类，分别是转换字符-&gt;字符TO_CHAR(c)：将nchar,nvarchar2,clob,nclob类型转换为char类型；例如：SELECT TO_CHAR(‘AABBCC’) FROM DUAL; 转换时间-&gt;字符TO_CHAR(d[,fmt])：将指定的时间(data,timestamp,timestamp with time zone)按照指定格式转换为varchar2类型；例如：SELECT TO_CHAR(sysdate,’yyyy-mm-dd hh24:mi:ss’) FROM DUAL; 转换数值-&gt;字符TO_CHAR(n[,fmt])：将指定数值n按照指定格式fmt转换为varchar2类型并返回；例如：SELECT TO_CHAR(-100, ‘L99G999D99MI’) FROM DUAL; TO_DATE(c[,fmt[,nls]]) 将char,nchar,varchar2,nvarchar2转换为日期类型，如果fmt参数不为空，则按照fmt中指定格式进行转换。注意这里的fmt参数。如果ftm为’J’则表示按照公元制(Julian day)转换，c则必须为大于0并小于5373484的正整数。例如：SELECT TO_DATE(2454336, ‘J’) FROM DUAL;SELECT TO_DATE(‘2007-8-23 23:25:00’, ‘yyyy-mm-dd hh24:mi:ss’) FROM DUAL; 为什么公元制的话，c的值必须不大于5373484呢？因为Oracle的DATE类型的取值范围是公元前4712年1月1日至公元9999年12月31日。看看下面这个语句：SELECT TO_CHAR(TO_DATE(‘9999-12-31’,’yyyy-mm-dd’),’j’) FROM DUAL; TO_NUMBER(c[,fmt[,nls]]) 将char,nchar,varchar2,nvarchar2型字串按照fmt中指定格式转换为数值类型并返回。例如：SELECT TO_NUMBER(‘-100.00’, ‘9G999D99’) FROM DUAL; 其它辅助函数(Miscellaneous Single-Row Functions)DECODE(exp,s1,r1,s2,r2..s,r[,def]) 可以把它理解成一个增强型的if else，只不过它并不通过多行语句，而是在一个函数内实现if else的功能。exp做为初始参数。s做为对比值，相同则返回r，如果s有多个，则持续遍历所有s，直到某个条件为真为止，否则返回默认值def(如果指定了的话)，如果没有默认值，并且前面的对比也都没有为真，则返回空。毫无疑问，decode是个非常重要的函数，在实现行转列等功能时都会用到，需要牢记和熟练使用。 例如：select decode(‘a2’,’a1’,’true1’,’a2’,’true2’,’default’) from dual; GREATEST(n1,n2,…n) 返回序列中的最大值例如：SELECT GREATEST(15,5,75,8) “Greatest” FROM DUAL; LEAST(n1,n2….n) 返回序列中的最小值例如：SELECT LEAST(15,5,75,8) LEAST FROM DUAL; NULLIF(c1,c2)Nullif也是个很有意思的函数。逻辑等价于：CASE WHEN c1 = c2 THEN NULL ELSE c1 END例如：SELECT NULLIF(‘a’,’b’),NULLIF(‘a’,’a’) FROM DUAL; NVL(c1,c2) 逻辑等价于IF c1 is null THEN c2 ELSE c1 END。c1,c2可以是任何类型。如果两者类型不同，则oracle会自动将c2转换为c1的类型。例如：SELECT NVL(null, ‘12’) FROM DUAL; NVL2(c1,c2,c3) 大家可能都用到nvl，但你用过nvl2吗？如果c1非空则返回c2,如果c1为空则返回c3例如：select nvl2(‘a’, ‘b’, ‘c’) isNull,nvl2(null, ‘b’, ‘c’) isNotNull from dual; SYS_CONNECT_BY_PATH(col,c) 该函数只能应用于树状查询。返回通过c1连接的从根到节点的路径。该函数必须与connect by 子句共同使用。多行函数和单行函数相比，oracle提供了丰富的基于组的，多行的函数。这些函数能在select或select的having子句中使用，当用于select子串时常常都和GROUP BY一起使用。多行函数分为接收多个输入，返回一个输出 求员工的工资总和select sum(sal) from emp; 求个数select count(*) from emp; 求平均工资select sum(sal)/count(*) 方式一, avg(sal) 方式二 from emp; 关于空值：组函数会自动滤空select count(*), count(comm) from emp; max和min：求最高工资和最低工资select max(sal) 最高工资,min(sal) 最低工资 from emp; 分组数据：求各个部门的平均工资select deptno,avg(sal) from emp group by deptno; group by作用于多列： 按部门，不同的工种，统计平均工资group by作用于多列：先按照第一列分组；如果相同，再按照第二列分组select deptno,job,avg(sal) from emp group by deptno,job; ：求部门的平均工资大于2000的部门select deptno,avg(sal) from emp group by deptno having avg(sal)&gt;2000; group by的增强select deptno,job,sum(sal) from emp group by rollup(deptno,job); 不同的deptno空两行/取消设置break on deptno skip 2/break on null 转载：https://blog.csdn.net/lailai186/article/]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
        <tag>oracle 函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle基本命令]]></title>
    <url>%2F2018%2F12%2F13%2Foracle-sql%2F</url>
    <content type="text"><![CDATA[一.ORACLE支持五种类型的完整性约束1.NOT NULL (非空)防止NULL值进入指定的列,在单列基础上定义,默认情况下,ORACLE允许在任何列中有NULL值. 2.CHECK (检查)检查在约束中指定的条件是否得到了满足. 3.UNIQUE (唯一)保证在指定的列中没有重复值.在该表中每一个值或者每一组值都将是唯一的. 4.PRIMARY KEY (主键)用来唯一的标识出表的每一行,并且防止出现NULL值,一个表只能有一个主键约束. 5.POREIGN KEY (外部键)通过使用公共列在表之间建立一种父子(parent-child)关系,在表上定义的外部键可以指向主键或者其他表的唯一键.ORACLE支持五种类型的完整性约束 二.基本命令创建表空间create tablespace schooltbs datafile ‘D:\oracle\datasource\schooltbs.dbf’ size 10M autoextend on; 删除表空间drop tablespace schooltbs[including contents and datafiles]; 查询表空间基本信息select *||tablespace_name from DBA_TABLESPACES; 创建用户create user lihua identified by lihua default tablespace schooltbs temporary tablespace temp; 更改用户alter user lihua identified by 123 default tablespace users; 锁定用户alter user lihua account lock|unlock; 删除用户drop user lihua cascade;–删除用户模式 oracle数据库中的角色connect,dba,select_catalog_role,delete_catalog_role,execute_catalog_role,exp_full_database,imp_full_database,resource 授予连接服务器的角色grant connect to lihua; 授予使用表空间的角色 grant resource to lihua with grant option;–该用户也有授权的权限 授予操作表的权限grant select,insert on user_tbl to scott;–当前用户 grant delete,update on lihua.user_tbl to scott;–系统管理员 修改表的结构(alter)Alter table 表名 add(列的名称,列的类型); 三.基本查询设置每行显示多少字符set linesize 300; 设置每页显示多少条记录set pagesize 30; 用户名的切换conn system/tiger Conn sys/change_on_install as sysdba(注意超级用户 在后面加as sysdba)在超级用户下查找普通用户的表是查不到的必须这样查找 如 select * from scott.emp(普通用户下的emp表) 查看当前是那个用户身份登录:show user; 查看有多少张表:select * from tab;(注意不同用户下的表是不同的) 查看表的结构:desc emp(emp为表名) 取出重复的列(DISTINCT):如 SELECT DISTINCT JOB EMP(去掉job的重复的值) 字符串的链接操作用:|| 查询有奖金的员工:select* from emp where comm is not null; 查询没有奖金的员工信息:select * from emp where comm is null; 两个条件以上就得用and 如查询工资大雨1500和有奖金的员 select * from emp where sal&gt;1500 and comm is not null; 表示两个条件有一个满足就可就用:or 如查询工资大于1500或者没有奖金的员工信息Select * from emp where sal&gt;1500 or comm is not null; 取反可以用not 如 查询员工工资不大于1500和有奖金的员工信息 如: Select * from emp where not (sal&gt;1500 or comm is not null); 在什么什么之间用between—-and—-如查询工资在1500和3000之间的员工信息:Select * from emp where sal between 1500 and 3000; 查询员工编号是2323, 4555, 2222的员工具体信息: 如Select * from emp where empno in(2323,4555,2222); 模糊查询 like 一般结合”%”和”“使用其中%:表示可以匹配任意长度的内容,”“表示匹配一个长度放入内容 如: 查询员工姓名中第二哥字母是M的员工信息:Select from emp where ename LIKE ‘_M%’;又如姓名中包含M的员工 Select from emp where ename LIKE ‘%M%’; oracle中不等于有两种表示方式 “&lt;&gt;”和”!=”排序用order by {asc desc}其中asc 是升序排列 如果不写就默认按升序排列desc是按降序排列 排序语句放在sal语句的最后如: 按员工工资进行排序Select from emp order by sal asc(升序)Selecct from emp order by sal desc(降序)Select * from emp where deptno=’10’ order by sal desc,hiredate asc;(查询部门10的员工工资的升序排列如果工资相等就按员工的入职时间排序) group by 用于对查询的结果进行分组统计: 显示每个部门的平均工资和最高工资 如:Select avg(sal),max(sal) from emp group by deptno; Having 子句用于限制分组显示结果: 显示平均工资大于2000的的部门号和他的平均工资?如:select avg(sal), deptno from emp group by deptno having avg(sal)&gt;2000; 四.锁和数据库对象1.锁数据库用来控制共享资源并发访问的机制。 锁的类型：行级锁，表级锁 行级锁：对正在被修改的行进行锁定。行级锁也被称之为排他锁。 在使用下列语句时，Oracle会自动应用行级锁： insert,update,delete,select…… for update select……for update允许用户一次锁定多条记录进行更新。 使用commit or rollback释放锁。 表级锁： lock table user_tbl in mode mode; 表级锁类型： 行共享 row share 行排他 row exclusive 共享 share 共享行排他 share row exclusive 排他 exclusive 死锁：两个或两个以上的事务相互等待对方释放资源，从而形成死锁 2.数据库对象 oracle数据库对象又称模式对象 数据库对象是逻辑结构的集合，最基本的数据库对象是表 数据库对象：表，序列，视图，索引 2.序列序列用于生成唯一，连续序号的对象。 创建语法： create sequence user_id_seq start with 1000 increment by 1 maxvalue 2000 minvalue 1000 nocycle cache 1000;–指定内存中预先分配的序号 访问序列： select user_id_seq.currval from dual; select user_id-seq.nextval from dual;更改删除序列： alter sequence user_id_seq maxvalue 10000;–不能修改其start with 值 drop sequence user_id_seq; 在Hibernate中访问序列： user_id_seq 3.视图视图以经过定制的方式显示来自一个或多个表的数据 创建视图： create or replace view user_tbl_view (vid,vname,vage) as select id,user_name,age from user_tbl [with check option]|[with read only]; 创建带有错误的视图： create force view user_tbl_force_view as select * from user_table;–此时user_table可以不存在 创建外联接视图： create view user_stu_view as select u.id,u.user_name,u.password,s.ddress from user_tbl u,stu_tbl s where u.s_id(+)=s.id;–哪一方带有(+)，哪一方就是次要的 删除视图： drop user_stu_view; 4.索引索引用于提高SQL语句执行的性能 索引类型： 唯一索引，位图索引，组合索引，基于函数的索引，反向键索引创建标准索引： create index user_id_index on user_tbl(id) tablespace schooltbs; 重建索引： alter index user_id_index rebuild; 删除索引： drop index user_id_index;创建唯一索引： create unique index user_id_index on user_tbl(id); 创建组合索引： create index name_pass_index on user_tbl(user_name,password); 创建反向键索引： create index user_id_index on user_tbl(id) reverse; 五.使用PL/SQL可用于创建存储过程，触发器，程序包，给SQL语句的执行添加程序逻辑。 支持SQL，在PL/SQL中可以使用：数据操纵命令 事务控制命令 游标控制 SQL函数和SQL运算符支持面向对象编程(OOP)可移植性更佳的性能，PL/SQL经过编译执行 分为三个部分：声明部分，可执行部分和异常处理部分 [declare declarations] begin executable statements [exception handlers] end;打开输出 set serverout on; 1.根据输入编号获取某学员的成绩–ifdeclarescore user_tbl.score%type;beginselect score into score from user_tbl where id=’&amp;id’;if score&gt;90 thendbms_output.put_line(‘优秀’);elsif score&gt;80 thendbms_output.put_line(‘良好’);elsif score&gt;60 thendbms_output.put_line(‘及格’);elsedbms_output.put_line(‘差’);end if;end; 2.根据学员姓名获取某学员的成绩–ifdeclarescore user_tbl.score%type;beginselect score into score from user_tbl where user_name=’&amp;name’;if score&gt;90 thendbms_output.put_line(‘优秀’);elsif score&gt;80 thendbms_output.put_line(‘良好’);elsif score&gt;60 thendbms_output.put_line(‘及格’);elsedbms_output.put_line(‘差’);end if;end; 3.case的使用declaregrade user_tbl.grade%type;beginselect grade into grade from user_tbl where id=’&amp;id’;case gradewhen ‘A’ then dbms_output.put_line(‘优异’);when ‘B’ then dbms_output.put_line(‘优秀’);when ‘C’ then dbms_output.put_line(‘良好’);else dbms_output.put_line(‘一般’);end case;end; 4.基本循环declarei number(4):=1;beginloopdbms_output.put_line(‘loop size:’||i);i:=i+1;exit when i&gt;10;end loop;end; 5.while循环declarei number(4):=1;beginwhile i&lt;=10 loopdbms_output.put_line(‘while loop size=’||i);i:=i+1;end loop;end; 6.for循环declarei number(4):=1;beginfor i in 1..10 loopdbms_output.put_line(‘for loop Size:’||i);end loop;end; declarei number(2):=1;j number(2):=1;beginfor i in reverse 1..9 loopfor j in 1..i loopdbms_output.put(j||’x’||i||’=’||j*i||’ ‘);end loop;dbms_output.put_line(‘’);end loop;end; 7.动态SQLdeclareuserId number(2);sql_str varchar2(100);userName user_tbl.user_name%type;beginexecute immediate ‘create table testExe(id number,test_name varchar2(20))’;userId:=’&amp;userId’;sql_str:=’select user_name from user_tbl where id=:id’;execute immediate sql_str into userName using userId;dbms_output.put_line(userName);end;(ordeclare id_param number:=’&amp;id_param’; sql_str varchar2(100); name_param stu_tbl.stu_name%type; begin sql_str:=’select stu_name from stu_tbl where id=:p’; execute immediate sql_str into name_param using id_param; dbms_output.put_line(name_param); end; /) 8.异常处理declaregrade number(4);begingrade:=’&amp;grade’;case gradewhen 1 then dbms_output.put_line(‘好的’);–else dbms_output.put_line(‘不好’);end case;exceptionwhen case_not_found thendbms_output.put_line(‘输入类型不匹配！’);end; 9.系统异常declarerowD user_tbl%rowtype;beginselect into rowD from user_tbl;dbms_output.put_line(rowD.id||’’||rowD.user_name||’ ‘||rowD.password);exceptionwhen too_many_rows thendbms_output.put_line(‘不能将多行赋予一个属性！’);end;ordeclarerowD user_tbl%rowtype;beginselect into rowD from user_tbl where id=5;dbms_output.put_line(rowD.id||’ ‘||rowD.user_name||’ ‘||rowD.password);exceptionwhen too_many_rows thendbms_output.put_line(‘不能将多行赋予一个属性！’);when no_data_found thendbms_output.put_line(‘没有您要查找的数据！’);end; 10.自定义错误declareinvalidError exception;category varchar2(20);begincategory:=’&amp;category’;if category not in(‘附件’,’顶盘’,’备件’) thenraise invalidError;elsedbms_output.put_line(‘您输入的类别是：’||category);end if;exceptionwhen invalidError thendbms_output.put_line(‘无法识别的类别！’);end; 11.引发应用程序异常declareapp_exception exception;grade user_tbl.grade%type;beginselect grade into grade from user_tbl where id=&id;if grade=’A’ thenraise app_exception;elsedbms_output.put_line(‘查询的等级为：’||grade);end if;exceptionwhen app_exception thenraise_application_error(-20001,’未知的等级！’);end;]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
        <tag>oracle sql</tag>
        <tag>oracle 命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis基础篇]]></title>
    <url>%2F2018%2F12%2F12%2Fredis1%2F</url>
    <content type="text"><![CDATA[redis介绍1.什么是NoSQL?NoSQL，泛指非关系型的数据库，NoSQL即Not-Only SQL，它可以作为关系型数据库的良好补充。随着互联网web2.0网站的兴起，非关系型的数据库现在成了一个极其热门的新领域，非关系数据库产品的发展非常迅速。而传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，例如： 1、High performance - 对数据库高并发读写的需求web2.0网站要根据用户个性化信息来实时生成动态页面和提供动态信息，所以基本上无法使用动态页面静态化技术，因此数据库并发负载非常高，往往要达到每秒上万次读写请求。关系数据库应付上万次SQL查询还勉强顶得住，但是应付上万次SQL写数据请求，硬盘IO就已经无法承受了。其实对于普通的BBS网站，往往也存在对高并发写请求的需求，例如网站的实时统计在线用户状态，记录热门帖子的点击次数，投票计数等，因此这是一个相当普遍的需求。 2、Huge Storage - 对海量数据的高效率存储和访问的需求类似Facebook，twitter，Friendfeed这样的SNS网站，每天用户产生海量的用户动态，以Friendfeed为例，一个月就达到了2.5亿条用户动态，对于关系数据库来说，在一张2.5亿条记录的表里面进行SQL查询，效率是极其低下乃至不可忍受的。再例如大型web网站的用户登录系统，例如腾讯，盛大，动辄数以亿计的帐号，关系数据库也很难应付。 3、High Scalability &amp;&amp; High Availability- 对数据库的高可扩展性和高可用性的需求在基于web的架构当中，数据库是最难进行横向扩展的，当一个应用系统的用户量和访问量与日俱增的时候，你的数据库却没有办法像web server和app server那样简单的通过添加更多的硬件和服务节点来扩展性能和负载能力。对于很多需要提供24小时不间断服务的网站来说，对数据库系统进行升级和扩展是非常痛苦的事情，往往需要停机维护和数据迁移，为什么数据库不能通过不断的添加服务器节点来实现扩展呢？ NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。 一些主流的NOSQL产品： NoSQL数据库的四大分类如下： 键值(Key-Value)存储数据库:相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB典型应用： 内容缓存，主要用于处理大量数据的高访问负载。数据模型： 一系列键值对优势： 快速查询劣势： 存储的数据缺少结构化 列存储数据库：相关产品：Cassandra, HBase, Riak典型应用：分布式的文件系统数据模型：以列簇式存储，将同一列数据存在一起优势：查找速度快，可扩展性强，更容易进行分布式扩展劣势：功能相对局限 文档型数据库：相关产品：CouchDB、MongoDB典型应用：Web应用（与Key-Value类似，Value是结构化的）数据模型： 一系列键值对 优势：数据结构要求不严格 劣势： 查询性能不高，而且缺乏统一的查询语法 图形(Graph)数据库：相关数据库：Neo4J、InfoGrid、Infinite Graph典型应用：社交网络数据模型：图结构优势：利用图结构相关算法。劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。 2.redis历史发展2008年，意大利的一家创业公司Merzia推出了一款基于MySQL的网站实时统计系统LLOOGG，然而没过多久该公司的创始人 Salvatore Sanfilippo便 对MySQL的性能感到失望，于是他决定亲自为LLOOGG量身定做一个数据库，并于2009年开发完成，这个数据库就是Redis。 不过Salvatore Sanfilippo并不满足只将Redis用于LLOOGG这一款产品，而是希望更多的人使用它，于是在同一年Salvatore Sanfilippo将Redis开源发布，并开始和Redis的另一名主要的代码贡献者Pieter Noordhuis一起继续着Redis的开发，直到今天。Salvatore Sanfilippo自己也没有想到，短短的几年时间，Redis就拥有了庞大的用户群体。Hacker News在2012年发布了一份数据库的使用情况调查，结果显示有近12%的公司在使用Redis。国内如新浪微博、街旁网、知乎网，国外如GitHub、Stack Overflow、Flickr等都是Redis的用户。 VMware公司从2010年开始赞助Redis的开发， Salvatore Sanfilippo和Pieter Noordhuis也分别在3月和5月加入VMware，全职开发Redis。 3.什么是redisRedis是用C语言开发的一个开源的高性能键值对（key-value）数据库。 它通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下： 字符串类型散列类型列表类型集合类型有序集合类型。3.4redis的应用场景缓存（数据查询、短连接、新闻内容、商品内容等等）。（最多使用）分布式集群架构中的session分离。聊天室的在线好友列表。任务队列。（秒杀、抢购、12306等等）应用排行榜。网站访问统计。数据过期处理（可以精确到毫秒） 4.测试环境redis需要安装在linux服务器上运行测试，本教程使用 linux虚拟机及ssh客户端进行功能测试。 4.1 虚拟机创建Centos6.4虚拟机作为linux服务器。 虚拟机ip：192.168.93.88 4.2 ssh客户端在开发环境(windows)安装ssh客户端，本教程使用SecureCRT作为ssh客户端连接虚拟机。 5.安装运行redis5.1redis安装环境redis是C语言开发，建议在linux上运行，本教程使用Centos6.4作为安装环境。 安装redis需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境， 需要安装gcc：yum install gcc-c++ 5.2redis安装版本说明 本教程使用redis3.0版本。3.0版本主要增加了redis集群功能。 源码下载 从官网下载 http://download.redis.io/releases/redis-3.0.0.tar.gz 将redis-3.0.0.tar.gz拷贝到/usr/local下 解压源码 tar -zxvf redis-3.0.0.tar.gz 进入解压后的目录进行编译 cd /usr/local/redis-3.0.0 make 安装到指定目录,如 /usr/local/redis cd /usr/local/redis-3.0.0 make PREFIX=/usr/local/redis install redis.conf redis.conf是redis的配置文件，redis.conf在redis源码目录。 注意修改port作为redis进程的端口,port默认6379。 拷贝配置文件到安装目录下 进入源码目录，里面有一份配置文件 redis.conf，然后将其拷贝到安装路径下 cd /usr/local/redis mkdir conf cp /usr/local/redis-3.0.0/redis.conf /usr/local/redis/bin 安装目录bin下的文件列表 redis3.0新增的redis-sentinel是redis集群管理工具可实现高可用。 5.3 redis启动5.3.1前端模式启动 直接运行bin/redis-server将以前端模式启动， 前端模式启动的缺点是ssh命令窗口关闭则redis-server程序结束， 不推荐使用此方法。 5.3.2后端模式启动 修改redis.conf配置文件， daemonize yes 以后端模式启动。 执行如下命令启动redis： cd /usr/local/redis ./bin/redis-server ./redis.conf redis默认使用6379端口。 也可更改redis.conf文件，修改端口号： 5.3.3启动多个redis进程 方法1： 启动时指定端口可在一台服务器启动多个redis进程。 cd /usr/local/redis/bin ./redis-server ./redis.conf --port 6380 方法2(推荐此方法)： 创建多个redis目录，以端口号命名，比如：创建6379、6380两个目录， redis的安装文件bin和conf拷贝至这两个目录。 修改6379目录下的redis.conf设置端口号为6379 修改6380目录下的redis.conf设置端口号为6380 启动6379和6380目录下的redis-server程序： cd 6379 ./redis-server . /redis.conf cd 6380 ./redis-server . /redis.conf 查询当前redis的进程： ps aux | grep redis 5.4redis停止强行终止Redis进程可能会导致redis持久化数据丢失。 正确停止Redis的方式应该是向Redis发送SHUTDOWN命令， 方法为： cd /usr/local/redis ./bin/redis-cli shutdown 5.5redis客户端在redis的安装目录中有redis的客户端，即redis-cli（Redis Command Line Interface）， 它是Redis自带的基于命令行的Redis客户端。 5.5.1连接redis服务端 执行bin/redis-cli连接redis服务端： 从上图得知redis-cli默认连接本机的redis，本机的redis没有启动则报上图中的错误。 指定连接redis服务的ip和端口： 5.5.2向redis服务端发送命令 redis-cli连上redis服务后，可以在命令行发送命令。 ping Redis提供了PING命令来测试客户端与Redis的连接是否正常，如果连接正常会收到回复PONG set/get 使用set和get可以向redis设置数据、获取数据。 del 删除指定key的内容。 例如：del name Keys * 查看当前库中所有的key值 5.6redis多数据库5.6.1redis实例 一个redis进程就是一个redis实例，一台服务器可以同时有多个redis实例， 不同的redis实例提供不同的服务端口对外提供服务，每个redis实例之间互相影响。 每个redis实例都包括自己的数据库，数据库中可以存储自己的数据。 5.6.2多数据库测试 一个Redis实例可以包括多个数据库，客户端可以指定连接某个redis实例的哪个数据库， 就好比一个mysql中创建多个数据库，客户端连接时指定连接哪个数据库。 一个redis实例最多可提供16个数据库，下标从0到15，客户端默认连接第0号数据库， 也可以通过select选择连接哪个数据库，如下连接1号库： 在1号库中查询上节设置的数据，结果查询不到： 重新选择第0号数据库，查询数据： 如果选择一个不存在数据库则会报错： 注意：redis不支持修改数据库的名称，只能通过select 0、select 1...选择数据库。 5.6.3注意问题 在0号数据库存储数据，在1号数据库执行清空数据命令却把0号数据库的数据给清空了： 建议：不同的应用系统要使用不同的redis实例而不是使用同一个redis实例下的不同数据库。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>非关系型数据库</tag>
        <tag>数据库</tag>
        <tag>缓存数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis完善(spring整合)篇]]></title>
    <url>%2F2018%2F12%2F12%2Fredis4%2F</url>
    <content type="text"><![CDATA[jedisjedis介绍Redis不仅是使用命令来操作，现在基本上主流的语言都有客户端支持，比如java、C、C#、C++、php、Node.js、Go等。在官方网站里列一些Java的客户端，有Jedis、Redisson、Jredis、JDBC-Redis、等其中官方推荐使用Jedis和Redisson。 在企业中用的最多的就是Jedis，下面我们就重点学习下Jedis。Jedis同样也是托管在github上，地址：https://github.com/xetorthio/jedis 通过jedis连接redis单机jar包pom坐标： &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; 单实例连接通过创建单实例jedis对象连接redis服务，如下代码： // 单实例连接redis @Test public void testJedisSingle() { Jedis jedis = new Jedis(&quot;192.168.101.3&quot;, 6379); jedis.set(&quot;name&quot;, &quot;bar&quot;); String name = jedis.get(&quot;name&quot;); System.out.println(name); jedis.close(); } 连接超时解决由于linux防火墙默认开启，redis的服务端口6379并不在开放规则之内，所有需要将此端口开放访问或者关闭防火墙。 关闭防火墙命令： sevice iptables stop 如果是修改防火墙规则，可以修改： /etc/sysconfig/iptables文件 使用连接池连接通过单实例连接redis不能对redis连接进行共享，可以使用连接池对redis连接进行共享，提高资源利用率，使用jedisPool连接redis服务，如下代码： @Test public void pool() { JedisPoolConfig config = new JedisPoolConfig(); //最大连接数 config.setMaxTotal(30); //最大连接空闲数 config.setMaxIdle(2); JedisPool pool = new JedisPool(config, &quot;192.168.101.3&quot;, 6379); Jedis jedis = null; try { jedis = pool.getResource(); jedis.set(&quot;name&quot;, &quot;lisi&quot;); String name = jedis.get(&quot;name&quot;); System.out.println(name); }catch(Exception ex){ ex.printStackTrace(); }finally{ if(jedis != null){ //关闭连接 jedis.close(); } } } jedis与spring整合配置spring配置文件applicationContext.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd &quot;&gt; 连接池配置 &lt;bean id=&quot;jedisPoolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt; &lt;!-- 最大连接数 --&gt; &lt;property name=&quot;maxTotal&quot; value=&quot;30&quot; /&gt; &lt;!-- 最大空闲连接数 --&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;10&quot; /&gt; &lt;!-- 每次释放连接的最大数目 --&gt; &lt;property name=&quot;numTestsPerEvictionRun&quot; value=&quot;1024&quot; /&gt; &lt;!-- 释放连接的扫描间隔（毫秒） --&gt; &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;30000&quot; /&gt; &lt;!-- 连接最小空闲时间 --&gt; &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;1800000&quot; /&gt; &lt;!-- 连接空闲多久后释放, 当空闲时间&gt;该值 且 空闲连接&gt;最大空闲连接数 时直接释放 --&gt; &lt;property name=&quot;softMinEvictableIdleTimeMillis&quot; value=&quot;10000&quot; /&gt; &lt;!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 --&gt; &lt;property name=&quot;maxWaitMillis&quot; value=&quot;1500&quot; /&gt; &lt;!-- 在获取连接的时候检查有效性, 默认false --&gt; &lt;property name=&quot;testOnBorrow&quot; value=&quot;true&quot; /&gt; &lt;!-- 在空闲时检查有效性, 默认false --&gt; &lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot; /&gt; &lt;!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true --&gt; &lt;property name=&quot;blockWhenExhausted&quot; value=&quot;false&quot; /&gt; &lt;/bean&gt; &lt;!-- redis单机 通过连接池 --&gt; &lt;bean id=&quot;jedisPool&quot; class=&quot;redis.clients.jedis.JedisPool&quot; destroy-method=&quot;close&quot;&gt; &lt;constructor-arg name=&quot;poolConfig&quot; ref=&quot;jedisPoolConfig&quot;/&gt; &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.145&quot;/&gt; &lt;constructor-arg name=&quot;port&quot; value=&quot;6379&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; 测试代码： private ApplicationContext applicationContext; @Before public void init() { applicationContext = new ClassPathXmlApplicationContext( &quot;classpath:applicationContext.xml&quot;); } @Test public void testJedisPool() { JedisPool pool = (JedisPool) applicationContext.getBean(&quot;jedisPool&quot;); try { Jedis jedis = pool.getResource(); jedis.set(&quot;name&quot;, &quot;lisi&quot;); String name = jedis.get(&quot;name&quot;); System.out.println(name); }catch(Exception ex){ ex.printStackTrace(); }finally{ if(jedis != null){ //关闭连接 jedis.close(); } } }]]></content>
      <categories>
        <category>spring-redis</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>redis</tag>
        <tag>非关系型数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis进阶篇]]></title>
    <url>%2F2018%2F12%2F12%2Fredis2%2F</url>
    <content type="text"><![CDATA[数据类型–stringredis string介绍redis中没有使用C语言的字符串表示，而是自定义一个数据结构叫SDS（simple dynamic string）即简单动态字符串。打开下载的redis源码包，找到src下的sds.h文件查看sds源码： struct sdshdr { //字符串长度 unsigned int len; //buf数组中未使用的字节数量 unsigned int free; //用于保存字符串 char buf[]; }; c语言对字符串的存储是使用字符数组，遇到’\0’字符则认为字符串结束，redis的字符串可以存储任何类型的数据，因为任何类型数据都可以表示成二进制，sds结构中的char buf[]就是存储了二进制数据。redis的字符串是二进制安全的，什么是二进制安全？简单理解就是存入什么数据取出的还是什么数据。redis中的sds不像c语言处理字符串那样遇到’\0’字符则认证字符串结束，它不会对存储进去的二进制数据进行处理，存入什么数据取出还是什么数据。 命令赋值SET key value: 127.0.0.1:6379&gt; set test 123 OK 取值：GET key: 127.0.0.1:6379&gt; get test &quot;123“ 当键不存在时返回空结果。 删除Del key: 127.0.0.1:6379&gt; del test (integer) 1 数值增减递增数字 INCR key: 当存储的字符串是整数时，Redis提供了一个实用的命令INCR，其作用是让当前键值递增，并返回递增后的值。 127.0.0.1:6379&gt; incr num (integer) 1 127.0.0.1:6379&gt; incr num (integer) 2 127.0.0.1:6379&gt; incr num (integer) 3 增加指定的整数 INCRBY key increment: 127.0.0.1:6379&gt; incrby num 2 (integer) 5 127.0.0.1:6379&gt; incrby num 2 (integer) 7 127.0.0.1:6379&gt; incrby num 2 (integer) 9 递减数值: DECR key 其它命令减少指定的整数 :DECRBY key decrement 127.0.0.1:6379&gt; decr num (integer) 6 127.0.0.1:6379&gt; decr num (integer) 5 127.0.0.1:6379&gt; decrby num 3 (integer) 2 127.0.0.1:6379&gt; decrby num 3 (integer) -1 向尾部追加值 :APPEND key valueAPPEND的作用是向键值的末尾追加value。如果键不存在则将该键的值设置为value，即相当于 SET key value。返回值是追加后字符串的总长度。 127.0.0.1:6379&gt; set str hello OK 127.0.0.1:6379&gt; append str &quot; world!&quot; (integer) 12 127.0.0.1:6379&gt; get str &quot;hello world!&quot; 获取字符串长度 :STRLEN keySTRLEN命令返回键值的长度，如果键不存在则返回0。 127.0.0.1:6379&gt; strlen str (integer) 0 127.0.0.1:6379&gt; set str hello OK 127.0.0.1:6379&gt; strlen str (integer) 5 同时设置/获取多个键值 :MSET key value [key value …]MGET key [key …] 127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3 OK 127.0.0.1:6379&gt; get k1 &quot;v1&quot; 127.0.0.1:6379&gt; mget k1 k3 1) &quot;v1&quot; 2) &quot;v3&quot; 应用自增主键商品编号、订单号采用string的递增数字特性生成。 定义商品编号key：items:id 192.168.101.3:7003&gt; INCR items:id (integer) 2 192.168.101.3:7003&gt; INCR items:id (integer) 3 数据类型–hash使用string的问题假设有User对象以JSON序列化的形式存储到Redis中，User对象有id，username、password、age、name等属性，存储的过程如下： 保存、更新： User对象 json(string) redis 如果在业务上只是更新age属性，其他的属性并不做更新我应该怎么做呢？ 如果仍然采用上边的方法在传输、处理时会造成资源浪费，下边讲的hash可以很好的解决这个问题。 redis hash介绍hash叫散列类型，它提供了字段和字段值的映射。字段值只能是字符串类型，不支持散列类型、集合类型等其它类型。如下： 命令赋值HSET key field value 一次只能设置一个字段值 127.0.0.1:6379&gt; hset user username zhangsan (integer) 1 HMSET key field value [field value …] 一次可以设置多个字段值 127.0.0.1:6379&gt; hmset user age 20 username lisi OK 取值HGET key field 一次只能获取一个字段值 127.0.0.1:6379&gt; hget user username &quot;zhangsan“ HMGET key field [field …] 一次可以获取多个字段值 127.0.0.1:6379&gt; hmget user age username 1) &quot;20&quot; 2) &quot;lisi&quot; HGETALL key 127.0.0.1:6379&gt; hgetall user 1) &quot;age&quot; 2) &quot;20&quot; 3) &quot;username&quot; 4) &quot;lisi&quot; HSET命令不区分插入和更新操作，当执行插入操作时HSET命令返回1，当执行更新操作时返回0. 删除字段可以删除一个或多个字段，返回值是被删除的字段个数HDEL key field [field …] 127.0.0.1:6379&gt; hdel user age (integer) 1 127.0.0.1:6379&gt; hdel user age name (integer) 0 127.0.0.1:6379&gt; hdel user age username (integer) 1 增加数字HINCRBY key field increment 127.0.0.1:6379&gt; hincrby user age 2 将用户的年龄加2 (integer) 22 127.0.0.1:6379&gt; hget user age 获取用户的年龄 &quot;22“ 其它命令判断字段是否存在HEXISTS key field 127.0.0.1:6379&gt; hexists user age 查看user中是否有age字段 (integer) 1 127.0.0.1:6379&gt; hexists user name 查看user中是否有name字段 (integer) 0 HSETNX key field value 当字段不存在时赋值，类似HSET，区别在于如果字段已经存在，该命令不执行任何操作。 127.0.0.1:6379&gt; hsetnx user age 30 如果user中没有age字段则设置age值为30，否则不做任何操作 (integer) 0 只获取字段名或字段值 HKEYS key HVALS key 127.0.0.1:6379&gt; hmset user age 20 name lisi OK 127.0.0.1:6379&gt; hkeys user 1) &quot;age&quot; 2) &quot;name&quot; 127.0.0.1:6379&gt; hvals user 1) &quot;20&quot; 2) &quot;lisi&quot; 获取字段数量HLEN key 127.0.0.1:6379&gt; hlen user (integer) 2 应用商品信息商品id、商品名称、商品描述、商品库存、商品好评 定义商品信息的key：商品1001的信息在 redis中的key为：items:1001 存储商品信息: 192.168.101.3:7003&gt; HMSET items:1001 id 3 name apple price 999.9 OK 获取商品信息: 192.168.101.3:7003&gt; HGET items:1001 id &quot;3&quot; .168.101.3:7003&gt; HGETALL items:1001 1) &quot;id&quot; 2) &quot;3&quot; 3) &quot;name&quot; 4) &quot;apple&quot; 5) &quot;price&quot; 6) &quot;999.9&quot; 数据类型–listArrayList与LinkedList的区别ArrayList使用数组方式存储数据，所以根据索引查询数据速度快，而新增或者删除元素时需要设计到位移操作，所以比较慢。LinkedList使用双向链接方式存储数据，每个元素都记录前后元素的指针，所以插入、删除数据时只是更改前后元素的指针指向即可，速度非常快，然后通过下标查询元素时需要从头开始索引，所以比较慢，但是如果查询前几个元素或后几个元素速度比较快。 redis list介绍列表类型（list）可以存储一个有序的字符串列表，常用的操作是向列表两端添加元素，或者获得列表的某一个片段。列表类型内部是使用双向链表（double linked list）实现的，所以向列表两端添加元素的时间复杂度为0(1)，获取越接近两端的元素速度就越快。这意味着即使是一个有几千万个元素的列表，获取头部或尾部的10条记录也是极快的。 命令向列表两端增加元素。LPUSH key value [value …] RPUSH key value [value …] 向列表左边增加元素 127.0.0.1:6379&gt; lpush list:1 1 2 3 (integer) 3 向列表右边增加元素 127.0.0.1:6379&gt; rpush list:1 4 5 6 (integer) 3 查看列表LRANGE key start stop LRANGE命令是列表类型最常用的命令之一，获取列表中的某一片段，将返回start、stop之间的所有元素（包含两端的元素），索引从0开始。索引可以是负数，如：“-1”代表最后边的一个元素。 127.0.0.1:6379&gt; lrange list:1 0 2 1) &quot;2&quot; 2) &quot;1&quot; 3) &quot;4&quot; 从列表两端弹出元素LPOP key RPOP key LPOP命令从列表左边弹出一个元素，会分两步完成，第一步是将列表左边的元素从列表中移除，第二步是返回被移除的元素值。 127.0.0.1:6379&gt; lpop list:1 &quot;3“ 127.0.0.1:6379&gt; rpop list:1 &quot;6“ 获取列表中元素的个数LLEN key 127.0.0.1:6379&gt; llen list:1 (integer) 2 ####其它命令删除列表中指定的值 : LREM key count value LREM命令会删除列表中前count个值为value的元素，返回实际删除的元素个数。根据count值的不同， 该命令的执行方式会有所不同： 当count&gt;0时， LREM会从列表左边开始删除。 当count&lt;0时， LREM会从列表后边开始删除。 当count=0时， LREM删除所有值为value的元素。 获得/设置指定索引的元素值 : LINDEX key index LSET key index value 127.0.0.1:6379&gt; lindex l:list 2 &quot;1&quot; 127.0.0.1:6379&gt; lset l:list 2 2 OK 127.0.0.1:6379&gt; lrange l:list 0 -1 1) &quot;6&quot; 2) &quot;5&quot; 3) &quot;2&quot; 4) &quot;2&quot; 只保留列表指定片段，指定范围和LRANGE一致 : LTRIM key start stop 127.0.0.1:6379&gt; lrange l:list 0 -1 1) &quot;6&quot; 2) &quot;5&quot; 3) &quot;0&quot; 4) &quot;2&quot; 127.0.0.1:6379&gt; ltrim l:list 0 2 OK 127.0.0.1:6379&gt; lrange l:list 0 -1 1) &quot;6&quot; 2) &quot;5&quot; 3) &quot;0&quot; 向列表中插入元素 : LINSERT key BEFORE|AFTER pivot value该命令首先会在列表中从左到右查找值为pivot的元素，然后根据第二个参数是BEFORE还是AFTER来决定将value插入到该元素的前面还是后面。 127.0.0.1:6379&gt; lrange list 0 -1 1) &quot;3&quot; 2) &quot;2&quot; 3) &quot;1&quot; 127.0.0.1:6379&gt; linsert list after 3 4 (integer) 4 127.0.0.1:6379&gt; lrange list 0 -1 1) &quot;3&quot; 2) &quot;4&quot; 3) &quot;2&quot; 4) &quot;1&quot; 将元素从一个列表转移到另一个列表中 : RPOPLPUSH source destination 127.0.0.1:6379&gt; rpoplpush list newlist &quot;1&quot; 127.0.0.1:6379&gt; lrange newlist 0 -1 1) &quot;1&quot; 127.0.0.1:6379&gt; lrange list 0 -1 1) &quot;3&quot; 2) &quot;4&quot; 3) &quot;2&quot; 应用商品评论列表思路： 在redis中创建商品评论列表 用户发布商品评论，将评论信息转成json存储到list中。 用户在页面查询评论列表，从redis中取出json数据展示到页面。 定义商品评论列表key： 商品编号为1001的商品评论key：items: comment:1001 192.168.101.3:7001&gt; LPUSH items:comment:1001 &apos;{&quot;id&quot;:1,&quot;name&quot;:&quot;商品不错，很好！！&quot;,&quot;date&quot;:1430295077289}&apos; 数据类型–setredis set介绍在集合中的每个元素都是不同的，且没有顺序。 集合类型和列表类型的对比： 集合类型的常用操作是向集合中加入或删除元素、判断某个元素是否存在等，由于集合类型的Redis内部是使用值为空的散列表实现，所有这些操作的时间复杂度都为0(1)。 Redis还提供了多个集合之间的交集、并集、差集的运算。 ###命令 增加/删除元素SADD key member [member …] SREM key member [member …] 127.0.0.1:6379&gt; sadd set a b c (integer) 3 127.0.0.1:6379&gt; sadd set a (integer) 0 127.0.0.1:6379&gt; srem set c d (integer) 1 获得集合中的所有元素SMEMBERS key 127.0.0.1:6379&gt; smembers set 1) &quot;b&quot; 2) &quot;a” 判断元素是否在集合中，无论集合中有多少元素都可以极速的返回结果。 SISMEMBER key member 127.0.0.1:6379&gt; sismember set a (integer) 1 127.0.0.1:6379&gt; sismember set h (integer) 0 其它命令集合的差集运算 A-B属于A并且不属于B的元素构成的集合。 SDIFF key [key …] 127.0.0.1:6379&gt; sadd setA 1 2 3 (integer) 3 127.0.0.1:6379&gt; sadd setB 2 3 4 (integer) 3 127.0.0.1:6379&gt; sdiff setA setB 1) &quot;1&quot; 127.0.0.1:6379&gt; sdiff setB setA 1) &quot;4&quot; 集合的交集运算 A ∩ B属于A且属于B的元素构成的集合。 SINTER key [key …] 127.0.0.1:6379&gt; sinter setA setB 1) &quot;2&quot; 2) &quot;3&quot; 集合的并集运算 A ∪ B属于A或者属于B的元素构成的集合 SUNION key [key …] 127.0.0.1:6379&gt; sunion setA setB 1) &quot;1&quot; 2) &quot;2&quot; 3) &quot;3&quot; 4) &quot;4&quot; 其它命令获得集合中元素的个数 SCARD key 127.0.0.1:6379&gt; smembers setA 1) &quot;1&quot; 2) &quot;2&quot; 3) &quot;3&quot; 127.0.0.1:6379&gt; scard setA (integer) 3 从集合中弹出一个元素 SPOP key 127.0.0.1:6379&gt; spop setA &quot;1“ 注意：由于集合是无序的，所有SPOP命令会从集合中随机选择一个元素弹出 数据类型–sorted setredis sorted set介绍在集合类型的基础上有序集合类型为集合中的每个元素都关联一个分数，这使得我们不仅可以完成插入、删除和判断元素是否存在在集合中，还能够获得分数最高或最低的前N个元素、获取指定分数范围内的元素等与分数有关的操作。 在某些方面有序集合和列表类型有些相似。 1、二者都是有序的。 2、二者都可以获得某一范围的元素。 但是，二者有着很大区别： 1、列表类型是通过链表实现的，获取靠近两端的数据速度极快，而当元素增多后，访问中间数据的速度会变慢。 2、有序集合类型使用散列表实现，所有即使读取位于中间部分的数据也很快。 3、列表中不能简单的调整某个元素的位置，但是有序集合可以（通过更改分数实现）4、有序集合要比列表类型更耗内存。 ###命令 ####增加元素向有序集合中加入一个元素和该元素的分数，如果该元素已经存在则会用新的分数替换原有的分数。返回值是新加入到集合中的元素个数，不包含之前已经存在的元素。 ZADD key score member [score member …] 127.0.0.1:6379&gt; zadd scoreboard 80 zhangsan 89 lisi 94 wangwu (integer) 3 127.0.0.1:6379&gt; zadd scoreboard 97 lisi (integer) 0 获取元素的分数 ZSCORE key member 127.0.0.1:6379&gt; zscore scoreboard lisi &quot;97&quot; 删除元素ZREM key member [member …] 移除有序集key中的一个或多个成员，不存在的成员将被忽略。 当key存在但不是有序集类型时，返回一个错误。 127.0.0.1:6379&gt; zrem scoreboard lisi (integer) 1 获得排名在某个范围的元素列表获得排名在某个范围的元素列表 ZRANGE key start stop [WITHSCORES]照元素分数从小到大的顺序返回索引从start到stop之间的所有元素（包含两端的元素） 127.0.0.1:6379&gt; zrange scoreboard 0 2 1) &quot;zhangsan&quot; 2) &quot;wangwu&quot; 3) &quot;lisi“ ZREVRANGE key start stop [WITHSCORES]照元素分数从大到小的顺序返回索引从start到stop之间的所有元素（包含两端的元素） 127.0.0.1:6379&gt; zrevrange scoreboard 0 2 1) &quot; lisi &quot; 2) &quot;wangwu&quot; 3) &quot; zhangsan “ 如果需要获得元素的分数的可以在命令尾部加上WITHSCORES参数 127.0.0.1:6379&gt; zrange scoreboard 0 1 WITHSCORES 1) &quot;zhangsan&quot; 2) &quot;80&quot; 3) &quot;wangwu&quot; 4) &quot;94&quot; 其它命令获得指定分数范围的元素 ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] 127.0.0.1:6379&gt; ZRANGEBYSCORE scoreboard 90 97 WITHSCORES 1) &quot;wangwu&quot; 2) &quot;94&quot; 3) &quot;lisi&quot; 4) &quot;97&quot; 127.0.0.1:6379&gt; ZRANGEBYSCORE scoreboard 70 100 limit 1 2 1) &quot;wangwu&quot; 2) &quot;lisi&quot; 增加某个元素的分数，返回值是更改后的分数 ZINCRBY key increment member 给lisi加4分 127.0.0.1:6379&gt; ZINCRBY scoreboard 4 lisi &quot;101“ 获得集合中元素的数量 ZCARD key 127.0.0.1:6379&gt; ZCARD scoreboard (integer) 3 获得指定分数范围内的元素个数 ZCOUNT key min max 127.0.0.1:6379&gt; ZCOUNT scoreboard 80 90 (integer) 1 按照排名范围删除元素 ZREMRANGEBYRANK key start stop 127.0.0.1:6379&gt; ZREMRANGEBYRANK scoreboard 0 1 (integer) 2 127.0.0.1:6379&gt; ZRANGE scoreboard 0 -1 1) &quot;lisi&quot; ZREMRANGEBYSCORE key min max 按照分数范围删除元素 127.0.0.1:6379&gt; zadd scoreboard 84 zhangsan (integer) 1 127.0.0.1:6379&gt; ZREMRANGEBYSCORE scoreboard 80 100 (integer) 1 获取元素的排名 ZRANK key member ZREVRANK key member 从小到大 127.0.0.1:6379&gt; ZRANK scoreboard lisi (integer) 0 从大到小 127.0.0.1:6379&gt; ZREVRANK scoreboard zhangsan (integer) 1 应用商品销售排行榜根据商品销售量对商品进行排行显示，定义sorted set集合，商品销售量为元素的分数。 定义商品销售排行榜key：items:sellsort 写入商品销售量： 商品编号1001的销量是9，商品编号1002的销量是10 192.168.101.3:7007&gt; ZADD items:sellsort 9 1001 10 1002 商品编号1001的销量加1 192.168.101.3:7001&gt; ZINCRBY items:sellsort 1 1001 商品销量前10名： 192.168.101.3:7001&gt; ZRANGE items:sellsort 0 9 withscores keys命令###设置key的生存时间Redis在实际使用过程中更多的用作缓存，然而缓存的数据一般都是需要设置生存时间的，即：到期后数据销毁。 EXPIRE key seconds 设置key的生存时间（单位：秒）key在多少秒后会自动删除 TTL key 查看key生于的生存时间 PERSIST key 清除生存时间 PEXPIRE key milliseconds 生存时间设置单位为：毫秒 例子： 192.168.101.3:7002&gt; set test 1 设置test的值为1 OK 192.168.101.3:7002&gt; get test 获取test的值 &quot;1&quot; 192.168.101.3:7002&gt; EXPIRE test 5 设置test的生存时间为5秒 (integer) 1 192.168.101.3:7002&gt; TTL test 查看test的生于生成时间还有1秒删除 (integer) 1 192.168.101.3:7002&gt; TTL test (integer) -2 192.168.101.3:7002&gt; get test 获取test的值，已经删除 (nil) 其它命令（自学）keys 返回满足给定pattern 的所有key redis 127.0.0.1:6379&gt; keys mylist* 1) &quot;mylist&quot; 2) &quot;mylist5&quot; 3) &quot;mylist6&quot; 4) &quot;mylist7&quot; 5) &quot;mylist8&quot; exists 确认一个key 是否存在 redis 127.0.0.1:6379&gt; exists HongWan (integer) 0 redis 127.0.0.1:6379&gt; exists age (integer) 1 redis 127.0.0.1:6379&gt; 从结果来数据库中不存在HongWan 这个key，但是age 这个key 是存在的 del删除一个key redis 127.0.0.1:6379&gt; del age (integer) 1 redis 127.0.0.1:6379&gt; exists age (integer) 0 redis 127.0.0.1:6379&gt; 从结果来数据库中不存在HongWan 这个key，但是age 这个key 是存在的 rename 重命名key redis 127.0.0.1:6379[1]&gt; keys * 1) &quot;age&quot; redis 127.0.0.1:6379[1]&gt; rename age age_new OK redis 127.0.0.1:6379[1]&gt; keys * 1) &quot;age_new&quot; redis 127.0.0.1:6379[1]&gt; age 成功的被我们改名为age_new 了 type返回值的类型 redis 127.0.0.1:6379&gt; type addr string redis 127.0.0.1:6379&gt; type myzset2 zset redis 127.0.0.1:6379&gt; type mylist list redis 127.0.0.1:6379&gt; ##服务器命令 ping测试连接是否存活 redis 127.0.0.1:6379&gt; ping PONG //执行下面命令之前，我们停止redis 服务器 redis 127.0.0.1:6379&gt; ping Could not connect to Redis at 127.0.0.1:6379: Connection refused //执行下面命令之前，我们启动redis 服务器 not connected&gt; ping PONG redis 127.0.0.1:6379&gt; 第一个ping 时，说明此连接正常 第二个ping 之前，我们将redis 服务器停止，那么ping 是失败的 第三个ping 之前，我们将redis 服务器启动，那么ping 是成功的 echo在命令行打印一些内容 redis 127.0.0.1:6379&gt; echo HongWan &quot;HongWan&quot; redis 127.0.0.1:6379&gt; select 选择数据库。Redis 数据库编号从0~15，我们可以选择任意一个数据库来进行数据的存取。 redis 127.0.0.1:6379&gt; select 1 OK redis 127.0.0.1:6379[1]&gt; select 16 (error) ERR invalid DB index redis 127.0.0.1:6379[16]&gt; 当选择16 时，报错，说明没有编号为16 的这个数据库 quit退出连接。 redis 127.0.0.1:6379&gt; quit dbsize返回当前数据库中key 的数目。 redis 127.0.0.1:6379&gt; dbsize (integer) 18 redis 127.0.0.1:6379&gt; 结果说明此库中有18 个key info获取服务器的信息和统计。 redis 127.0.0.1:6379&gt; info redis_version:2.2.12 redis_git_sha1:00000000 redis_git_dirty:0 arch_bits:32 multiplexing_api:epoll process_id:28480 uptime_in_seconds:2515 uptime_in_days:0 flushdb删除当前选择数据库中的所有key。 redis 127.0.0.1:6379&gt; dbsize (integer) 18 redis 127.0.0.1:6379&gt; flushdb OK redis 127.0.0.1:6379&gt; dbsize (integer) 0 redis 127.0.0.1:6379&gt; 在本例中我们将0 号数据库中的key 都清除了。 flushall删除所有数据库中的所有key。 redis 127.0.0.1:6379[1]&gt; dbsize (integer) 1 redis 127.0.0.1:6379[1]&gt; select 0 OK redis 127.0.0.1:6379&gt; flushall OK redis 127.0.0.1:6379&gt; select 1 OK redis 127.0.0.1:6379[1]&gt; dbsize (integer) 0 redis 127.0.0.1:6379[1]&gt; 在本例中我们先查看了一个1 号数据库中有一个key，然后我切换到0 号库执行flushall 命令，结果1 号库中的key 也被清除了，说是此命令工作正常。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>非关系型数据库</tag>
        <tag>数据库</tag>
        <tag>缓存数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis高级篇]]></title>
    <url>%2F2018%2F12%2F12%2Fredis3%2F</url>
    <content type="text"><![CDATA[持久化Redis的高性能是由于其将所有数据都存储在了内存中为了使Redis在重启之后仍能保证数据不丢失，需要将数据从内存中同步到硬盘中，这一过程就是持久化。Redis支持两种方式的持久化，一种是RDB方式，一种是AOF方式。可以单独使用其中一种或将二者结合使用。 RDB持久化RDB方式的持久化是通过快照（snapshotting）完成的，当符合一定条件时Redis会自动将内存中的数据进行快照并持久化到硬盘。RDB是Redis默认采用的持久化方式，在redis.conf配置文件中默认有此下配置： save 900 1save 300 10save 60 10000 save 开头的一行就是持久化配置，可以配置多个条件（每行配置一个条件），每个条件之间是“或”的关系，“save 900 1”表示15分钟（900秒钟）内至少1个键被更改则进行快照，“save 300 10”表示5分钟（300秒）内至少10个键被更改则进行快照。 在redis.conf中：配置dir指定rdb快照文件的位置配置dbfilenam指定rdb快照文件的名称 Redis启动后会读取RDB快照文件，将数据从硬盘载入到内存。根据数据量大小与结构和服务器性能不同，这个时间也不同。通常将记录一千万个字符串类型键、大小为1GB的快照文件载入到内存中需要花费20～30秒钟。 问题总结：通过RDB方式实现持久化，一旦Redis异常退出，就会丢失最后一次快照以后更改的所有数据。这就需要开发者根据具体的应用场合，通过组合设置自动快照条件的方式来将可能发生的数据损失控制在能够接受的范围。如果数据很重要以至于无法承受任何损失，则可以考虑使用AOF方式进行持久化。 AOF持久化默认情况下Redis没有开启AOF（append only file）方式的持久化，可以通过appendonly参数开启：appendonly yes开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof，可以通过appendfilename参数修改：appendfilename appendonly.aof 主从复制（了解）什么是主从复制持久化保证了即使redis服务重启也会丢失数据，因为redis服务重启后会将硬盘上持久化的数据恢复到内存中，但是当redis服务器的硬盘损坏了可能会导致数据丢失，如果通过redis的主从复制机制就可以避免这种单点故障，如下图： 说明：主redis中的数据有两个副本（replication）即从redis1和从redis2，即使一台redis服务器宕机其它两台redis服务也可以继续提供服务。主redis中的数据和从redis上的数据保持实时同步，当主redis写入数据时通过主从复制机制会复制到两个从redis服务上。只有一个主redis，可以有多个从redis。主从复制不会阻塞master，在同步数据时，master 可以继续处理client 请求一个redis可以即是主又是从，如下图： 主从配置主redis配置无需特殊配置。 从redis配置修改从redis服务器上的redis.conf文件，添加slaveof 主redisip 主redis端口 上边的配置说明当前该从redis服务器所对应的主redis是192.168.101.3，端口是6379 主从复制过程完整复制在redis2.8版本之前主从复制过程如下图： 复制过程说明： 1、slave 服务启动，slave 会建立和master 的连接，发送sync 命令。2、master启动一个后台进程将数据库快照保存到RDB文件中注意：此时如果生成RDB文件过程中存在写数据操作会导致RDB文件和当前主redis数据不一致，所以此时master 主进程会开始收集写命令并缓存起来。3、master 就发送RDB文件给slave4、slave 将文件保存到磁盘上，然后加载到内存恢复5、master把缓存的命令转发给slave注意：后续master 收到的写命令都会通过开始建立的连接发送给slave。当master 和slave 的连接断开时slave 可以自动重新建立连接。如果master 同时收到多个slave 发来的同步连接命令，只会启动一个进程来写数据库镜像，然后发送给所有slave。 完整复制的问题： 在redis2.8之前从redis每次同步都会从主redis中复制全部的数据，如果从redis是新创建的从主redis中复制全部的数据这是没有问题的，但是，如果当从redis停止运行，再启动时可能只有少部分数据和主redis不同步，此时启动redis仍然会从主redis复制全部数据，这样的性能肯定没有只复制那一小部分不同步的数据高。 部分复制部分复制说明：从机连接主机后，会主动发起 PSYNC 命令，从机会提供 master的runid(机器标识，随机生成的一个串) 和 offset（数据偏移量，如果offset主从不一致则说明数据不同步），主机验证 runid 和 offset 是否有效， runid 相当于主机身份验证码，用来验证从机上一次连接的主机，如果runid验证未通过则，则进行全同步，如果验证通过则说明曾经同步过，根据offset同步部分数据。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>非关系型数据库</tag>
        <tag>数据库</tag>
        <tag>缓存数据库</tag>
        <tag>持久化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot-redis.md]]></title>
    <url>%2F2018%2F12%2F12%2Fspringboot-redis%2F</url>
    <content type="text"><![CDATA[一. Springboot整合Redis(单机版 注解式开发)1.引入redis起步依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-redis&lt;/artifactId&gt; &lt;/dependency&gt; 2.在虚拟机中开启redis服务 启动server: ./redis-server redis.conf (启动客户端测试: ./redis-cli) 3.在applicaction.properties中配置redis 主机和端口号(这里为我的centos中的主机名以及redis端口号，可自行配置 spring.redis.host=192.168.66.66 spring.redis.port=6379 4.在启动类中加入注解@EnableCaching开启缓存 @EnableCaching @SpringBootApplication 5.在service实现类中利用@Cacheable设置缓存 /** * value : 缓存的名字 , * key ： 缓存map中的key * @param id * @return */ @Cacheable(value = { &quot;sampleCache&quot; },key=&quot;#id&quot;) public String getBook(int id) { System.out.println(&quot;Method executed..&quot;); if (id == 1) { return &quot;Book 1&quot;; } else { return &quot;Book 2&quot;; } } 二. Springboot整合Redis(集群版 注解式开发)1.在applicaction.properties中配置redis 集群 redis.cache.clusterNodes=192.168.66.66:7001,192.168.66.66:7002,192.168.66.66:7003,192.168.66.66:7004 2.自定义config对配置的集群节点进行解析 @Configuration //AaplicationContext.xml public class RedisClusterConfig { //注入集群节点信息 @Value(&quot;${redis.cache.clusterNodes}&quot;) private String clusterNodes; @Bean public JedisCluster getJedisCluster() { // 截取集群节点 String[] cluster = clusterNodes.split(&quot;,&quot;); // 创建set集合 Set&lt;HostAndPort&gt; nodes = new HashSet&lt;HostAndPort&gt;(); // 循环数组把集群节点添加到set集合中 for (String node : cluster) { String[] host = node.split(&quot;:&quot;); //添加集群节点 nodes.add(new HostAndPort(host[0], Integer.parseInt(host[1]))); } //创建集群节点对象 JedisCluster jc = new JedisCluster(nodes); return jc; } 3.在service实现类注入REDIS集群对象并实现缓存 @Autowired private JedisCluster jedisCluster; @Override public Map&lt;String, Object&gt; redisMap() { jedisCluster.set(&quot;user&quot;, &quot;张三丰&quot;); String value = jedisCluster.get(&quot;user&quot;); Map&lt;String, Object&gt; maps = newHashMap&lt;String,Object&gt;(); maps.put(&quot;redis&quot;, value); return maps; }]]></content>
      <categories>
        <category>springboot-redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>非关系型数据库</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis高级篇(输入输出映射/动态sql/关联查询)]]></title>
    <url>%2F2017%2F12%2F28%2Fmybatis-2%2F</url>
    <content type="text"><![CDATA[课程计划 1、输入映射和输出映射 a)输入参数映射 b)返回值映射 2、动态sql a)If b)Where c)Foreach d)Sql片段 3、关联查询 a)一对一关联 b)一对多关联 一.输入映射和输出映射Mapper.xml映射文件中定义了操作数据库的sql，每个sql是一个statement，映射文件是mybatis的核心。 1.parameterType(输入类型)1)传递简单类型参考基础篇内容。 2)传递pojo对象Mybatis使用ognl表达式解析对象字段的值，#{}或者${}括号中的值为pojo属性名称。 3)传递pojo包装对象开发中通过pojo传递查询条件 ，查询条件是综合的查询条件，不仅包括用户查询条件还包括其它的查询条件（比如将用户购买商品信息也作为查询条件），这时可以使用包装对象传递输入参数。Pojo类中包含pojo。 需求：根据用户名查询用户信息，查询条件放到QueryVo的user属性中。 1.QueryVo public class QueryVo { private User user; public User getUser() { return user; } public void setUser(User user) { this.user = user; } } 2.Sql语句 SELECT * FROM user where username like &apos;%刘%&apos; 3.Mapper文件 &lt;!-- 使用包装类型查询用户 使用ognl从对象中取属性值，如果是包装对象可以使用.操作符来取内容部的属性 --&gt; &lt;select id=&quot;findUserByQueryVo&quot; parameterType=&quot;queryvo&quot; resultType=&quot;user&quot;&gt; SELECT * FROM user where username like &apos;%${user.username}%&apos; &lt;/select&gt; 4.接口 5.测试方法 @Test public void testFindUserByQueryVo() throws Exception { SqlSession sqlSession = sessionFactory.openSession(); //获得mapper的代理对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); //创建QueryVo对象 QueryVo queryVo = new QueryVo(); //创建user对象 User user = new User(); user.setUsername(&quot;刘&quot;); queryVo.setUser(user); //根据queryvo查询用户 List&lt;User&gt; list = userMapper.findUserByQueryVo(queryVo); System.out.println(list); sqlSession.close(); } 2.resultType(输出类型)1)输出简单类型参考getnow输出日期类型，看下边的例子输出整型： Mapper.xml文件 &lt;!-- 获取用户列表总数 --&gt; &lt;select id=&quot;findUserCount&quot; resultType=&quot;int&quot;&gt; select count(1) from user &lt;/select&gt; Mapper接口 public int findUserCount() throws Exception; 调用： Public void testFindUserCount() throws Exception{ //获取session SqlSession session = sqlSessionFactory.openSession(); //获取mapper接口实例 UserMapper userMapper = session.getMapper(UserMapper.class); //传递Hashmap对象查询用户列表 int count = userMapper.findUserCount(); //关闭session session.close(); } 输出简单类型必须查询出来的结果集有一条记录，最终将第一个字段的值转换为输出类型。使用session的selectOne可查询单条记录。 2)输出pojo对象参考基础篇内容 3）输出pojo列表参考初级篇内容。 3.resultMapresultType可以指定pojo将查询结果映射为pojo，但需要pojo的属性名和sql查询的列名一致方可映射成功。 如果sql查询字段名和pojo的属性名不一致，可以通过resultMap将字段名和属性名作一个对应关系 ，resultMap实质上还需要将查询结果映射到pojo对象中。 resultMap可以实现将查询结果映射为复杂类型的pojo，比如在查询结果映射对象中包括pojo和list实现一对一查询和一对多查询。 1).Mapper.xml定义 使用resultMap指定上边定义的personmap。 2).定义resultMap由于上边的mapper.xml中sql查询列和Users.java类属性不一致，需要定义resultMap：userListResultMap将sql查询列和Users.java类属性对应起来 &lt;id /&gt;：此属性表示查询结果集的唯一标识，非常重要。如果是多个字段为复合唯一约束则定义多个&lt;id /&gt;。 Property：表示User类的属性。 Column：表示sql查询出来的字段名。 Column和property放在一块儿表示将sql查询出来的字段映射到指定的pojo类属性上。 &lt;result /&gt;：普通结果，即pojo的属性。 3)Mapper接口定义public List&lt;User&gt; findUserListResultMap() throws Exception; 二.动态sql通过mybatis提供的各种标签方法实现动态拼接sql。 1.If&lt;!-- 传递pojo综合查询用户信息 --&gt; &lt;select id=&quot;findUserList&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt; select * from user where 1=1 &lt;if test=&quot;id!=null&quot;&gt; and id=#{id} &lt;/if&gt; &lt;if test=&quot;username!=null and username!=&apos;&apos;&quot;&gt; and username like &apos;%${username}%&apos; &lt;/if&gt; &lt;/select&gt; 注意要做不等于空字符串校验。 2.Where上边的sql也可以改为： &lt;select id=&quot;findUserList&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt; select * from user &lt;where&gt; &lt;if test=&quot;id!=null and id!=&apos;&apos;&quot;&gt; and id=#{id} &lt;/if&gt; &lt;if test=&quot;username!=null and username!=&apos;&apos;&quot;&gt; and username like &apos;%${username}%&apos; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;where /&gt;可以自动处理第一个and。 3.foreach向sql传递数组或List，mybatis使用foreach解析，如下： 需求 传入多个id查询用户信息，用下边两个sql实现： SELECT * FROM USERS WHERE username LIKE &apos;%张%&apos; AND (id =10 OR id =89 OR id=16) SELECT * FROM USERS WHERE username LIKE &apos;%张%&apos; id IN (10,89,16) 在pojo中定义list属性ids存储多个用户id，并添加getter/setter方法 mapper.xml &lt;if test=&quot;ids!=null and ids.size&gt;0&quot;&gt; &lt;foreach collection=&quot;ids&quot; open=&quot; and id in(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot; &gt; #{id} &lt;/foreach&gt; &lt;/if&gt; 测试代码： List&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;(); ids.add(1);//查询id为1的用户 ids.add(10); //查询id为10的用户 queryVo.setIds(ids); List&lt;User&gt; list = userMapper.findUserList(queryVo); 4.Sql片段Sql中可将重复的sql提取出来，使用时用include引用即可，最终达到sql重用的目的，如下： &lt;!-- 传递pojo综合查询用户信息 --&gt; &lt;select id=&quot;findUserList&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt; select * from user &lt;where&gt; &lt;if test=&quot;id!=null and id!=&apos;&apos;&quot;&gt; and id=#{id} &lt;/if&gt; &lt;if test=&quot;username!=null and username!=&apos;&apos;&quot;&gt; and username like &apos;%${username}%&apos; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; 将where条件抽取出来： &lt;sql id=&quot;query_user_where&quot;&gt; &lt;if test=&quot;id!=null and id!=&apos;&apos;&quot;&gt; and id=#{id} &lt;/if&gt; &lt;if test=&quot;username!=null and username!=&apos;&apos;&quot;&gt; and username like &apos;%${username}%&apos; &lt;/if&gt; &lt;/sql&gt; 使用include引用： &lt;select id=&quot;findUserList&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt; select * from user &lt;where&gt; &lt;include refid=&quot;query_user_where&quot;/&gt; &lt;/where&gt; &lt;/select&gt; 注意：如果引用其它mapper.xml的sql片段，则在引用时需要加上namespace，如下： &lt;include refid=”namespace.sql片段”/&gt; 三.关联查询(一对一/一对多)1.商品订单数据模型 2.一对一查询案例：查询所有订单信息，关联查询下单用户信息。 注意：因为一个订单信息只会是一个人下的订单，所以从查询订单信息出发关联查询用户信息为一对一查询。如果从用户信息出发查询用户下的订单信息则为一对多查询，因为一个用户可以下多个订单。 1)方法一：使用resultType，定义订单信息po类，此po类中包括了订单信息和用户信息： 1.Sql语句： SELECT orders.*, user.username, userss.address FROM orders, user WHERE orders.user_id = user.id 2.定义po类 Po类中应该包括上边sql查询出来的所有字段，如下： public class OrdersCustom extends Orders { private String username;// 用户名称 private String address;// 用户地址 get/set。。。。 OrdersCustom类继承Orders类后OrdersCustom类包括了Orders类的所有字段，只需要定义用户的信息字段即可。 3.Mapper.xml &lt;!-- 查询所有订单信息 --&gt; &lt;select id=&quot;findOrdersList&quot; resultType=&quot;cn.itcast.mybatis.po.OrdersCustom&quot;&gt; SELECT orders.*, user.username, user.address FROM orders, user WHERE orders.user_id = user.id &lt;/select&gt; 4.Mapper接口： public List&lt;OrdersCustom&gt; findOrdersList() throws Exception; 5.测试： Public void testfindOrdersList()throws Exception{ //获取session SqlSession session = sqlSessionFactory.openSession(); //获限mapper接口实例 UserMapper userMapper = session.getMapper(UserMapper.class); //查询订单信息 List&lt;OrdersCustom&gt; list = userMapper.findOrdersList(); System.out.println(list); //关闭session session.close(); } 6.小结： 定义专门的po类作为输出类型，其中定义了sql查询结果集所有的字段。此方法较为简单，企业中使用普遍。 2）方法二：使用resultMap，定义专门的resultMap用于映射一对一查询结果。 1.Sql语句： SELECT orders.*, user.username, user.address FROM orders, user WHERE orders.user_id = user.id 2.定义po类 在Orders类中加入User属性，user属性中用于存储关联查询的用户信息，因为订单关联查询用户是一对一关系，所以这里使用单个User对象存储关联查询的用户信息。 private User user; get set 3.Mapper.xml &lt;!-- 查询订单关联用户信息使用resultmap --&gt; &lt;resultMap type=&quot;cn.itheima.po.Orders&quot; id=&quot;orderUserResultMap&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;user_id&quot; property=&quot;userId&quot;/&gt; &lt;result column=&quot;number&quot; property=&quot;number&quot;/&gt; &lt;result column=&quot;createtime&quot; property=&quot;createtime&quot;/&gt; &lt;result column=&quot;note&quot; property=&quot;note&quot;/&gt; &lt;!-- 一对一关联映射 --&gt; &lt;!-- property:Orders对象的user属性 javaType：user属性对应 的类型 --&gt; &lt;association property=&quot;user&quot; javaType=&quot;cn.itcast.po.User&quot;&gt; &lt;!-- column:user表的主键对应的列 property：user对象中id属性--&gt; &lt;id column=&quot;user_id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt; &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id=&quot;findOrdersWithUserResultMap&quot; resultMap=&quot;orderUserResultMap&quot;&gt; SELECT o.id, o.user_id, o.number, o.createtime, o.note, u.username, u.address FROM orders o JOIN `user` u ON u.id = o.user_id &lt;/select&gt; 这里resultMap指定orderUserResultMap。 association：表示进行关联查询单条记录 property：表示关联查询的结果存储在cn.itcast.mybatis.po.Orders的user属性中 javaType：表示关联查询的结果类型 &lt;id property=&quot;id&quot; column=&quot;user_id&quot;/&gt;：查询结果的user_id列对应关联对象的id属性，这里是&lt;id /&gt;表示user_id是关联查询对象的唯一标识。 &lt;result property=&quot;username&quot; column=&quot;username&quot;/&gt;：查询结果的username列对应关联对象的username属性。 4.Mapper接口： public List&lt;Orders&gt; findOrdersListResultMap() throws Exception; 5.测试： Public void testfindOrdersListResultMap()throws Exception{ //获取session SqlSession session = sqlSessionFactory.openSession(); //获限mapper接口实例 UserMapper userMapper = session.getMapper(UserMapper.class); //查询订单信息 List&lt;Orders&gt; list = userMapper.findOrdersList2(); System.out.println(list); //关闭session session.close(); } 6.小结： 使用association完成关联查询，将关联查询信息映射到pojo对象中。 3.一对多查询案例：查询所有用户信息及用户关联的订单信息。 用户信息和订单信息为一对多关系。 使用resultMap实现如下： 1.Sql语句： SELECT u.*, o.id oid, o.number, o.createtime, o.note FROM `user` u LEFT JOIN orders o ON u.id = o.user_id 2.定义po类 在User类中加入List&lt;Orders&gt; orders属性 private List&lt;Orders&gt; orders; get set 3.Mapper.xml &lt;resultMap type=&quot;cn.itheima.po.user&quot; id=&quot;userOrderResultMap&quot;&gt; &lt;!-- 用户信息映射 --&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;username&quot; column=&quot;username&quot;/&gt; &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;/&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&gt; &lt;result property=&quot;address&quot; column=&quot;address&quot;/&gt; &lt;!-- 一对多关联映射 --&gt; &lt;collection property=&quot;orders&quot; ofType=&quot;cn.itheima.po.Orders&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;oid&quot;/&gt; &lt;!--用户id已经在user对象中存在，此处可以不设置--&gt; &lt;!-- &lt;result property=&quot;userId&quot; column=&quot;id&quot;/&gt; --&gt; &lt;result property=&quot;number&quot; column=&quot;number&quot;/&gt; &lt;result property=&quot;createtime&quot; column=&quot;createtime&quot;/&gt; &lt;result property=&quot;note&quot; column=&quot;note&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;getUserOrderList&quot; resultMap=&quot;userOrderResultMap&quot;&gt; SELECT u.*, o.id oid, o.number, o.createtime, o.note FROM `user` u LEFT JOIN orders o ON u.id = o.user_id &lt;/select&gt; collection部分定义了用户关联的订单信息。表示关联查询结果集 property=&quot;orders&quot;：关联查询的结果集存储在User对象的上哪个属性。 ofType=&quot;orders&quot;：指定关联查询的结果集中的对象类型即List中的对象类型。此处可以使用别名，也可以使用全限定名。 &lt;id /&gt;及&lt;result/&gt;的意义同一对一查询。 4.Mapper接口： List&lt;User&gt; getUserOrderList(); 5.测试 @Test public void getUserOrderList() { SqlSession session = sqlSessionFactory.openSession(); UserMapper userMapper = session.getMapper(UserMapper.class); List&lt;User&gt; result = userMapper.getUserOrderList(); for (User user : result) { System.out.println(user); } session.close(); }]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis基础篇（基础配置/动态代理取代原始dao层开发）]]></title>
    <url>%2F2017%2F12%2F28%2Fmybatis-1%2F</url>
    <content type="text"><![CDATA[本篇内容： 1.Mybatis的介绍 2.Mybatis的入门 a)使用jdbc操作数据库存在的问题 b)Mybatis的架构 c)Mybatis的入门程序 3.Dao的开发方法 a)原始dao的开发方法 b)动态代理方式 4.SqlMapConfig.xml文件说明 一.Mybatis的介绍MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。 MyBatis是一个优秀的持久层框架，它对jdbc的操作数据库的过程进行封装，使开发者只需要关注 SQL 本身，而不需要花费精力去处理例如注册驱动、创建connection、创建statement、手动设置参数、结果集检索等jdbc繁杂的过程代码。Mybatis通过xml或注解的方式将要执行的各种statement（statement、preparedStatement、CallableStatement）配置起来，并通过java对象和statement中的sql进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射成java对象并返回。 二.Mybatis的入门1.jdbc操作数据库存在的问题1.创建mysql数据库 2.创建工程|（引入mysql驱动包） 3.jdbc编程步骤 1)、加载数据库驱动 2)、创建并获取数据库链接 3)、创建jdbc statement对象 4)、设置sql语句 5)、设置sql语句中的参数(使用preparedStatement) 6)、通过statement执行sql并获取结果 7)、对sql执行结果进行解析处理 8)、释放资源(resultSet、preparedstatement、connection) 4.jdbc程序 public static void main(String[] args) { Connection connection = null; PreparedStatement preparedStatement = null; ResultSet resultSet = null; try { //加载数据库驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //通过驱动管理类获取数据库链接 connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8&quot;, &quot;root&quot;, &quot;root&quot;); //定义sql语句 ?表示占位符 String sql = &quot;select * from user where username = ?&quot;; //获取预处理statement preparedStatement = connection.prepareStatement(sql); //设置参数，第一个参数为sql语句中参数的序号（从1开始），第二个参数为设置的参数值 preparedStatement.setString(1, &quot;王五&quot;); //向数据库发出sql执行查询，查询出结果集 resultSet = preparedStatement.executeQuery(); //遍历查询结果集 while(resultSet.next()){ System.out.println(resultSet.getString(&quot;id&quot;)+&quot; &quot;+resultSet.getString(&quot;username&quot;)); } } catch (Exception e) { e.printStackTrace(); }finally{ //释放资源 if(resultSet!=null){ try { resultSet.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } } if(preparedStatement!=null){ try { preparedStatement.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } } if(connection!=null){ try { connection.close(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } 5.jdbc问题总结如下： 1)、数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。 2)、Sql语句在代码中硬编码，造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。 3)、使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不一定，可能多也可能少，修改sql还要修改代码，系统不易维护。 4)、对结果集解析存在硬编码（查询列名），sql变化导致解析代码变化，系统不易维护，如果能将数据库记录封装成pojo对象解析比较方便。 2.Mybatis架构 1、mybatis配置 SqlMapConfig.xml，此文件作为mybatis的全局配置文件，配置了mybatis的运行环境等信息。 mapper.xml文件即sql映射文件，文件中配置了操作数据库的sql语句。此文件需要在SqlMapConfig.xml中加载。 2、通过mybatis环境等配置信息构造SqlSessionFactory即会话工厂 3、由会话工厂创建sqlSession即会话，操作数据库需要通过sqlSession进行。 4、mybatis底层自定义了Executor执行器接口操作数据库，Executor接口有两个实现，一个是基本执行器、一个是缓存执行器。 5、Mapped Statement也是mybatis一个底层封装对象，它包装了mybatis配置信息及sql映射信息等。mapper.xml文件中一个sql对应一个Mapped Statement对象，sql的id即是Mapped statement的id。 6、Mapped Statement对sql执行输入参数进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql前将输入的java对象映射至sql中，输入参数映射就是jdbc编程中对preparedStatement设置参数。 7、Mapped Statement对sql执行输出结果进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql后将输出结果映射至java对象中，输出结果映射过程相当于jdbc编程中对结果的解析处理过程。 3.Mybatis入门程序1.mybatis下载mybaits的代码由github.com管理，地址：https://github.com/mybatis/mybatis-3/releases mybatis-3.2.7.jar----mybatis的核心包 lib----mybatis的依赖包 mybatis-3.2.7.pdf----mybatis使用手册 2.需求实现以下功能： 根据用户id查询一个用户信息 根据用户名称模糊查询用户信息列表 添加用户 更新用户 删除用户 3.工程搭建a) 创建java工程 使用eclipse创建java工程，jdk使用1.7.0_72。 b) 加入jar包 加入mybatis核心包、依赖包、数据驱动包。 c) log4j.properties(mybatis默认使用log4j作为输出日志信息。) 在classpath下创建log4j.properties如下： # Global logging configuration log4j.rootLogger=DEBUG, stdout # Console output... log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n d) SqlMapConfig.xml 在classpath下创建SqlMapConfig.xml，如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;!-- 和spring整合后 environments配置将废除--&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- 使用jdbc事务管理--&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;!-- 数据库连接池--&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;/configuration&gt; SqlMapConfig.xml是mybatis核心配置文件，上边文件的配置内容为数据源、事务管理。 e) po类（Po类作为mybatis进行sql映射使用，po类通常与数据库表对应，User.java如下：） Public class User { private int id; private String username;// 用户姓名 private String sex;// 性别 private Date birthday;// 生日 private String address;// 地址 f) sql映射文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;test&quot;&gt; &lt;/mapper&gt; g) 加载映射文件（在SqlMapConfig.xml） &lt;mappers&gt; &lt;mapper resource=&quot;sqlmap/User.xml&quot;/&gt; &lt;/mappers&gt; 4.根据ID查询用户信息a) 映射文件 &lt;!-- 根据id获取用户信息 --&gt; &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;cn.itcast.mybatis.po.User&quot;&gt; select * from user where id = #{id} &lt;/select&gt; parameterType：定义输入到sql中的映射类型，#{id}表示使用preparedstatement设置占位符号并将输入变量id传到sql。 resultType：定义结果映射类型。 b) 测试程序 public class Mybatis_first { //会话工厂 private SqlSessionFactory sqlSessionFactory; @Before public void createSqlSessionFactory() throws IOException { // 配置文件 String resource = &quot;SqlMapConfig.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); // 使用SqlSessionFactoryBuilder从xml配置文件中创建SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder() .build(inputStream); } // 根据 id查询用户信息 @Test public void testFindUserById() { // 数据库会话实例 SqlSession sqlSession = null; try { // 创建数据库会话实例sqlSession sqlSession = sqlSessionFactory.openSession(); // 查询单个记录，根据用户id查询用户信息 User user = sqlSession.selectOne(&quot;test.findUserById&quot;, 10); // 输出用户信息 System.out.println(user); } catch (Exception e) { e.printStackTrace(); } finally { if (sqlSession != null) { sqlSession.close(); } } } } 5.根据用户名查询用户信息a) 映射文件 &lt;!-- 自定义条件查询用户列表 --&gt; &lt;select id=&quot;findUserByUsername&quot; parameterType=&quot;java.lang.String&quot; resultType=&quot;cn.itcast.mybatis.po.User&quot;&gt; select * from user where username like &apos;%${value}%&apos; &lt;/select&gt; parameterType：定义输入到sql中的映射类型，${value}表示使用参数将${value}替换，做字符串的拼接。 注意：如果是取简单数量类型的参数，括号中的值必须为value resultType：定义结果映射类型。 b) 测试程序 // 根据用户名称模糊查询用户信息 @Test public void testFindUserByUsername() { // 数据库会话实例 SqlSession sqlSession = null; try { // 创建数据库会话实例sqlSession sqlSession = sqlSessionFactory.openSession(); // 查询单个记录，根据用户id查询用户信息 List&lt;User&gt; list = sqlSession.selectList(&quot;test.findUserByUsername&quot;, &quot;张&quot;); System.out.println(list.size()); } catch (Exception e) { e.printStackTrace(); } finally { if (sqlSession != null) { sqlSession.close(); } } } 6.小结a) #{}和&amp;{}的区别 #{}表示一个占位符号，通过#{}可以实现preparedStatement向占位符中设置值，自动进行java类型和jdbc类型转换，#{}可以有效防止sql注入。 #{}可以接收简单类型值或pojo属性值。 如果parameterType传输单个简单类型值，#{}括号中可以是value或其它名称。 ${}表示拼接sql串，通过${}可以将parameterType 传入的内容拼接在sql中且不进行jdbc类型转换， ${}可以接收简单类型值或pojo属性值，如果parameterType传输单个简单类型值，${}括号中只能是value。 b) parameterType和resultType parameterType：指定输入参数类型，mybatis通过ognl从输入对象中获取参数值拼接在sql中。 resultType：指定输出结果类型，mybatis将sql查询结果的一行记录数据映射为resultType指定类型的对象。 c) selectOne和selectList selectOne查询一条记录，如果使用selectOne查询多条记录则抛出异常： org.apache.ibatis.exceptions.TooManyResultsException: Expected one result (or null) to be returned by selectOne(), but found: 3 at org.apache.ibatis.session.defaults.DefaultSqlSession.selectOne(DefaultSqlSession.java:70) selectList可以查询一条或多条记录。 7.添加用户a) 映射文件 &lt;!-- 添加用户 --&gt; &lt;insert id=&quot;insertUser&quot; parameterType=&quot;cn.itcast.mybatis.po.User&quot;&gt; insert into user(username,birthday,sex,address) values(#{username},#{birthday},#{sex},#{address}) &lt;/insert&gt; b) 测试程序 // 添加用户信息 @Test public void testInsert() { // 数据库会话实例 SqlSession sqlSession = null; try { // 创建数据库会话实例sqlSession sqlSession = sqlSessionFactory.openSession(); // 添加用户信息 User user = new User(); user.setUsername(&quot;张小明&quot;); user.setAddress(&quot;河南郑州&quot;); user.setSex(&quot;1&quot;); user.setPrice(1999.9f); sqlSession.insert(&quot;test.insertUser&quot;, user); //提交事务 sqlSession.commit(); } catch (Exception e) { e.printStackTrace(); } finally { if (sqlSession != null) { sqlSession.close(); } } } c) mysql自增主键返回 通过修改sql映射文件，可以将mysql自增主键返回： &lt;insert id=&quot;insertUser&quot; parameterType=&quot;cn.itcast.mybatis.po.User&quot;&gt; &lt;!-- selectKey将主键返回，需要再返回 --&gt; &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;java.lang.Integer&quot;&gt; select LAST_INSERT_ID() &lt;/selectKey&gt; insert into user(username,birthday,sex,address) values(#{username},#{birthday},#{sex},#{address}); &lt;/insert&gt; 添加selectKey实现将主键返回 keyProperty:返回的主键存储在pojo中的哪个属性 order：selectKey的执行顺序，是相对与insert语句来说，由于mysql的自增原理执行完insert语句之后才将主键生成，所以这里selectKey的执行顺序为after resultType:返回的主键是什么类型 LAST_INSERT_ID():是mysql的函数，返回auto_increment自增列新记录id值。 d) mysql使用uuid实现主键 需要增加通过select uuid()得到uuid值 &lt;insert id=&quot;insertUser&quot; parameterType=&quot;cn.itcast.mybatis.po.User&quot;&gt; &lt;selectKey resultType=&quot;java.lang.String&quot; order=&quot;BEFORE&quot; keyProperty=&quot;id&quot;&gt; select uuid() &lt;/selectKey&gt; insert into user(id,username,birthday,sex,address) values(#{id},#{username},#{birthday},#{sex},#{address}) &lt;/insert&gt; 注意这里使用的order是“BEFORE” 8.删除用户a)映射文件 &lt;!-- 删除用户 --&gt; &lt;delete id=&quot;deleteUserById&quot; parameterType=&quot;int&quot;&gt; delete from user where id=#{id} &lt;/delete&gt; b)测试程序 // 根据id删除用户 @Test public void testDelete() { // 数据库会话实例 SqlSession sqlSession = null; try { // 创建数据库会话实例sqlSession sqlSession = sqlSessionFactory.openSession(); // 删除用户 sqlSession.delete(&quot;test.deleteUserById&quot;,18); // 提交事务 sqlSession.commit(); } catch (Exception e) { e.printStackTrace(); } finally { if (sqlSession != null) { sqlSession.close(); } } } 9.修改用户a)映射文件 &lt;!-- 更新用户 --&gt; &lt;update id=&quot;updateUser&quot; parameterType=&quot;cn.itcast.mybatis.po.User&quot;&gt; update user set username=#{username},birthday=#{birthday},sex=#{sex},address=#{address} where id=#{id} &lt;/update&gt; b)测试程序 // 更新用户信息 @Test public void testUpdate() { // 数据库会话实例 SqlSession sqlSession = null; try { // 创建数据库会话实例sqlSession sqlSession = sqlSessionFactory.openSession(); // 添加用户信息 User user = new User(); user.setId(16); user.setUsername(&quot;张小明&quot;); user.setAddress(&quot;河南郑州&quot;); user.setSex(&quot;1&quot;); user.setPrice(1999.9f); sqlSession.update(&quot;test.updateUser&quot;, user); // 提交事务 sqlSession.commit(); } catch (Exception e) { e.printStackTrace(); } finally { if (sqlSession != null) { sqlSession.close(); } } } 10.mybatis解决jdbc编程的问题1、数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。 解决：在SqlMapConfig.xml中配置数据链接池，使用连接池管理数据库链接。 2、Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。 解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。 3、向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。 解决：Mybatis自动将java对象映射至sql语句，通过statement中的parameterType定义输入参数的类型。 4、对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。 解决：Mybatis自动将sql执行结果映射至java对象，通过statement中的resultType定义输出结果的类型。 11.mybatis和hibernate的区别Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。 Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。 Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。 三.Dao的开发方法（）使用Mybatis开发Dao，通常有两个方法，即“原始Dao开发方法”和“Mapper接口开发方法” 1.原始dao的开发方法1.需求将下边的功能实现Dao： 根据用户id查询一个用户信息 根据用户名称模糊查询用户信息列表 添加用户信息 2.SqlSession的使用范围SqlSession中封装了对数据库的操作，如：查询、插入、更新、删除等。通过SqlSessionFactory创建SqlSession，而SqlSessionFactory是通过SqlSessionFactoryBuilder进行创建。 a)SqlSessionFactoryBuilder SqlSessionFactoryBuilder用于创建SqlSessionFacoty，SqlSessionFacoty一旦创建完成就不需要SqlSessionFactoryBuilder了，因为SqlSession是通过SqlSessionFactory生产，所以可以将SqlSessionFactoryBuilder当成一个工具类使用，最佳使用范围是方法范围即方法体内局部变量。 b)SqlSessionFactory SqlSessionFactory是一个接口，接口中定义了openSession的不同重载方法，SqlSessionFactory的最佳使用范围是整个应用运行期间，一旦创建后可以重复使用，通常以单例模式管理SqlSessionFactory。 c)SqlSession SeqlSssion是一个面向用户的接口， sqlSession中定义了数据库操作方法。每个线程都应该有它自己的SqlSession实例。SqlSession的实例不能共享使用，它也是线程不安全的。因此最佳的范围是请求或方法范围。绝对不能将SqlSession实例的引用放在一个类的静态字段或实例字段中。打开一个 SqlSession；使用完毕就要关闭它。通常把这个关闭操作放到 finally 块中以确保每次都能执行关闭。如下： SqlSession session = sqlSessionFactory.openSession(); try { // do work } finally { session.close(); } 3.原始dao开发方式原始Dao开发方法需要程序员编写Dao接口和Dao实现类。a)映射文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;test&quot;&gt; &lt;!-- 根据id获取用户信息 --&gt; &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;cn.itcast.mybatis.po.User&quot;&gt; select * from user where id = #{id} &lt;/select&gt; &lt;!-- 添加用户 --&gt; &lt;insert id=&quot;insertUser&quot; parameterType=&quot;cn.itcast.mybatis.po.User&quot;&gt; &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;java.lang.Integer&quot;&gt; select LAST_INSERT_ID() &lt;/selectKey&gt; insert into user(username,birthday,sex,address) values(#{username},#{birthday},#{sex},#{address}) &lt;/insert&gt; &lt;/mapper&gt; b)dao接口 Public interface UserDao { public User getUserById(int id) throws Exception; public void insertUser(User user) throws Exception; } Public class UserDaoImpl implements UserDao { //注入SqlSessionFactory public UserDaoImpl(SqlSessionFactory sqlSessionFactory){ this.setSqlSessionFactory(sqlSessionFactory); } private SqlSessionFactory sqlSessionFactory; @Override public User getUserById(int id) throws Exception { SqlSession session = sqlSessionFactory.openSession(); User user = null; try { //通过sqlsession调用selectOne方法获取一条结果集 //参数1：指定定义的statement的id,参数2：指定向statement中传递的参数 user = session.selectOne(&quot;test.findUserById&quot;, 1); System.out.println(user); } finally{ session.close(); } return user; } @Override Public void insertUser(User user) throws Exception { SqlSession sqlSession = sqlSessionFactory.openSession(); try { sqlSession.insert(&quot;insertUser&quot;, user); sqlSession.commit(); } finally{ session.close(); } } } c)dao测试 创建一个JUnit的测试类，对UserDao进行测试。 private SqlSessionFactory sqlSessionFactory; @Before public void init() throws Exception { SqlSessionFactoryBuilder sessionFactoryBuilder = new SqlSessionFactoryBuilder(); InputStream inputStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); sqlSessionFactory = sessionFactoryBuilder.build(inputStream); } @Test public void testGetUserById() { UserDao userDao = new UserDaoImpl(sqlSessionFactory); User user = userDao.getUserById(22); System.out.println(user); } } d)问题 原始Dao开发中存在以下问题： 1.Dao方法体存在重复代码：通过SqlSessionFactory创建SqlSession，调用SqlSession的数据库操作方法 2.调用sqlSession的数据库操作方法需要指定statement的id，这里存在硬编码，不利于开发维护。 2.动态代理方式1.开发规范Mapper接口开发方法只需要程序员编写Mapper接口（相当于Dao接口）， 由Mybatis框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。 Mapper接口开发需要遵循以下规范： 1、Mapper.xml文件中的namespace与mapper接口的类路径相同。 2、 Mapper接口方法名和Mapper.xml中定义的每个statement的id相同 3、Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同 4、Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同 2.Mapper.xml(映射文件)定义mapper映射文件UserMapper.xml（内容同Users.xml），需要修改namespace的值为 UserMapper接口路径。将UserMapper.xml放在classpath 下mapper目录 下。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;cn.itcast.mybatis.mapper.UserMapper&quot;&gt; &lt;!-- 根据id获取用户信息 --&gt; &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;cn.itcast.mybatis.po.User&quot;&gt; select * from user where id = #{id} &lt;/select&gt; &lt;!-- 自定义条件查询用户列表 --&gt; &lt;select id=&quot;findUserByUsername&quot; parameterType=&quot;java.lang.String&quot; resultType=&quot;cn.itcast.mybatis.po.User&quot;&gt; select * from user where username like &apos;%${value}%&apos; &lt;/select&gt; &lt;!-- 添加用户 --&gt; &lt;insert id=&quot;insertUser&quot; parameterType=&quot;cn.itcast.mybatis.po.User&quot;&gt; &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;java.lang.Integer&quot;&gt; select LAST_INSERT_ID() &lt;/selectKey&gt; insert into user(username,birthday,sex,address) values(#{username},#{birthday},#{sex},#{address}) &lt;/insert&gt; &lt;/mapper&gt; 3.Mapper.java(接口文件)/** * 用户管理mapper */ Public interface UserMapper { //根据用户id查询用户信息 public User findUserById(int id) throws Exception; //查询用户列表 public List&lt;User&gt; findUserByUsername(String username) throws Exception; //添加用户信息 public void insertUser(User user)throws Exception; } 接口定义有如下特点： 1、Mapper接口方法名和Mapper.xml中定义的statement的id相同 2、Mapper接口方法的输入参数类型和mapper.xml中定义的statement的parameterType的类型相同 3、Mapper接口方法的输出参数类型和mapper.xml中定义的statement的resultType的类型相同 4.加载UserMapper.xml文件修改SqlMapConfig.xml文件： &lt;!-- 加载映射文件 --&gt; &lt;mappers&gt; &lt;mapper resource=&quot;mapper/UserMapper.xml&quot;/&gt; &lt;/mappers&gt; 5.测试Public class UserMapperTest extends TestCase { private SqlSessionFactory sqlSessionFactory; protected void setUp() throws Exception { //mybatis配置文件 String resource = &quot;sqlMapConfig.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); //使用SqlSessionFactoryBuilder创建sessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } Public void testFindUserById() throws Exception { //获取session SqlSession session = sqlSessionFactory.openSession(); //获取mapper接口的代理对象 UserMapper userMapper = session.getMapper(UserMapper.class); //调用代理对象方法 User user = userMapper.findUserById(1); System.out.println(user); //关闭session session.close(); } @Test public void testFindUserByUsername() throws Exception { SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; list = userMapper.findUserByUsername(&quot;张&quot;); System.out.println(list.size()); } Public void testInsertUser() throws Exception { //获取session SqlSession session = sqlSessionFactory.openSession(); //获取mapper接口的代理对象 UserMapper userMapper = session.getMapper(UserMapper.class); //要添加的数据 User user = new User(); user.setUsername(&quot;张三&quot;); user.setBirthday(new Date()); user.setSex(&quot;1&quot;); user.setAddress(&quot;北京市&quot;); //通过mapper接口添加用户 userMapper.insertUser(user); //提交 session.commit(); //关闭session session.close(); } } 6.小结1.selectOne和selectList 动态代理对象调用sqlSession.selectOne()和sqlSession.selectList()是根据mapper接口方法的返回值决定，如果返回list则调用selectList方法，如果返回单个对象则调用selectOne方法。 2.namespace mybatis官方推荐使用mapper代理方法开发mapper接口，程序员不用编写mapper接口实现类，使用mapper代理方法时，输入参数可以使用pojo包装对象或map对象，保证dao的通用性。 四.SqlMapConfig.xml配置文件1.配置内容SqlMapConfig.xml中配置的内容和顺序如下： properties（属性） settings（全局配置参数） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境集合属性对象） environment（环境子属性对象） transactionManager（事务管理） dataSource（数据源） mappers（映射器） 2.properties（属性）SqlMapConfig.xml可以引用java属性文件中的配置信息如下： 在classpath下定义db.properties文件， jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8 jdbc.username=root jdbc.password=root SqlMapConfig.xml引用如下： &lt;properties resource=&quot;db.properties&quot;/&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; 注意： MyBatis 将按照下面的顺序来加载属性： 在 properties 元素体内定义的属性首先被读取。 然后会读取properties 元素中resource或 url 加载的属性，它会覆盖已读取的同名属性。 3.typeAliases（类型别名）1.mybatis支持别名：别名 映射的类型 _byte byte _long long _short short _int int _integer int _double double _float float _boolean boolean string String byte Byte long Long short Short int Integer integer Integer double Double float Float boolean Boolean date Date decimal BigDecimal bigdecimal BigDecimal map Map 2.自定义别名：在SqlMapConfig.xml中配置： &lt;typeAliases&gt; &lt;!-- 单个别名定义 --&gt; &lt;typeAlias alias=&quot;user&quot; type=&quot;cn.itcast.mybatis.po.User&quot;/&gt; &lt;!-- 批量别名定义，扫描整个包下的类，别名为类名（首字母大写或小写都可以） --&gt; &lt;package name=&quot;cn.itcast.mybatis.po&quot;/&gt; &lt;package name=&quot;其它包&quot;/&gt; &lt;/typeAliases&gt; 4.mappers（映射器）Mapper配置的几种方法： 1.&lt;mapper resource=”sqlmap/User.xml”使用相对于类路径的资源 如：&lt;mapper resource=&quot;sqlmap/User.xml&quot; /&gt; 2.&lt;mapper class=” “ /使用mapper接口类路径 如：&lt;mapper class=&quot;cn.itcast.mybatis.mapper.UserMapper&quot;/&gt; 注意：此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。 3.&lt;package name=””/注册指定包下的所有mapper接口 如：&lt;package name=&quot;cn.itcast.mybatis.mapper&quot;/&gt; 注意：此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate与Mybatis总结篇]]></title>
    <url>%2F2017%2F12%2F28%2Fhibernate-mybatis%2F</url>
    <content type="text"><![CDATA[第一章 Hibernate与MyBatisHibernate 是当前最流行的O/R mapping框架，它出身于sf.net，现在已经成为Jboss的一部分。 Mybatis 是另外一种优秀的O/R mapping框架。目前属于apache的一个子项目。 MyBatis 参考资料官网：http://www.mybatis.org/core/zh/index.html Hibernate参考资料： http://docs.jboss.org/hibernate/core/3.6/reference/zh-CN/html_single/ 1 Hibernate 简介Hibernate对数据库结构提供了较为完整的封装，Hibernate的O/R Mapping实现了POJO 和数据库表之间的映射，以及SQL 的自动生成和执行。程序员往往只需定义好了POJO 到数据库表的映射关系，即可通过Hibernate 提供的方法完成持久层操作。程序员甚至不需要对SQL 的熟练掌握， Hibernate/OJB 会根据制定的存储逻辑，自动生成对应的SQL 并调用JDBC 接口加以执行。 2 MyBatis简介iBATIS 的着力点，则在于POJO 与SQL之间的映射关系。然后通过映射配置文件，将SQL所需的参数，以及返回的结果字段映射到指定POJO。 相对Hibernate“O/R”而言，iBATIS 是一种“Sql Mapping”的ORM实现。 第二章 开发对比1.开发速度Hibernate的真正掌握要比Mybatis来得难些。Mybatis框架相对简单很容易上手，但也相对简陋些。个人觉得要用好Mybatis还是首先要先理解好Hibernate。 2.开发社区Hibernate 与Mybatis都是流行的持久层开发框架，但Hibernate开发社区相对多热闹些，支持的工具也多，更新也快，当前最高版本4.1.8。而Mybatis相对平静，工具较少，当前最高版本3.2。 3.开发工作量Hibernate和MyBatis都有相应的代码生成工具。可以生成简单基本的DAO层方法。 针对高级查询，Mybatis需要手动编写SQL语句，以及ResultMap。而Hibernate有良好的映射机制，开发者无需关心SQL的生成与结果映射，可以更专注于业务流程。 第三章 系统调优对比1.Hibernate的调优方案 制定合理的缓存策略； 尽量使用延迟加载特性； 采用合理的Session管理机制； 使用批量抓取，设定合理的批处理参数（batch_size）; 进行合理的O/R映射设计 2.Mybatis的调优方案MyBatis在Session方面和Hibernate的Session生命周期是一致的，同样需要合理的Session管理机制。MyBatis同样具有二级缓存机制。 MyBatis可以进行详细的SQL优化设计。 3.SQL优化方面Hibernate的查询会将表中的所有字段查询出来，这一点会有性能消耗。Hibernate也可以自己写SQL来指定需要查询的字段，但这样就破坏了Hibernate开发的简洁性。而Mybatis的SQL是手动编写的，所以可以按需求指定查询的字段。 Hibernate HQL语句的调优需要将SQL打印出来，而Hibernate的SQL被很多人嫌弃因为太丑了。MyBatis的SQL是自己手动写的所以调整方便。但Hibernate具有自己的日志统计。Mybatis本身不带日志统计，使用Log4j进行日志记录。 4.扩展性方面Hibernate与具体数据库的关联只需在XML文件中配置即可，所有的HQL语句与具体使用的数据库无关，移植性很好。MyBatis项目中所有的SQL语句都是依赖所用的数据库的，所以不同数据库类型的支持不好。 第四章 对象管理与抓取策略1.对象管理Hibernate 是完整的对象/关系映射解决方案，它提供了对象状态管理（state management）的功能，使开发者不再需要理会底层数据库系统的细节。也就是说，相对于常见的 JDBC/SQL 持久层方案中需要管理 SQL 语句，Hibernate采用了更自然的面向对象的视角来持久化 Java 应用中的数据。 换句话说，使用 Hibernate 的开发者应该总是关注对象的状态（state），不必考虑 SQL 语句的执行。这部分细节已经由 Hibernate 掌管妥当，只有开发者在进行系统性能调优的时候才需要进行了解。 而MyBatis在这一块没有文档说明，用户需要对对象自己进行详细的管理。 2.抓取策略Hibernate对实体关联对象的抓取有着良好的机制。对于每一个关联关系都可以详细地设置是否延迟加载，并且提供关联抓取、查询抓取、子查询抓取、批量抓取四种模式。 它是详细配置和处理的。 而Mybatis的延迟加载是全局配置的。 第五章 缓存机制对比1.Hibernate缓存Hibernate一级缓存是Session缓存，利用好一级缓存就需要对Session的生命周期进行管理好。建议在一个Action操作中使用一个Session。一级缓存需要对Session进行严格管理。 Hibernate二级缓存是SessionFactory级的缓存。 SessionFactory的缓存分为内置缓存和外置缓存。内置缓存中存放的是SessionFactory对象的一些集合属性包含的数据(映射元素据及预定SQL语句等),对于应用程序来说,它是只读的。外置缓存中存放的是数据库数据的副本,其作用和一级缓存类似.二级缓存除了以内存作为存储介质外,还可以选用硬盘等外部存储设备。二级缓存称为进程级缓存或SessionFactory级缓存，它可以被所有session共享，它的生命周期伴随着SessionFactory的生命周期存在和消亡。 2.MyBatis缓存MyBatis 包含一个非常强大的查询缓存特性,它可以非常方便地配置和定制。MyBatis 3 中的缓存实现的很多改进都已经实现了,使得它更加强大而且易于配置。 默认情况下是没有开启缓存的,除了局部的 session 缓存,可以增强变现而且处理循环 依赖也是必须的。要开启二级缓存,你需要在你的 SQL 映射文件中添加一行: 字面上看就是这样。这个简单语句的效果如下: 映射语句文件中的所有 select 语句将会被缓存。 映射语句文件中的所有 insert,update 和 delete 语句会刷新缓存。 缓存会使用 Least Recently Used(LRU,最近最少使用的)算法来收回。 根据时间表(比如 no Flush Interval,没有刷新间隔), 缓存不会以任何时间顺序 来刷新。 缓存会存储列表集合或对象(无论查询方法返回什么)的 1024 个引用。 缓存会被视为是 read/write(可读/可写)的缓存,意味着对象检索不是共享的, 而且可以安全地被调用者修改,而不干扰其他调用者或线程所做的潜在修改。 所有的这些属性都可以通过缓存元素的属性来修改。 比如: 这个更高级的配置创建了一个 FIFO 缓存,并每隔 60 秒刷新,存数结果对象或列表的 512 个引用,而且返回的对象被认为是只读的,因此在不同线程中的调用者之间修改它们会 导致冲突。可用的收回策略有, 默认的是 LRU: LRU – 最近最少使用的:移除最长时间不被使用的对象。 FIFO – 先进先出:按对象进入缓存的顺序来移除它们。 SOFT – 软引用:移除基于垃圾回收器状态和软引用规则的对象。 WEAK – 弱引用:更积极地移除基于垃圾收集器状态和弱引用规则的对象。 flushInterval(刷新间隔)可以被设置为任意的正整数,而且它们代表一个合理的毫秒 形式的时间段。默认情况是不设置,也就是没有刷新间隔,缓存仅仅调用语句时刷新。 size(引用数目)可以被设置为任意正整数,要记住你缓存的对象数目和你运行环境的 可用内存资源数目。默认值是1024。 readOnly(只读)属性可以被设置为 true 或 false。只读的缓存会给所有调用者返回缓 存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。可读写的缓存 会返回缓存对象的拷贝(通过序列化) 。这会慢一些,但是安全,因此默认是 false。 3.相同点Hibernate和Mybatis的二级缓存除了采用系统默认的缓存机制外，都可以通过实现你自己的缓存或为其他第三方缓存方案，创建适配器来完全覆盖缓存行为。 4.不同点Hibernate的二级缓存配置在SessionFactory生成的配置文件中进行详细配置，然后再在具体的表-对象映射中配置是那种缓存。 MyBatis的二级缓存配置都是在每个具体的表-对象映射中进行详细配置，这样针对不同的表可以自定义不同的缓存机制。并且Mybatis可以在命名空间中共享相同的缓存配置和实例，通过Cache-ref来实现。 5.两者比较因为Hibernate对查询对象有着良好的管理机制，用户无需关心SQL。所以在使用二级缓存时如果出现脏数据，系统会报出错误并提示。 而MyBatis在这一方面，使用二级缓存时需要特别小心。如果不能完全确定数据更新操作的波及范围，避免Cache的盲目使用。否则，脏数据的出现会给系统的正常运行带来很大的隐患。 第六章 Hibernate与Mybatis对比总结1.两者相同点Hibernate与MyBatis都可以是通过SessionFactoryBuider由XML配置文件生成SessionFactory，然后由SessionFactory 生成Session，最后由Session来开启执行事务和SQL语句。其中SessionFactoryBuider，SessionFactory，Session的生命周期都是差不多的。 Hibernate和MyBatis都支持JDBC和JTA事务处理。 2.Mybatis优势MyBatis可以进行更为细致的SQL优化，可以减少查询字段。 MyBatis容易掌握，而Hibernate门槛较高。 3.Hibernate优势Hibernate的DAO层开发比MyBatis简单，Mybatis需要维护SQL和结果映射。 Hibernate对对象的维护和缓存要比MyBatis好，对增删改查的对象的维护要方便。 Hibernate数据库移植性很好，MyBatis的数据库移植性不好，不同的数据库需要写不同SQL。 Hibernate有更好的二级缓存机制，可以使用第三方缓存。MyBatis本身提供的缓存机制不佳。 他人总结 Hibernate功能强大，数据库无关性好，O/R映射能力强，如果你对Hibernate相当精通，而且对Hibernate进行了适当的封装，那么你的项目整个持久层代码会相当简单，需要写的代码很少，开发速度很快，非常爽。 Hibernate的缺点就是学习门槛不低，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡取得平衡，以及怎样用好Hibernate方面需要你的经验和能力都很强才行。 iBATIS入门简单，即学即用，提供了数据库查询的自动对象绑定功能，而且延续了很好的SQL使用经验，对于没有那么高的对象模型要求的项目来说，相当完美。 iBATIS的缺点就是框架还是比较简陋，功能尚有缺失，虽然简化了数据绑定代码，但是整个底层数据库查询实际还是要自己写的，工作量也比较大，而且不太容易适应快速数据库修改。]]></content>
      <categories>
        <category>hibernate-mybatis</category>
      </categories>
      <tags>
        <tag>hibernate</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis完善篇（逆向工程/spring整合mybatis）]]></title>
    <url>%2F2017%2F12%2F28%2Fmybatis-3%2F</url>
    <content type="text"><![CDATA[本篇内容 1.Mybatis的逆向工程 2.spring整合mybatis 一.Mybatis的逆向工程使用官方网站的mapper自动生成工具mybatis-generator-core-1.3.2来生成po类和mapper映射文件。 作用:mybatis官方提供逆向工程,可以使用它通过数据库中的表来自动生成Mapper接口和映射文件(单表增删改查)和Po类. 导入的jar包有: 1.第一步：mapper生成配置文件：在generatorConfig.xml中配置mapper生成的详细信息，注意改下几点： 1、添加要生成的数据库表 2、po文件所在包路径 3、mapper文件所在包路径 配置文件如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt; &lt;generatorConfiguration&gt; &lt;context id=&quot;testTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt; &lt;/commentGenerator&gt; &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/mybatis&quot; userId=&quot;root&quot; password=&quot;admin&quot;&gt; &lt;/jdbcConnection&gt; &lt;!-- &lt;jdbcConnection driverClass=&quot;oracle.jdbc.OracleDriver&quot; connectionURL=&quot;jdbc:oracle:thin:@127.0.0.1:1521:yycg&quot; userId=&quot;yycg&quot; password=&quot;yycg&quot;&gt; &lt;/jdbcConnection&gt; --&gt; &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 NUMERIC 类型解析为java.math.BigDecimal --&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt; &lt;/javaTypeResolver&gt; &lt;!-- targetProject:生成PO类的位置 --&gt; &lt;javaModelGenerator targetPackage=&quot;cn.itcast.ssm.po&quot; targetProject=&quot;.\src&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;!-- 从数据库返回的值被清理前后的空格 --&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;!-- targetProject:mapper映射文件生成的位置 --&gt; &lt;sqlMapGenerator targetPackage=&quot;cn.itcast.ssm.mapper&quot; targetProject=&quot;.\src&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- targetPackage：mapper接口生成的位置 --&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;cn.itcast.ssm.mapper&quot; targetProject=&quot;.\src&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定数据库表 --&gt; &lt;table tableName=&quot;items&quot;&gt;&lt;/table&gt; &lt;table tableName=&quot;orders&quot;&gt;&lt;/table&gt; &lt;table tableName=&quot;orderdetail&quot;&gt;&lt;/table&gt; &lt;table tableName=&quot;user&quot;&gt;&lt;/table&gt; &lt;!-- &lt;table schema=&quot;&quot; tableName=&quot;sys_user&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;sys_role&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;sys_permission&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;sys_user_role&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;sys_role_permission&quot;&gt;&lt;/table&gt; --&gt; &lt;!-- 有些表的字段需要指定java类型 &lt;table schema=&quot;&quot; tableName=&quot;&quot;&gt; &lt;columnOverride column=&quot;&quot; javaType=&quot;&quot; /&gt; &lt;/table&gt; --&gt; &lt;/context&gt; &lt;/generatorConfiguration&gt; 2.第二步：使用java类生成mapper文件：Public void generator() throws Exception{ List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; File configFile = new File(&quot;generatorConfig.xml&quot;); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); } Public static void main(String[] args) throws Exception { try { GeneratorSqlmap generatorSqlmap = new GeneratorSqlmap(); generatorSqlmap.generator(); } catch (Exception e) { e.printStackTrace(); } } 3.第三步：拷贝生成的mapper文件到工程中指定的目录中1)Mapper.xmlMapper.xml的文件拷贝至mapper目录内 2)Mapper.javaMapper.java的文件拷贝至mapper 目录内 注意：mapper xml文件和mapper.java文件在一个目录内且文件名相同。 4.第四步Mapper接口测试学会使用mapper自动生成的增、删、改、查方法。 //删除符合条件的记录 int deleteByExample(UserExample example); //根据主键删除 int deleteByPrimaryKey(String id); //插入对象所有字段 int insert(User record); //插入对象不为空的字段 int insertSelective(User record); //自定义查询条件查询结果集 List&lt;User&gt; selectByExample(UserExample example); //根据主键查询 UserselectByPrimaryKey(String id); //根据主键将对象中不为空的值更新至数据库 int updateByPrimaryKeySelective(User record); //根据主键将对象中所有字段的值更新至数据库 int updateByPrimaryKey(User record); 5.逆向工程注意事项1)Mapper文件内容不覆盖而是追加XXXMapper.xml文件已经存在时， 如果进行重新生成则mapper.xml文件内容不被覆盖而是进行内容追加，结果导致mybatis解析失败。 解决方法：删除原来已经生成的mapper xml文件再进行生成。 Mybatis自动生成的po及mapper.java文件不是内容而是直接覆盖没有此问题。 2)Table schema问题下边是关于针对oracle数据库表生成代码的schema问题： Schma即数据库模式，oracle中一个用户对应一个schema，可以理解为用户就是schema。当Oralce数据库存在多个schema可以访问相同的表名时，使用mybatis生成该表的mapper.xml将会出现mapper.xml内容重复的问题，结果导致mybatis解析错误。 解决方法：在table中填写schema，如下： &lt;table schema=&quot;XXXX&quot; tableName=&quot; &quot; &gt; XXXX即为一个schema的名称，生成后将mapper.xml的schema前缀批量去掉， 如果不去掉当oracle用户变更了sql语句将查询失败。 快捷操作方式：mapper.xml文件中批量替换：“from XXXX.”为空 Oracle查询对象的schema可从dba_objects中查询，如下： select * from dba_objects 二.spring整合mybatis1.整合思路1、SqlSessionFactory对象应该放到spring容器中作为单例存在。 2、传统dao的开发方式中，应该从spring容器中获得sqlsession对象。 3、Mapper代理形式中，应该从spring容器中直接获得mapper的代理对象。 4、数据库的连接以及数据库连接池事务管理都交给spring容器来完成。 2.整合需要的jar包1、spring的jar包 2、Mybatis的jar包 3、Spring+mybatis的整合包。 4、Mysql的数据库驱动jar包。 5、数据库连接池的jar包。 3.整合的步骤第一步：创建一个java工程。 第二步：导入jar包。（上面提到的jar包） 第三步：mybatis的配置文件sqlmapConfig.xml 第四步：编写Spring的配置文件 1、数据库连接及连接池 2、事务管理（暂时可以不配置） 3、sqlsessionFactory对象，配置到spring容器中 4、mapeer代理对象或者是dao实现类配置到spring容器中。 第五步：编写dao或者mapper文件 第六步：测试。 1)SqlMapConfig.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=&quot;cn.itcast.mybatis.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;mappers&gt; &lt;mapper resource=&quot;sqlmap/User.xml&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 2)applicationContext.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd&quot;&gt; &lt;!-- 加载配置文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:db.properties&quot; /&gt; &lt;!-- 数据库连接池 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt; &lt;property name=&quot;maxActive&quot; value=&quot;10&quot; /&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;5&quot; /&gt; &lt;/bean&gt; &lt;!-- mapper配置 --&gt; &lt;!-- 让spring管理sqlsessionfactory 使用mybatis和spring整合包中的 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!-- 加载mybatis的全局配置文件 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis/SqlMapConfig.xml&quot; /&gt; &lt;/bean&gt; &lt;/beans&gt; 3)db.propertiesjdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8 jdbc.username=root jdbc.password=root 4.Dao的开发三种dao的实现方式： 1、传统dao的开发方式 2、使用mapper代理形式开发方式 3、使用扫描包配置mapper代理。 1)传统dao的开发方式接口+实现类来完成。需要dao实现类需要继承SqlsessionDaoSupport类 1.Dao实现类 public class UserDaoImpl extends SqlSessionDaoSupport implements UserDao { @Override public User findUserById(int id) throws Exception { SqlSession session = getSqlSession(); User user = session.selectOne(&quot;test.findUserById&quot;, id); //不能关闭SqlSession，让spring容器来完成 //session.close(); return user; } @Override public void insertUser(User user) throws Exception { SqlSession session = getSqlSession(); session.insert(&quot;test.insertUser&quot;, user); session.commit(); //session.close(); } } 2.配置dao 把dao实现类配置到spring容器中 &lt;!-- 配置UserDao实现类 --&gt; &lt;bean id=&quot;userDao&quot; class=&quot;cn.itcast.dao.UserDaoImpl&quot;&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&gt; &lt;/bean&gt; 3.测试方法 初始化: private ApplicationContext applicationContext; @Before public void setUp() throws Exception{ String configLocation = &quot;classpath:spring/ApplicationContext.xml&quot;; //初始化spring运行环境 applicationContext = new ClassPathXmlApplicationContext(configLocation); } 测试: @Test public void testFindUserById() throws Exception { UserDao userDao = (UserDao) applicationContext.getBean(&quot;userDao&quot;); User user = userDao.findUserById(1); System.out.println(user); } 2)Mapper代理形式开发dao1.开发mapper接口 开发mapper文件 2.配置mapper代理 &lt;!-- 配置mapper代理对象 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt; &lt;property name=&quot;mapperInterface&quot; value=&quot;cn.itcast.mybatis.mapper.UserMapper&quot;/&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 3.测试方法 public class UserMapperTest { private ApplicationContext applicationContext; @Before public void setUp() throws Exception { applicationContext = new ClassPathXmlApplicationContext(&quot;classpath:spring/applicationContext.xml&quot;); } @Test public void testGetUserById() { UserMapper userMapper = applicationContext.getBean(UserMapper.class); User user = userMapper.getUserById(1); System.out.println(user); } } 3.扫描包形式配置mapper&lt;!-- 使用扫描包的形式来创建mapper代理对象 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;cn.itcast.mybatis.mapper&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 每个mapper代理对象的id就是类名，首字母小写]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springmvc基础篇(springmvc以及SSM架构讲解/基础参数绑定以及传递)]]></title>
    <url>%2F2015%2F12%2F21%2Fspringmvc1%2F</url>
    <content type="text"><![CDATA[本片内容 1、Springmvc介绍 2、入门程序 3、Springmvc架构讲解 a)框架结构 b)组件说明 4、Springmvc整合mybatis 5、参数绑定 a)Springmvc默认支持的类型 b)简单数据类型 c)Pojo类型 d)Pojo包装类型 e)自定义参数绑定 6、Springmvc和struts2的区别 一.Spring web mvc介绍Spring web mvc和Struts2都属于表现层的框架,它是Spring框架的一部分,我们可以从Spring的整体结构中看得出来： 二.入门程序1.开发环境本教程使用环境：Jdk：jdk1.7.0_72 Eclipse：mars Tomcat：apache-tomcat-7.0.53 Springmvc：4.1.3 2.需求使用springmvc实现商品列表的展示。 3.需求分析请求的url：/itemList.action 参数：无 数据：静态数据 4.开发步骤第一步：创建一个javaweb工程第二步：导入jar包 第三步：创建itemList.jsp把参考资料中的itemList.jsp复制到工程的/WEB-INF/jsp目录下。 第四步：创建ItemsControllerItemController是一个普通的java类，不需要实现任何接口，只需要在类上添加@Controller注解即可。@RequestMapping注解指定请求的url，其中“.action”可以加也可以不加。在ModelAndView对象中，将视图设置为“/WEB-INF/jsp/itemList.jsp” @Controller publicclass ItemController { @RequestMapping(&quot;/itemList&quot;) public ModelAndView itemList() throws Exception { List&lt;Items&gt;itemList = new ArrayList&lt;&gt;(); //商品列表 Items items_1 = new Items(); items_1.setName(&quot;联想笔记本_3&quot;); items_1.setPrice(6000f); items_1.setDetail(&quot;ThinkPad T430 联想笔记本电脑！&quot;); Items items_2 = new Items(); items_2.setName(&quot;苹果手机&quot;); items_2.setPrice(5000f); items_2.setDetail(&quot;iphone6苹果手机！&quot;); itemList.add(items_1); itemList.add(items_2); //创建modelandView对象 ModelAndView modelAndView = new ModelAndView(); //添加model modelAndView.addObject(&quot;itemList&quot;, itemList); //添加视图 modelAndView.setViewName(&quot;/WEB-INF/jsp/itemList.jsp&quot;); // modelAndView.setViewName(&quot;itemsList&quot;); returnmodelAndView; } } 商品数据使用Items类描述，可以使用参考资料中提供的pojo类， 第五步：创建springmvc.xml&lt;?xmlversion=&quot;1.0&quot;encoding=&quot;UTF-8&quot;?&gt; &lt;beansxmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&gt; &lt;context:component-scanbase-package=&quot;cn.itcast.springmvc.controller&quot;/&gt; &lt;/beans&gt; 第六步：配置前端控制器在web.xml中添加DispatcherServlet的配置。 &lt;!-- 前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 三.Springmvc架构1.架构流程1、用户发送请求至前端控制器DispatcherServlet 2、DispatcherServlet收到请求调用HandlerMapping处理器映射器。 3、处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 4、DispatcherServlet通过HandlerAdapter处理器适配器调用处理器 5、执行处理器(Controller，也叫后端控制器)。 6、Controller执行完成返回ModelAndView 7、HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet 8、DispatcherServlet将ModelAndView传给ViewReslover视图解析器 9、ViewReslover解析后返回具体View 10、DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。 11、DispatcherServlet响应用户 2.组件说明以下组件通常使用框架提供实现： DispatcherServlet：前端控制器用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。 HandlerMapping：处理器映射器HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 Handler：处理器Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。 HandlAdapter：处理器适配器通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。 View Resolver：视图解析器View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 View：视图springmvc框架提供了很多的View视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是jsp。 一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。 说明：在springmvc的各个组件中，处理器映射器、处理器适配器、视图解析器称为springmvc的三大组件。 需要用户开放的组件有handler、view 3.框架默认加载组件 4.注解映射器和适配器1).组件扫描器使用组件扫描器省去在spring容器配置每个controller类的繁琐。使用context:component-scan自动扫描标记@controller的控制器类，配置如下： &lt;!-- 扫描controller注解,多个包中间使用半角逗号分隔 --&gt; &lt;context:component-scanbase-package=&quot;cn.itcast.springmvc.controller.first&quot;/&gt; 2).RequestMappingHandlerMapping注解式处理器映射器，对类中标记@ResquestMapping的方法进行映射，根据ResquestMapping定义的url匹配ResquestMapping标记的方法，匹配成功返回HandlerMethod对象给前端控制器，HandlerMethod对象中封装url对应的方法Method。 从spring3.1版本开始，废除了DefaultAnnotationHandlerMapping的使用，推荐使用RequestMappingHandlerMapping完成注解式处理器映射。 配置如下： &lt;!--注解映射器 --&gt; &lt;beanclass=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt; 注解描述：@RequestMapping：定义请求url到处理器功能方法的映射 3).RequestMappingHandlerAdapter注解式处理器适配器，对标记@ResquestMapping的方法进行适配。 从spring3.1版本开始，废除了AnnotationMethodHandlerAdapter的使用，推荐使用RequestMappingHandlerAdapter完成注解式处理器适配。 配置如下： &lt;!--注解适配器 --&gt; &lt;beanclass=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt; 4).mvc:annotation-drivenspringmvc使用mvc:annotation-driven自动加载RequestMappingHandlerMapping和RequestMappingHandlerAdapter，可用在springmvc.xml配置文件中使用mvc:annotation-driven替代注解处理器和适配器的配置。 5.视图解析器在springmvc.xml文件配置如下： &lt;beanclass=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;propertyname=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt; &lt;propertyname=&quot;prefix&quot;value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;propertyname=&quot;suffix&quot;value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; InternalResourceViewResolver：支持JSP视图解析 viewClass：JstlView表示JSP模板页面需要使用JSTL标签库，所以classpath中必须包含jstl的相关jar 包。此属性可以不设置，默认为JstlView。 prefix 和suffix：查找视图页面的前缀和后缀，最终视图的址为： 前缀+逻辑视图名+后缀，逻辑视图名需要在controller中返回ModelAndView指定，比如逻辑视图名为hello，则最终返回的jsp视图地址 “WEB-INF/jsp/hello.jsp” 四.整合mybatis为了更好的学习 springmvc和mybatis整合开发的方法，需要将springmvc和mybatis进行整合。 整合目标：控制层采用springmvc、持久层使用mybatis实现。 1.需求实现商品查询列表，从mysql数据库查询商品信息。 2.jar包包括：spring（包括springmvc）、mybatis、mybatis-spring整合包、数据库驱动、第三方连接池。 参考：“mybatis与springmvc整合全部jar包”目录 3.工程搭建1)整合思路Dao层： 1、SqlMapConfig.xml，空文件即可。需要文件头。 2、applicationContext-dao.xml。 a)数据库连接池 b)SqlSessionFactory对象，需要spring和mybatis整合包下的。 c)配置mapper文件扫描器。 Service层： 1、applicationContext-service.xml包扫描器，扫描@service注解的类。 2、applicationContext-trans.xml配置事务。 表现层： Springmvc.xml 1、包扫描器，扫描@Controller注解的类。 2、配置注解驱动。 3、视图解析器 Web.xml 配置前端控制器。 2)sqlMapConfig.xml在classpath下创建mybatis/sqlMapConfig.xml &lt;?xmlversion=&quot;1.0&quot;encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPEconfiguration PUBLIC&quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;/configuration&gt; 3)applicationContext-dao.xml配置数据源、配置SqlSessionFactory、mapper扫描器。 &lt;?xmlversion=&quot;1.0&quot;encoding=&quot;UTF-8&quot;?&gt; &lt;beansxmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd&quot;&gt; &lt;!-- 加载配置文件 --&gt; &lt;context:property-placeholderlocation=&quot;classpath:db.properties&quot;/&gt; &lt;!-- 数据库连接池 --&gt; &lt;beanid=&quot;dataSource&quot;class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;propertyname=&quot;driverClassName&quot;value=&quot;${jdbc.driver}&quot;/&gt; &lt;propertyname=&quot;url&quot;value=&quot;${jdbc.url}&quot;/&gt; &lt;propertyname=&quot;username&quot;value=&quot;${jdbc.username}&quot;/&gt; &lt;propertyname=&quot;password&quot;value=&quot;${jdbc.password}&quot;/&gt; &lt;propertyname=&quot;maxActive&quot;value=&quot;10&quot;/&gt; &lt;propertyname=&quot;maxIdle&quot;value=&quot;5&quot;/&gt; &lt;/bean&gt; &lt;!-- mapper配置 --&gt; &lt;!-- 让spring管理sqlsessionfactory 使用mybatis和spring整合包中的 --&gt; &lt;beanid=&quot;sqlSessionFactory&quot;class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 数据库连接池 --&gt; &lt;propertyname=&quot;dataSource&quot;ref=&quot;dataSource&quot;/&gt; &lt;!-- 加载mybatis的全局配置文件 --&gt; &lt;propertyname=&quot;configLocation&quot;value=&quot;classpath:mybatis/SqlMapConfig.xml&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置Mapper扫描器 --&gt; &lt;beanclass=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;propertyname=&quot;basePackage&quot;value=&quot;cn.itcast.springmvc.mapper&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; Db.properties jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/springmvc?characterEncoding=utf-8 jdbc.username=root jdbc.password=root 4)applicationContext-service.xml&lt;?xmlversion=&quot;1.0&quot;encoding=&quot;UTF-8&quot;?&gt; &lt;beansxmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd&quot;&gt; &lt;context:component-scanbase-package=&quot;cn.itcast.springmvc.service&quot;/&gt; &lt;/beans&gt; 5)applicationContext-transaction.xml&lt;?xmlversion=&quot;1.0&quot;encoding=&quot;UTF-8&quot;?&gt; &lt;beansxmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd&quot;&gt; &lt;!-- 事务管理器 --&gt; &lt;beanid=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!-- 数据源 --&gt; &lt;propertyname=&quot;dataSource&quot;ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!-- 通知 --&gt; &lt;tx:adviceid=&quot;txAdvice&quot;transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;!-- 传播行为 --&gt; &lt;tx:methodname=&quot;save*&quot;propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:methodname=&quot;insert*&quot;propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:methodname=&quot;delete*&quot;propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:methodname=&quot;update*&quot;propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:methodname=&quot;find*&quot;propagation=&quot;SUPPORTS&quot;read-only=&quot;true&quot;/&gt; &lt;tx:methodname=&quot;get*&quot;propagation=&quot;SUPPORTS&quot;read-only=&quot;true&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 切面 --&gt; &lt;aop:config&gt; &lt;aop:advisoradvice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* cn.itcast.springmvc.service.*.*(..))&quot;/&gt; &lt;/aop:config&gt; &lt;/beans&gt; 6)springmvc.xml&lt;?xmlversion=&quot;1.0&quot;encoding=&quot;UTF-8&quot;?&gt; &lt;beansxmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&gt; &lt;!-- 扫描带Controller注解的类 --&gt; &lt;context:component-scanbase-package=&quot;cn.itcast.springmvc.controller&quot;/&gt; &lt;!-- 加载注解驱动 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 视图解析器 --&gt; &lt;beanclass=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver &quot;&gt; &lt;propertyname=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt; &lt;!-- jsp前缀 --&gt; &lt;propertyname=&quot;prefix&quot;value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;!-- jsp后缀 --&gt; &lt;propertyname=&quot;suffix&quot;value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; 7)web.xml&lt;?xmlversion=&quot;1.0&quot;encoding=&quot;UTF-8&quot;?&gt; &lt;web-appxmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; id=&quot;WebApp_ID&quot;version=&quot;2.5&quot;&gt; &lt;display-name&gt;springmvc-web&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 加载spring容器 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/applicationContext-*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 4.Daomybatis逆向工程。 5.Service1、Service由spring管理 2、spring对Service进行事务控制。 1)ItemService接口publicinterface ItemService { List&lt;Items&gt; getItemsList(); } 2)ItemServiceImpl实现类@Service publicclass ItemServiceImpl implements ItemService { @Autowired private ItemMapper itemMapper; @Override public List&lt;Items&gt; getItemsList() { List&lt;Items&gt;itemList = itemMapper.getItemList(); returnitemList; } } 6.Controller@Controller publicclass ItemController { @Autowired private ItemService itemService; @RequestMapping(&quot;/itemList&quot;) public ModelAndView getItemList() { List&lt;Items&gt;list = itemService.getItemsList(); ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(&quot;itemList&quot;, list); modelAndView.setViewName(&quot;itemList&quot;); returnmodelAndView; } } 7.测试访问：http://localhost:8080/springmvc-web/itemList.action 五.参数绑定1.绑定简单数据类型1)需求打开商品编辑页面，展示商品信息。 2)需求分析编辑商品信息，需要根据商品id查询商品信息，然后展示到页面。 请求的url：/itemEdit.action 参数：id（商品id） 响应结果：商品编辑页面，展示商品详细信息。 3)Service@Override public Items getItemById(intid) { Items items = itemMapper.getItemById(id); returnitems; } 4)Controller参数绑定要根据id查询商品数据，需要从请求的参数中把请求的id取出来。Id应该包含在Request对象中。可以从Request对象中取id。 @RequestMapping(&quot;/itemEdit&quot;) publicModelAndView itemEdit(HttpServletRequest request) { //从Request中取id String strId = request.getParameter(&quot;id&quot;); Integer id = null; //如果id有值则转换成int类型 if (strId != null&amp;&amp; !&quot;&quot;.equals(strId)) { id = newInteger(strId); } else { //出错 returnnull; } Items items = itemService.getItemById(id); //创建ModelAndView ModelAndView modelAndView = new ModelAndView(); //向jsp传递数据 modelAndView.addObject(&quot;item&quot;, items); //设置跳转的jsp页面 modelAndView.setViewName(&quot;editItem&quot;); returnmodelAndView; } 如果想获得Request对象只需要在Controller方法的形参中添加一个参数即可。Springmvc框架会自动把Request对象传递给方法。 5)默认支持的参数类型处理器形参中添加如下类型的参数处理适配器会默认识别并进行赋值。 a)HttpServletRequest 通过request对象获取请求信息 b)HttpServletResponse 通过response处理响应信息 c)HttpSession 通过session对象得到session中存放的对象 d)Model/ModelMap ModelMap是Model接口的实现类，通过Model或ModelMap向页面传递数据，如下： //调用service查询商品信息 Items item = itemService.findItemById(id); model.addAttribute(&quot;item&quot;, item); 页面通过${item.XXXX}获取item对象的属性值。 使用Model和ModelMap的效果一样，如果直接使用Model，springmvc会实例化ModelMap。 如果使用Model则可以不使用ModelAndView对象，Model对象可以向页面传递数据，View对象则可以使用String返回值替代。不管是Model还是ModelAndView，其本质都是使用Request对象向jsp传递数据。 如果使用Model则方法可以改造成： @RequestMapping(&quot;/itemEdit&quot;) publicString itemEdit(HttpServletRequest request, Model model) { //从Request中取id String strId = request.getParameter(&quot;id&quot;); Integer id = null; //如果id有值则转换成int类型 if (strId != null&amp;&amp; !&quot;&quot;.equals(strId)) { id = newInteger(strId); } else { //出错 returnnull; } Items items = itemService.getItemById(id); //创建ModelAndView //ModelAndView modelAndView = new ModelAndView(); //向jsp传递数据 //modelAndView.addObject(&quot;item&quot;, items); model.addAttribute(&quot;item&quot;, items); //设置跳转的jsp页面 //modelAndView.setViewName(&quot;editItem&quot;); //return modelAndView; return&quot;editItem&quot;; } 6)绑定简单类型当请求的参数名称和处理器形参名称一致时会将请求参数与形参进行绑定。从Request取参数的方法可以进一步简化。 @RequestMapping(&quot;/itemEdit&quot;) public String itemEdit(Integer id, Model model) { Items items = itemService.getItemById(id); //向jsp传递数据 model.addAttribute(&quot;item&quot;, items); //设置跳转的jsp页面 return&quot;editItem&quot;; } a)支持的数据类型 参数类型推荐使用包装数据类型，因为基础数据类型不可以为null 整形：Integer、int 字符串：String 单精度：Float、float 双精度：Double、double 布尔型：Boolean、boolean 说明：对于布尔类型的参数，请求的参数值为true或false。 处理器方法： public String editItem(Model model,Integer id,Boolean status) throws Exception 请求url： http://localhost:8080/xxx.action?id=2&amp;status=false b)@RequestParam 使用@RequestParam常用于处理简单类型的绑定。 value：参数名字，即入参的请求参数名字，如value=“item_id”表示请求的参数区中的名字为item_id的参数的值将传入； required：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报；TTP Status 400 - Required Integer parameter ‘XXXX’ is not present defaultValue：默认值，表示如果请求中没有同名参数时的默认值 定义如下： public String editItem(@RequestParam(value=”item_id”,required=true) String id) { } 形参名称为id，但是这里使用value=”item_id”限定请求的参数名为item_id，所以页面传递参数的名必须为item_id。 注意：如果请求参数中没有item_id将跑出异常： HTTP Status 500 - Required Integer parameter ‘item_id’ is not present 这里通过required=true限定item_id参数为必需传递，如果不传递则报400错误，可以使用defaultvalue设置默认值，即使required=true也可以不传item_id参数值 2.绑定pojo类型1)需求将页面修改后的商品信息保存到数据库中。 2)需求分析请求的url：/updateitem.action 参数：表单中的数据。 响应内容：更新成功页面 3)使用pojo接收表单数据如果提交的参数很多，或者提交的表单中的内容很多的时候可以使用pojo接收数据。要求pojo对象中的属性名和表单中input的name属性一致。 页面定义如下: &lt;input type=&quot;text&quot; name=&quot;name&quot;/&gt; &lt;input type=&quot;text&quot; name=&quot;price&quot;/&gt; Pojo定义： 请求的参数名称和pojo的属性名称一致，会自动将请求参数赋值给pojo的属性。 @RequestMapping(&quot;/updateitem&quot;) public String updateItem(Items items) { itemService.updateItem(items); return&quot;success&quot;; } 注意：提交的表单中不要有日期类型的数据，否则会报400错误。如果想提交日期类型的数据需要用到后面的自定义参数绑定的内容。 4)解决post乱码问题在web.xml中加入： &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 以上可以解决post请求乱码问题。 对于get请求中文参数出现乱码解决方法有两个： 修改tomcat配置文件添加编码与工程编码一致，如下： &lt;Connector URIEncoding=&quot;utf-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt; 另外一种方法对参数进行重新编码： String userName new String(request.getParamter(&quot;userName&quot;).getBytes(&quot;ISO8859-1&quot;),&quot;utf-8&quot;) ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码 3.绑定包装pojo1)需求使用包装的pojo接收商品信息的查询条件。 2)需求分析包装对象定义如下： PublicclassQueryVo { privateItemsitems; } 页面定义： &lt;input type=&quot;text&quot; name=&quot;items.name&quot; /&gt; &lt;input type=&quot;text&quot; name=&quot;items.price&quot; /&gt; Controller方法定义如下： public String useraddsubmit(Model model,QueryVoqueryVo)throws Exception{ System.out.println(queryVo.getItems()); 3)接收查询条件@RequestMapping(&quot;/queryitem&quot;) public String queryItem(QueryVo queryVo) { System.out.println(queryVo.getItems().getName()); System.out.println(queryVo.getItems().getPrice()); returnnull; } 4.自定义参数绑定1)需求在商品修改页面可以修改商品的生产日期，并且根据业务需求自定义日期格式。 2)需求分析由于日期数据有很多种格式，所以springmvc没办法把字符串转换成日期类型。所以需要自定义参数绑定。前端控制器接收到请求后，找到注解形式的处理器适配器，对RequestMapping标记的方法进行适配，并对方法中的形参进行参数绑定。在springmvc这可以在处理器适配器上自定义Converter进行参数绑定。如果使用mvc:annotation-driven/可以在此标签上进行扩展。 3)自定义Converterpublicclass DateConverter implements Converter&lt;String, Date&gt; { @Override public Date convert(String source) { SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); try { returnsimpleDateFormat.parse(source); } catch (ParseException e) { e.printStackTrace(); } returnnull; } } 4)配置Converter&lt;!-- 加载注解驱动 --&gt; &lt;mvc:annotation-drivenconversion-service=&quot;conversionService&quot;/&gt; &lt;!-- 转换器配置 --&gt; &lt;beanid=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt; &lt;propertyname=&quot;converters&quot;&gt; &lt;set&gt; &lt;beanclass=&quot;cn.itcast.springmvc.convert.DateConverter&quot;/&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; 5)配置方式2（了解）&lt;?xmlversion=&quot;1.0&quot;encoding=&quot;UTF-8&quot;?&gt; &lt;beansxmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&gt; &lt;!-- 扫描带Controller注解的类 --&gt; &lt;context:component-scanbase-package=&quot;cn.itcast.springmvc.controller&quot;/&gt; &lt;!-- 转换器配置 --&gt; &lt;beanid=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryB ean&quot;&gt; &lt;propertyname=&quot;converters&quot;&gt; &lt;set&gt; &lt;beanclass=&quot;cn.itcast.springmvc.convert.DateConverter&quot;/&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 自定义webBinder --&gt; &lt;beanid=&quot;customBinder&quot; class=&quot;org.springframework.web.bind.support.ConfigurableWebBindingInitializer&quot;&gt; &lt;propertyname=&quot;conversionService&quot;ref=&quot;conversionService&quot;/&gt; &lt;/bean&gt; &lt;!--注解适配器 --&gt; &lt;beanclass=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMapp ingHandlerAdapter&quot;&gt; &lt;propertyname=&quot;webBindingInitializer&quot;ref=&quot;customBinder&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 注解处理器映射器 --&gt; &lt;beanclass=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMapp ingHandlerMapping&quot;/&gt; &lt;!-- 加载注解驱动 --&gt; &lt;!-- &lt;mvc:annotation-driven/&gt; --&gt; &lt;!-- 视图解析器 --&gt; &lt;beanclass=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver &quot;&gt; &lt;propertyname=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt; &lt;!-- jsp前缀 --&gt; &lt;propertyname=&quot;prefix&quot;value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;!-- jsp后缀 --&gt; &lt;propertyname=&quot;suffix&quot;value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; 注意：此方法需要独立配置处理器映射器、适配器，不再使用mvc:annotation-driven/ 六.springmvc与struts2不同1、springmvc的入口是一个servlet即前端控制器，而struts2入口是一个filter过虑器。 2、springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。 3、Struts采用值栈存储请求和响应的数据，通过OGNL存取数据， springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl。]]></content>
      <categories>
        <category>springmvc</category>
      </categories>
      <tags>
        <tag>springmvc</tag>
        <tag>springmvc基础篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springmvc高级篇(springmvc高级参数绑定/springmvc自带各种组件及其应用)]]></title>
    <url>%2F2015%2F12%2F21%2Fspringmvc2%2F</url>
    <content type="text"><![CDATA[本篇内容 1、高级参数绑定 a)数组类型的参数绑定 b)List类型的绑定 2、@RequestMapping注解的使用 3、Controller方法返回值 4、Springmvc中异常处理 5、图片上传处理 6、Json数据交互 7、Springmvc实现Restful 8、拦截器 一.高级参数绑定1.绑定数组1)需求在商品列表页面选中多个商品，然后删除。 2)需求分析此功能要求商品列表页面中的每个商品前有一个checkbook，选中多个商品后点击删除按钮把商品id传递给Controller，根据商品id删除商品信息。 3)Jsp中实现：&lt;c:forEach items=&quot;${itemList }&quot; var=&quot;item&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;input name=&quot;ids&quot; value=&quot;${item.id}&quot; type=&quot;checkbox&quot;&gt;&lt;/td&gt; &lt;td&gt;${item.name }&lt;/td&gt; &lt;td&gt;${item.price }&lt;/td&gt; &lt;td&gt;&lt;fmt:formatDate value=&quot;${item.createtime}&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt;&lt;/td&gt; &lt;td&gt;${item.detail }&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;${pageContext.request.contextPath }/itemEdit.action?id=${item.id}&quot;&gt;修改&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; 生成html代码如下：页面选中多个checkbox向controller方法传递 &lt;table width=&quot;100%&quot; border=1&gt; &lt;tr&gt; &lt;td&gt;商品名称&lt;/td&gt; &lt;td&gt;商品价格&lt;/td&gt; &lt;td&gt;生产日期&lt;/td&gt; &lt;td&gt;商品描述&lt;/td&gt; &lt;td&gt;操作&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input name=&quot;ids&quot; value=&quot;1&quot; type=&quot;checkbox&quot;&gt;&lt;/td&gt; &lt;td&gt;台式机&lt;/td&gt; &lt;td&gt;3000.0&lt;/td&gt; &lt;td&gt;2016-02-03 13:22:53&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;/springmvc-web/itemEdit.action?id=1&quot;&gt;修改&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input name=&quot;ids&quot; value=&quot;2&quot; type=&quot;checkbox&quot;&gt;&lt;/td&gt; &lt;td&gt;笔记本&lt;/td&gt; &lt;td&gt;6000.0&lt;/td&gt; &lt;td&gt;2015-02-09 13:22:57&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;/springmvc-web/itemEdit.action?id=2&quot;&gt;修改&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input name=&quot;ids&quot; value=&quot;3&quot; type=&quot;checkbox&quot;&gt;&lt;/td&gt; &lt;td&gt;背包&lt;/td&gt; &lt;td&gt;200.0&lt;/td&gt; &lt;td&gt;2015-02-06 13:23:02&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;/springmvc-web/itemEdit.action?id=3&quot;&gt;修改&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 4.ControllerController方法中可以用String[]接收，或者pojo的String[]属性接收。两种方式任选其一即可。定义如下： @RequestMapping(&quot;/queryitem&quot;) public String queryItem(QueryVo queryVo, String[] ids) { System.out.println(queryVo.getItems().getName()); System.out.println(queryVo.getItems().getPrice()); System.out.println(ids.toString()); return null; } 或者： 查看结果： 2.将表单的数据绑定到List1)需求实现商品数据的批量修改。 2)需求分析要想实现商品数据的批量修改，需要在商品列表中可以对商品信息进行修改，并且可以批量提交修改后的商品数据。 3)接收商品列表的pojoList中存放对象，并将定义的List放在包装类中，使用包装pojo对象接收。 4)Jsp改造页面定义如下： &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;text&quot; name=&quot; itemsList[0].id&quot; value=&quot;${item.id}&quot;/&gt; &lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; name=&quot; itemsList[0].name&quot; value=&quot;${item.name }&quot;/&gt; &lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; name=&quot; itemsList[0].price&quot; value=&quot;${item.price}&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type=&quot;text&quot; name=&quot; itemsList[1].id&quot; value=&quot;${item.id}&quot;/&gt; &lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; name=&quot; itemsList[1].name&quot; value=&quot;${item.name }&quot;/&gt; &lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; name=&quot; itemsList[1].price&quot; value=&quot;${item.price}&quot;/&gt; &lt;/td&gt; &lt;/tr&gt; Name属性必须是包装pojo的list属性+下标+元素属性。Jsp做如下改造： &lt;c:forEach items=&quot;${itemList }&quot; var=&quot;item&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;input name=&quot;ids&quot; value=&quot;${item.id}&quot; type=&quot;checkbox&quot;&gt;&lt;/td&gt; &lt;td&gt; &lt;input name=&quot;id&quot; value=&quot;${item.id}&quot; type=&quot;hidden&quot;&gt; &lt;input name=&quot;name&quot; value=&quot;${item.name }&quot; type=&quot;text&quot;&gt; &lt;/td&gt; &lt;td&gt;&lt;input name=&quot;name&quot; value=&quot;${item.price }&quot; type=&quot;text&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;input name=&quot;name&quot; value=&quot;&lt;fmt:formatDate value=&quot;${item.createtime}&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt;&quot; type=&quot;text&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;input name=&quot;name&quot; value=&quot;${item.detail }&quot; type=&quot;text&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;${pageContext.request.contextPath }/itemEdit.action?id=${item.id}&quot;&gt;修改&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; varStatus属性常用参数总结下： ${status.index} 输出行号，从0开始。 ${status.count} 输出行号，从1开始。 ${status.current} 当前这次迭代的（集合中的）项 ${status.first} 判断当前项是否为集合中的第一项，返回值为true或false ${status.last} 判断当前项是否为集合中的最后一项，返回值为true或false begin、end、step分别表示：起始序号，结束序号，跳跃步伐。 5)Contrller@RequestMapping(&quot;/queryitem&quot;) public String queryItem(QueryVo queryVo, String[] ids) { System.out.println(queryVo.getItems().getName()); System.out.println(queryVo.getItems().getPrice()); System.out.println(ids.toString()); return null; } 注意：接收List类型的数据必须是pojo的属性，方法的形参为List类型无法正确接收到数据。 二.@RequestMapping通过RequestMapping注解可以定义不同的处理器映射规则。 1.URL路径映射@RequestMapping(value=”/item”)或@RequestMapping(“/item） value的值是数组，可以将多个url映射到同一个方法 2.窄化请求映射在class上添加@RequestMapping(url)指定通用请求前缀， 限制此类下的所有方法请求url必须以请求前缀开头，通过此方法对url进行分类管理。 如下： @RequestMapping放在类名上边，设置请求前缀 @Controller @RequestMapping(&quot;/item&quot;) 方法名上边设置请求映射url： @RequestMapping放在方法名上边，如下： @RequestMapping(&quot;/queryItem &quot;) 访问地址为：/item/queryItem 3.请求方法限定限定GET方法@RequestMapping(method = RequestMethod.GET) 如果通过Post访问则报错：HTTP Status 405 - Request method ‘POST’ not supported 例如：@RequestMapping(value=”/editItem”,method=RequestMethod.GET) 限定POST方法@RequestMapping(method = RequestMethod.POST) 如果通过Post访问则报错：HTTP Status 405 - Request method ‘GET’ not supported GET和POST都可以 @RequestMapping(method={RequestMethod.GET,RequestMethod.POST}) 三.controller方法返回值1.返回ModelAndViewcontroller方法中定义ModelAndView对象并返回，对象中可添加model数据、指定view。 2.返回void在controller方法形参上可以定义request和response，使用request或response指定响应结果： 1)使用request转向页面，如下：request.getRequestDispatcher(&quot;页面路径&quot;).forward(request, response); 2)也可以通过response页面重定向：response.sendRedirect(&quot;url&quot;) 3)也可以通过response指定响应结果，例如响应json数据如下：response.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;application/json;charset=utf-8&quot;); response.getWriter().write(&quot;json串&quot;); 3.返回字符串1)逻辑视图名controller方法返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址。 //指定逻辑视图名，经过视图解析器解析为jsp物理路径：/WEB-INF/jsp/item/editItem.jsp return &quot;item/editItem&quot;; 2)Redirect重定向Contrller方法返回结果重定向到一个url地址，如下商品修改提交后重定向到商品查询方法，参数无法带到商品查询方法中。 //重定向到queryItem.action地址,request无法带过去 return &quot;redirect:queryItem.action&quot;; redirect方式相当于“response.sendRedirect()”，转发后浏览器的地址栏变为转发后的地址，因为转发即执行了一个新的request和response。由于新发起一个request原来的参数在转发时就不能传递到下一个url，如果要传参数可以/item/queryItem.action后边加参数，如下：/item/queryItem?…&amp;….. 3)forward转发controller方法执行后继续执行另一个controller方法，如下商品修改提交后转向到商品修改页面，修改商品的id参数可以带到商品修改方法中。 //结果转发到editItem.action，request可以带过去 return &quot;forward:editItem.action&quot;; forward方式相当于“request.getRequestDispatcher().forward(request,response)”，转发后浏览器地址栏还是原来的地址。转发并没有执行新的request和response，而是和转发前的请求共用一个request和response。所以转发前请求的参数在转发后仍然可以读取到。 四.异常处理器springmvc在处理请求过程中出现异常信息交由异常处理器进行处理，自定义异常处理器可以实现一个系统的异常处理逻辑。 1.异常处理思路系统中异常包括两类：预期异常和运行时异常RuntimeException 前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。系统的dao、service、controller出现都通过throws Exception向上抛出，最后由springmvc前端控制器交由异常处理器进行异常处理，如下图： 2.自定义异常类为了区别不同的异常通常根据异常类型自定义异常类，这里我们创建一个自定义系统异常，如果controller、service、dao抛出此类异常说明是系统预期处理的异常信息。 public class CustomException extends Exception { /** serialVersionUID*/ private static final long serialVersionUID = -5212079010855161498L; public CustomException(String message){ super(message); this.message = message; } //异常信息 private String message; public String getMessage() { return message; } public void setMessage(String message) { this.message = message; } } 3.自定义异常处理器public class CustomExceptionResolver implements HandlerExceptionResolver { @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { ex.printStackTrace(); CustomException customException = null; //如果抛出的是系统自定义异常则直接转换 if(ex instanceof CustomException){ customException = (CustomException)ex; }else{ //如果抛出的不是系统自定义异常则重新构造一个系统错误异常。 customException = new CustomException(&quot;系统错误，请与系统管理 员联系！&quot;); } ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(&quot;message&quot;, customException.getMessage()); modelAndView.setViewName(&quot;error&quot;); return modelAndView; } } 取异常堆栈： try { } catch (Exception e) { StringWriter s = new StringWriter(); PrintWriter printWriter = new PrintWriter(s); e.printStackTrace(printWriter); s.toString(); } 4.错误页面&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt; &lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; prefix=&quot;fmt&quot;%&gt; &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;错误页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 您的操作出现错误如下：&lt;br/&gt; ${message } &lt;/body&gt; &lt;/html&gt; 5.异常处理器配置在springmvc.xml中添加： &lt;!-- 异常处理器 --&gt; &lt;bean id=&quot;handlerExceptionResolver&quot; class=&quot;cn.itcast.ssm.controller.exceptionResolver.CustomExceptionResolver&quot;/&gt; 6.异常测试修改商品信息，id输入错误提示商品信息不存在。 修改controller方法“editItem”，调用service查询商品信息，如果商品信息为空则抛出异常： // 调用service查询商品信息 Items item = itemService.findItemById(id); if(item == null){ throw new CustomException(&quot;商品信息不存在!&quot;); } 在service中抛出异常方法同上。 五.上传图片1.配置虚拟目录在tomcat上配置图片虚拟目录，在tomcat下conf/server.xml中添加： 访问http://localhost:8080/pic即可访问F:\develop\upload\temp下的图片。 也可以通过eclipse配置： 2.jar包CommonsMultipartResolver解析器依赖commons-fileupload和commons-io，加入jar包 3.配置解析器&lt;!-- 文件上传 --&gt; &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!-- 设置上传文件的最大尺寸为5MB --&gt; &lt;property name=&quot;maxUploadSize&quot;&gt; &lt;value&gt;5242880&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; 4.图片上传controller：//商品修改提交 @RequestMapping(&quot;/editItemSubmit&quot;) public String editItemSubmit(Items items, MultipartFile pictureFile)throws Exception{ //原始文件名称 String pictureFile_name = pictureFile.getOriginalFilename(); //新文件名称 String newFileName = UUID.randomUUID().toString()+pictureFile_name.substring(pictureFile_name.lastIndexOf(&quot;.&quot;)); //上传图片 File uploadPic = new java.io.File(&quot;F:/develop/upload/temp/&quot;+newFileName); if(!uploadPic.exists()){ uploadPic.mkdirs(); } //向磁盘写文件 pictureFile.transferTo(uploadPic); ….. 页面：form添加enctype=&quot;multipart/form-data&quot;： &lt;form id=&quot;itemForm&quot; action=&quot;${pageContext.request.contextPath }/item/editItemSubmit.action&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;pic&quot; value=&quot;${item.pic }&quot; /&gt; file的name与controller形参一致： &lt;tr&gt; &lt;td&gt;商品图片&lt;/td&gt; &lt;td&gt;&lt;c:if test=&quot;${item.pic !=null}&quot;&gt; &lt;img src=&quot;/pic/${item.pic}&quot; width=100 height=100 /&gt; &lt;br /&gt; &lt;/c:if&gt; &lt;input type=&quot;file&quot; name=&quot;pictureFile&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; 六.json数据交互1.@RequestBody作用： @RequestBody注解用于读取http请求的内容(字符串)，通过springmvc提供的HttpMessageConverter接口将读到的内容转换为json、xml等格式的数据并绑定到controller方法的参数上。 List.action?id=1&amp;name=zhangsan&amp;age=12 本例子应用： @RequestBody注解实现接收http请求的json数据，将json数据转换为java对象 2.@ResponseBody作用： 该注解用于将Controller的方法返回的对象，通过HttpMessageConverter接口转换为指定格式的数据 如：json,xml等，通过Response响应给客户端 本例子应用： @ResponseBody注解实现将controller方法返回对象转换为json响应给客户端 3.请求json，响应json实现：1)环境准备Springmvc默认用MappingJacksonHttpMessageConverter对json数据进行转换，需要加入jackson的包， 2)配置json转换器在注解适配器中加入messageConverters &lt;!--注解适配器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt; &lt;property name=&quot;messageConverters&quot;&gt; &lt;list&gt; &lt;bean class=&quot;org.springframework.http.converter.json.MappingJacksonHttpMessageConverter&quot;&gt;&lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 注意：如果使用&lt;mvc:annotation-driven /&gt; 则不用定义上边的内容。 3)controller编写// 商品修改提交json信息，响应json信息 @RequestMapping(&quot;/editItemSubmit_RequestJson&quot;) public @ResponseBody Items editItemSubmit_RequestJson(@RequestBody Items items) throws Exception { System.out.println(items); //itemService.saveItem(items); return items; } 4)页面js方法编写：引入 js： &lt;script type=&quot;text/javascript&quot; src=&quot;${pageContext.request.contextPath }/js/jquery-1.4.4.min.js&quot;&gt;&lt;/script&gt; //请求json响应json function request_json(){ $.ajax({ type:&quot;post&quot;, url:&quot;${pageContext.request.contextPath }/item/editItemSubmit_RequestJson.action&quot;, contentType:&quot;application/json;charset=utf-8&quot;, data:&apos;{&quot;name&quot;:&quot;测试商品&quot;,&quot;price&quot;:99.9}&apos;, success:function(data){ alert(data); } }); } 5)测试结果： 从上图可以看出请求的数据是json格式 七.RESTful支持1.什么是restful？Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格，是对http协议的诠释。 资源定位：互联网所有的事物都是资源，要求url中没有动词，只有名词。没有参数 Url格式：http://blog.csdn.net/beat_the_world/article/details/45621673 资源操作：使用put、delete、post、get，使用不同方法对资源进行操作。分别对应添加、删除、修改、查询。一般使用时还是post和get。Put和Delete几乎不使用。 2.需求RESTful方式实现商品信息查询，返回json数据 3.添加DispatcherServlet的rest配置&lt;servlet&gt; &lt;servlet-name&gt;springmvc-servlet-rest&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc-servlet-rest&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 4.URL 模板模式映射@RequestMapping(value=”/ viewItems/{id}”)：{×××}占位符，请求的URL可以是“/viewItems/1”或“/viewItems/2”，通过在方法中使用@PathVariable获取{×××}中的×××变量。 @PathVariable用于将请求URL中的模板变量映射到功能处理方法的参数上。 @RequestMapping(&quot;/viewItems/{id}&quot;) public @ResponseBody viewItems(@PathVariable(&quot;id&quot;) String id,Model model) throws Exception{ //方法中使用@PathVariable获取useried的值，使用model传回页面 //调用 service查询商品信息 ItemsCustom itemsCustom = itemsService.findItemsById(id); return itemsCustom; } 如果RequestMapping中表示为”/viewItems/{id}”，id和形参名称一致，@PathVariable不用指定名称。 商品查询的controller方法也改为rest实现： // 查询商品列表 @RequestMapping(&quot;/queryItem&quot;) public ModelAndView queryItem() throws Exception { // 商品列表 List&lt;Items&gt; itemsList = itemService.findItemsList(null); // 创建modelAndView准备填充数据、设置视图 ModelAndView modelAndView = new ModelAndView(); // 填充数据 modelAndView.addObject(&quot;itemsList&quot;, itemsList); // 视图 modelAndView.setViewName(&quot;item/itemsList&quot;); return modelAndView; } 5.静态资源访问mvc:resources如果在DispatcherServlet中设置url-pattern为 /则必须对静态资源进行访问处理。 spring mvc 的&lt;mvc:resources mapping=”” location=””&gt;实现对静态资源进行映射访问。 如下是对js文件访问配置： &lt;mvc:resources location=&quot;/js/&quot; mapping=&quot;/js/**&quot;/&gt; 八.拦截器1.定义Spring Web MVC 的处理器拦截器类似于Servlet 开发中的过滤器Filter，用于对处理器进行预处理和后处理。 2.拦截器定义实现HandlerInterceptor接口，如下： Public class HandlerInterceptor1 implements HandlerInterceptor{ /** * controller执行前调用此方法 * 返回true表示继续执行，返回false中止执行 * 这里可以加入登录校验、权限拦截等 */ @Override Public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // TODO Auto-generated method stub Return false; } /** * controller执行后但未返回视图前调用此方法 * 这里可在返回用户前对模型数据进行加工处理，比如这里加入公用信息以便页面显示 */ @Override Public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { // TODO Auto-generated method stub } /** * controller执行后且视图返回后调用此方法 * 这里可得到执行controller时的异常信息 * 这里可记录操作日志，资源清理等 */ @Override Public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { // TODO Auto-generated method stub } } 3.拦截器配置1)针对某种mapping配置拦截器&lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;&gt; &lt;property name=&quot;interceptors&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;handlerInterceptor1&quot;/&gt; &lt;ref bean=&quot;handlerInterceptor2&quot;/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;handlerInterceptor1&quot; class=&quot;springmvc.intercapter.HandlerInterceptor1&quot;/&gt; &lt;bean id=&quot;handlerInterceptor2&quot; class=&quot;springmvc.intercapter.HandlerInterceptor2&quot;/&gt; 2)针对所有mapping配置全局拦截器&lt;!--拦截器 --&gt; &lt;mvc:interceptors&gt; &lt;!--多个拦截器,顺序执行 --&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean class=&quot;cn.itcast.springmvc.filter.HandlerInterceptor1&quot;&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean class=&quot;cn.itcast.springmvc.filter.HandlerInterceptor2&quot;&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 4.正常流程测试1)代码：定义两个拦截器分别为：HandlerInterceptor1和HandlerInteptor2，每个拦截器的preHandler方法都返回true。 2)运行流程HandlerInterceptor1..preHandle.. HandlerInterceptor2..preHandle.. HandlerInterceptor2..postHandle.. HandlerInterceptor1..postHandle.. HandlerInterceptor2..afterCompletion.. HandlerInterceptor1..afterCompletion.. 5.中断流程测试1)代码：定义两个拦截器分别为：HandlerInterceptor1和HandlerInteptor2。 2)运行流程HandlerInterceptor1的preHandler方法返回false，HandlerInterceptor2返回true，运行流程如下： HandlerInterceptor1..preHandle.. 从日志看出第一个拦截器的preHandler方法返回false后第一个拦截器只执行了preHandler方法，其它两个方法没有执行，第二个拦截器的所有方法不执行，且controller也不执行了。 HandlerInterceptor1的preHandler方法返回true，HandlerInterceptor2返回false，运行流程如下： HandlerInterceptor1..preHandle.. HandlerInterceptor2..preHandle.. HandlerInterceptor1..afterCompletion.. 从日志看出第二个拦截器的preHandler方法返回false后第一个拦截器的postHandler没有执行，第二个拦截器的postHandler和afterCompletion没有执行，且controller也不执行了。 总结： preHandle按拦截器定义顺序调用 postHandler按拦截器定义逆序调用 afterCompletion按拦截器定义逆序调用 postHandler在拦截器链内所有拦截器返成功调用 afterCompletion只有preHandle返回true才调用 6.拦截器应用1)处理流程1、有一个登录页面，需要写一个controller访问页面 2、登录页面有一提交表单的动作。需要在controller中处理。 a)判断用户名密码是否正确 b)如果正确 想session中写入用户信息 c)返回登录成功，或者跳转到商品列表 3、拦截器。 a)拦截用户请求，判断用户是否登录 b)如果用户已经登录。放行 c)如果用户未登录，跳转到登录页面。 2)用户身份认证Public class LoginInterceptor implements HandlerInterceptor{ @Override Public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //如果是登录页面则放行 if(request.getRequestURI().indexOf(&quot;login.action&quot;)&gt;=0){ return true; } HttpSession session = request.getSession(); //如果用户已登录也放行 if(session.getAttribute(&quot;user&quot;)!=null){ return true; } //用户没有登录挑战到登录页面 request.getRequestDispatcher(&quot;/WEB-INF/jsp/login.jsp&quot;).forward(request, response); return false; } } 3)用户登陆controller//登陆页面 @RequestMapping(&quot;/login&quot;) public String login(Model model)throws Exception{ return &quot;login&quot;; } //登陆提交 //userid：用户账号，pwd：密码 @RequestMapping(&quot;/loginsubmit&quot;) public String loginsubmit(HttpSession session,String userid,String pwd)throws Exception{ //向session记录用户身份信息 session.setAttribute(&quot;activeUser&quot;, userid); return &quot;redirect:item/queryItem.action&quot;; } //退出 @RequestMapping(&quot;/logout&quot;) public String logout(HttpSession session)throws Exception{ //session过期 session.invalidate(); return &quot;redirect:item/queryItem.action&quot;; }]]></content>
      <categories>
        <category>springmvc</category>
      </categories>
      <tags>
        <tag>springmvc</tag>
        <tag>springmvc高级篇</tag>
      </tags>
  </entry>
</search>
