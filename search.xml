<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hibernate入门(框架搭建)]]></title>
    <url>%2F2018%2F12%2F16%2Fhibernate-1%2F</url>
    <content type="text"><![CDATA[Hibernate框架的学习路线学习的路线 * 入门篇：主要是学习框架的入门，自己搭建框架，完成增删改查的操作 * 进阶篇：主要学习一级缓存、事务管理和基本的查询 * 高级篇：主要学习一对多和多对多的操作等 * 完善篇：基本查询和查询的优化 一.Hibernate框架的概述1. Hibernate框架的概述 * Hibernate称为 * Hibernate是一个开放源代码的对象关系映射（ORM）框架，它对JDBC进行了非常轻量级的对象封装，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 * Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用。 * Hibernate是轻量级JavaEE应用的持久层解决方案，是一个关系数据库ORM框架 2. 记住：Hibernate是一个持久层的ORM框架！！！ 二.什么是ORM（对象关系映射） 1. ORM映射：Object Relational Mapping * O：面向对象领域的Object（JavaBean对象） * R：关系数据库领域的Relational（表的结构） * M：映射Mapping（XML的配置文件） 2. 简单一句话：Hibernate使程序员通过操作对象的方式来操作数据库表记录 三.Hibernate优点1. 优点 * Hibernate对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码 * Hibernate是一个基于jdbc的主流持久化框架，是一个优秀的orm实现，它很大程度的简化了dao层编码工作 * Hibernate的性能非常好，因为它是一个轻量级框架。映射的灵活性很出色。它支持很多关系型数据库，从一对一到多对多的各种复杂关系 四.技术分析之Hibernate框架的快速入门1.第一步：下载Hibernate5的运行环境1. 下载相应的jar包等 * http://sourceforge.net/projects/hibernate/files/hibernate-orm/5.0.7.Final/hibernate-release-5.0.7.Final.zip/download 2. 解压后对目录结构有一定的了解 2.第二步：创建表结构**1. 建表语句如下 Create database hibernate_day01; Use hibernate_day01; CREATE TABLE `cst_customer` ( `cust_id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT &apos;客户编号(主键)&apos;, `cust_name` varchar(32) NOT NULL COMMENT &apos;客户名称(公司名称)&apos;, `cust_user_id` bigint(32) DEFAULT NULL COMMENT &apos;负责人id&apos;, `cust_create_id` bigint(32) DEFAULT NULL COMMENT &apos;创建人id&apos;, `cust_source` varchar(32) DEFAULT NULL COMMENT &apos;客户信息来源&apos;, `cust_industry` varchar(32) DEFAULT NULL COMMENT &apos;客户所属行业&apos;, `cust_level` varchar(32) DEFAULT NULL COMMENT &apos;客户级别&apos;, `cust_linkman` varchar(64) DEFAULT NULL COMMENT &apos;联系人&apos;, `cust_phone` varchar(64) DEFAULT NULL COMMENT &apos;固定电话&apos;, `cust_mobile` varchar(16) DEFAULT NULL COMMENT &apos;移动电话&apos;, PRIMARY KEY (`cust_id`) ) ENGINE=InnoDB AUTO_INCREMENT=94 DEFAULT CHARSET=utf8; 3.第三步：搭建Hibernate的开发环境1. 创建WEB工程，引入Hibernate开发所需要的jar包 * MySQL的驱动jar包 * Hibernate开发需要的jar包（资料/hibernate-release-5.0.7.Final/lib/required/所有jar包） * 日志jar包（资料/jar包/log4j/所有jar包） 4.第四步：编写JavaBean实体类1. Customer类的代码如下： public class Customer { private Long cust_id; private String cust_name; private Long cust_user_id; private Long cust_create_id; private String cust_source; private String cust_industry; private String cust_level; private String cust_linkman; private String cust_phone; private String cust_mobile; // 省略get和set方法 } 5.第五步：创建类与表结构的映射1. 在JavaBean所在的包下创建映射的配置文件 * 默认的命名规则为：实体类名.hbm.xml * 在xml配置文件中引入约束（引入的是hibernate3.0的dtd约束，不要引入4的约束） &lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt; 2. 如果不能上网，编写配置文件是没有提示的，需要自己来配置 * 先复制http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd --&gt; window --&gt; preferences --&gt; 搜索xml --&gt; 选择xml catalog --&gt; 点击add --&gt; 现在URI --&gt; 粘贴复制的地址 --&gt; 选择location，选择本地的DTD的路径 3. 编写映射的配置文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt; &lt;hibernate-mapping&gt; &lt;class name=&quot;com.itheima.domain.Customer&quot; table=&quot;cst_customer&quot;&gt; &lt;id name=&quot;cust_id&quot; column=&quot;cust_id&quot;&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;property name=&quot;cust_name&quot; column=&quot;cust_name&quot;/&gt; &lt;property name=&quot;cust_user_id&quot; column=&quot;cust_user_id&quot;/&gt; &lt;property name=&quot;cust_create_id&quot; column=&quot;cust_create_id&quot;/&gt; &lt;property name=&quot;cust_source&quot; column=&quot;cust_source&quot;/&gt; &lt;property name=&quot;cust_industry&quot; column=&quot;cust_industry&quot;/&gt; &lt;property name=&quot;cust_level&quot; column=&quot;cust_level&quot;/&gt; &lt;property name=&quot;cust_linkman&quot; column=&quot;cust_linkman&quot;/&gt; &lt;property name=&quot;cust_phone&quot; column=&quot;cust_phone&quot;/&gt; &lt;property name=&quot;cust_mobile&quot; column=&quot;cust_mobile&quot;/&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; 6.第六步：编写Hibernate核心的配置文件1. 在src目录下，创建名称为hibernate.cfg.xml的配置文件 2. 在XML中引入DTD约束 &lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt; 3. 打开：资料/hibernate-release-5.0.7.Final/project/etc/hibernate.properties，可以查看具体的配置信息 * 必须配置的4大参数 #hibernate.connection.driver_class com.mysql.jdbc.Driver #hibernate.connection.url jdbc:mysql:///test #hibernate.connection.username gavin #hibernate.connection.password * 数据库的方言（必须配置的） #hibernate.dialect org.hibernate.dialect.MySQLDialect * 可选的配置 #hibernate.show_sql true #hibernate.format_sql true #hibernate.hbm2ddl.auto update * 引入映射配置文件（一定要注意，要引入映射文件，框架需要加载映射文件） * &lt;mapping resource=&quot;com/itheima/domain/Customer.hbm.xml&quot;/&gt; 4. 具体的配置如下 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt; &lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;hibernate.connection.url&quot;&gt;jdbc:mysql:///hibernate_day01&lt;/property&gt; &lt;property name=&quot;hibernate.connection.username&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;hibernate.connection.password&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;mapping resource=&quot;com/itheima/domain/Customer.hbm.xml&quot;/&gt; &lt;/session-factory&gt; &lt;/hibernate-configuration&gt; 7.第七步：编写Hibernate入门代码1. 具体的代码如下 /** * 测试保存客户 */ @Test public void testSave(){ // 先加载配置文件 Configuration config = new Configuration(); // 默认加载src目录下的配置文件 config.configure(); // 创建SessionFactory对象 SessionFactory factory = config.buildSessionFactory(); // 创建session对象 Session session = factory.openSession(); // 开启事务 Transaction tr = session.beginTransaction(); // 编写保存代码 Customer c = new Customer(); // c.setCust_id(cust_id); 已经自动递增 c.setCust_name(&quot;测试名称&quot;); c.setCust_mobile(&quot;110&quot;); // 保存客户 session.save(c); // 提交事务 tr.commit(); // 释放资源 session.close(); factory.close(); } 五.Hibernate具体配置文件(初阶段)1.ibernate配置文件之映射配置文件1. 映射文件，即Stu.hbm.xml的配置文件 * &lt;class&gt;标签 -- 用来将类与数据库表建立映射关系 * name -- 类的全路径 * table -- 表名.(类名与表名一致,那么table属性也可以省略) * catalog -- 数据库的名称，基本上都会省略不写 * &lt;id&gt;标签 -- 用来将类中的属性与表中的主键建立映射，id标签就是用来配置主键的。 * name -- 类中属性名 * column -- 表中的字段名.(如果类中的属性名与表中的字段名一致,那么column可以省略.) * length -- 字段的程度，如果数据库已经创建好了，那么length可以不写。如果没有创建好，生成表结构时，length最好指定。 * &lt;property&gt; -- 用来将类中的普通属性与表中的字段建立映射. * name -- 类中属性名 * column -- 表中的字段名.(如果类中的属性名与表中的字段名一致,那么column可以省略.) * length -- 数据长度 * type -- 数据类型（一般都不需要编写，如果写需要按着规则来编写） * Hibernate的数据类型 type=&quot;string&quot; * Java的数据类型 type=&quot;java.lang.String&quot; * 数据库字段的数据类型 &lt;column name=&quot;name&quot; sql-type=&quot;varchar&quot;/&gt; 2.Hibernate配置文件之核心配置文件1. 核心配置文件的两种方式 * 第一种方式是属性文件的形式，即properties的配置文件 * hibernate.properties * hibernate.connection.driver_class=com.mysql.jdbc.Driver * 缺点 * 不能加载映射的配置文件，需要手动编写代码去加载 * 第二种方式是XML文件的形式，开发基本都会选择这种方式 * hibernate.cfg.xml * &lt;property name=&quot;hibernate.connection.driver_class&quot; &gt;com.mysql.jdbc.Driver&lt;/property&gt; * 优点 * 格式比较清晰 * 编写有提示 * 可以在该配置文件中加载映射的配置文件（最主要的） 2. 关于hibernate.cfg.xml的配置文件方式 * 必须有的配置 * 数据库连接信息: hibernate.connection.driver_class -- 连接数据库驱动程序 hibernate.connection.url -- 连接数据库URL hibernate.connection.username -- 数据库用户名 hibernate.connection.password -- 数据库密码 * 方言: hibernate.dialect -- 操作数据库方言 * 可选的配置 * hibernate.show_sql -- 显示SQL * hibernate.format_sql -- 格式化SQL * hibernate.hbm2ddl.auto -- 通过映射转成DDL语句 * create -- 每次都会创建一个新的表.---测试的时候 * create-drop -- 每次都会创建一个新的表,当执行结束之后,将创建的这个表删除.---测试的时候 * update -- 如果有表,使用原来的表.没有表,创建一个新的表.同时更新表结构. * validate -- 如果有表,使用原来的表.同时校验映射文件与表中字段是否一致如果不一致就会报错. * 加载映射 * 如果XML方式：&lt;mapping resource=&quot;cn/itcast/hibernate/domain/User.hbm.xml&quot; /&gt; 六.技术分析之Hibernate常用的接口和类1.Configuration类和作用1. Configuration类 * Configuration对象用于配置并且启动Hibernate。 * Hibernate应用通过该对象来获得对象-关系映射文件中的元数据，以及动态配置Hibernate的属性，然后创建SessionFactory对象。 * 简单一句话：加载Hibernate的配置文件，可以获取SessionFactory对象。 2. Configuration类的其他应用（了解） * 加载配置文件的种类，Hibernate支持xml和properties类型的配置文件，在开发中基本都使用XML配置文件的方式。 * 如果采用的是properties的配置文件，那么通过Configuration configuration = new Configuration();就可以假装配置文件 * 但是需要自己手动加载映射文件 * 例如：config.addResource(&quot;cn/itcast/domain/Student.hbm.xml&quot;); * 如果采用的XML的配置文件，通过Configuration configuration = new Configuration().configure();加载配置文件 2.SessionFactory(重要)1. 是工厂类，是生成Session对象的工厂类 2. SessionFactory类的特点 * 由Configuration通过加载配置文件创建该对象。 * SessionFactory对象中保存了当前的数据库配置信息和所有映射关系以及预定义的SQL语句。同时，SessionFactory还负责维护Hibernate的二级缓存。 * 预定义SQL语句 * 使用Configuration类创建了SessionFactory对象是，已经在SessionFacotry对象中缓存了一些SQL语句 * 常见的SQL语句是增删改查（通过主键来查询） * 这样做的目的是效率更高 * 一个SessionFactory实例对应一个数据库，应用从该对象中获得Session实例。 * SessionFactory是线程安全的，意味着它的一个实例可以被应用的多个线程共享。 * SessionFactory是重量级的，意味着不能随意创建或销毁它的实例。如果只访问一个数据库，只需要创建一个SessionFactory实例，且在应用初始化的时候完成。 * SessionFactory需要一个较大的缓存，用来存放预定义的SQL语句及实体的映射信息。另外可以配置一个缓存插件，这个插件被称之为Hibernate的二级缓存，被多线程所共享 3. 总结 * 一般应用使用一个SessionFactory,最好是应用启动时就完成初始化。 3.编写HibernateUtil的工具类1. 具体代码如下 public class HibernateUtil { private static final Configuration cfg; private static final SessionFactory factory; static{ // 给常量赋值 // 加载配置文件 cfg = new Configuration().configure(); // 生成factory对象 factory = cfg.buildSessionFactory(); } // 获取Session对象 public static Session openSession(){ return factory.openSession(); } } 4.Session接口1. 概述 * Session是在Hibernate中使用最频繁的接口。也被称之为持久化管理器。它提供了和持久化有关的操作，比如添加、修改、删除、加载和查询实体对象 * Session 是应用程序与数据库之间交互操作的一个单线程对象，是 Hibernate 运作的中心 * Session是线程不安全的 * 所有持久化对象必须在 session 的管理下才可以进行持久化操作 * Session 对象有一个一级缓存，显式执行 flush 之前，所有的持久化操作的数据都缓存在 session 对象处 * 持久化类与 Session 关联起来后就具有了持久化的能力 2. 特点 * 不是线程安全的。应避免多个线程使用同一个Session实例 * Session是轻量级的，它的创建和销毁不会消耗太多的资源。应为每次客户请求分配独立的Session实例 * Session有一个缓存，被称之为Hibernate的一级缓存。每个Session实例都有自己的缓存 3. 常用的方法 * save(obj) * delete(obj) * get(Class,id) * update(obj) * saveOrUpdate(obj) -- 保存或者修改（如果没有数据，保存数据。如果有，修改数据） * createQuery() -- HQL语句的查询的方式 5.Transaction接口1. Transaction是事务的接口 2. 常用的方法 * commit() -- 提交事务 * rollback() -- 回滚事务 3. 特点 * Hibernate框架默认情况下事务不自动提交.需要手动提交事务 * 如果没有开启事务，那么每个Session的操作，都相当于一个独立的事务 七.本阶段总结回忆：快速入门hibernate1. 下载Hibernate框架的开发包 2. 编写数据库和表结构 3. 创建WEB的项目，导入了开发的jar包 * MySQL驱动包、Hibernate开发的必须要有的jar包、日志的jar包 4. 编写JavaBean，以后不使用基本数据类型，使用包装类 5. 编写映射的配置文件（核心），先导入开发的约束，里面正常配置标签 6. 编写hibernate的核心的配置文件，里面的内容是固定的 7. 编写代码，使用的类和方法]]></content>
      <categories>
        <category>hibernate</category>
      </categories>
      <tags>
        <tag>hibernate</tag>
        <tag>hibernate入门篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle索引]]></title>
    <url>%2F2018%2F12%2F16%2Foracle-index%2F</url>
    <content type="text"><![CDATA[一.说明1）索引是数据库对象之一，用于加快数据的检索，类似于书籍的索引。在数据库中索引可以减少数据库程序查询结果时需要读取的数据量，类似于在书籍中我们利用索引可以不用翻阅整本书即可找到想要的信息。2）索引是建立在表上的可选对象；索引的关键在于通过一组排序后的索引键来取代默认的全表扫描检索方式，从而提高检索效率3）索引在逻辑上和物理上都与相关的表和数据无关，当创建或者删除一个索引时，不会影响基本的表；4）索引一旦建立，在表上进行DML操作时（例如在执行插入、修改或者删除相关操作时），oracle会自动管理索引，索引删除，不会对表产生影响5）索引对用户是透明的，无论表上是否有索引，sql语句的用法不变6）oracle创建主键时会自动在该列上创建索引二.索引原理1. 若没有索引，搜索某个记录时（例如查找name=’wish’）需要搜索所有的记录，因为不能保证只有一个wish，必须全部搜索一遍2. 若在name上建立索引，oracle会对全表进行一次搜索，将每条记录的name值哪找升序排列，然后构建索引条目（name和rowid），存储到索引段中，查询name为wish时即可直接查找对应地方3.创建了索引并不一定就会使用，oracle自动统计表的信息后，决定是否使用索引，表中数据很少时使用全表扫描速度已经很快，没有必要使用索引三.索引使用（创建、修改、删除、查看）1.创建索引语法CREATE [UNIQUE] | [BITMAP] INDEX index_name –unique表示唯一索引 ON table_name([column1 [ASC|DESC],column2 –bitmap，创建位图索引 [ASC|DESC],…] | [express]) [TABLESPACE tablespace_name] [PCTFREE n1] –指定索引在数据块中空闲空间 [STORAGE (INITIAL n2)] [NOLOGGING] –表示创建和重建索引时允许对表做DML操作，默认情况下不应该使用 [NOLINE] [NOSORT]; –表示创建索引时不进行排序，默认不适用，如果数据已经是按照该索引顺序排列的可以使用 2.修改索引1）重命名索引alter index index_sno rename to bitmap_index; 2) 合并索引（表使用一段时间后在索引中会产生碎片，此时索引效率会降低，可以选择重建索引或者合并索引,合并索引方式更好些，无需额外存储空间，代价较低）alter index index_sno coalesce; 3)重建索引方式一：删除原来的索引，重新建立索引 方式二： alter index index_sno rebuild; 3.删除索引drop index index_sno; 4.查看索引复制代码复制代码 select index_name,index-type, tablespace_name, uniqueness from all_indexes where table_name =’tablename’; – eg:create index index_sno on student(‘name’);select * from all_indexes where table_name=’student’; 四.索引分类1. B树索引（默认索引，保存讲过排序过的索引列和对应的rowid值）1）说明： 1.oracle中最常用的索引；B树索引就是一颗二叉树；叶子节点（双向链表）包含索引列和指向表中每个匹配行的ROWID值 2.所有叶子节点具有相同的深度，因而不管查询条件怎样，查询速度基本相同 3.能够适应精确查询、模糊查询和比较查询 2）分类： UNIQUE,NON-UNIQUE(默认),REVERSE KEY（数据列中的数据是反向存储的） 3）创建例子craete index index_sno on student(‘sno’); 4）适合使用场景： 列基数（列不重复值的个数）大时适合使用B数索引 2. 位图索引1）说明： 创建位图索引时，oracle会扫描整张表，并为索引列的每个取值建立一个位图（位图中，对表中每一行 使用一位（bit，0或者1）来标识该行是否包含该位图的索引列的取值，如果为1，表示对应的rowid所在的记录包含该位图索引列值），最后通过位图索 引中的映射函数完成位到行的ROWID的转换 2)创建例子create bitmap index index_sno on student(sno); 3) 适合场景：对于基数小的列适合简历位图索引（例如性别等） 3.单列索引和复合索引（基于多个列创建）注意： 即如果索引建立在多个列上，只有它的第一个列被where子句引用时，优化器才会使用该索引，即至少要包含组合索引的第一列 4. 函数索引1)说明： 1. 当经常要访问一些函数或者表达式时，可以将其存储在索引中，这样下次访问时，该值已经计算出来了，可以加快查询速度 2. 函数索引既可以使用B数索引，也可以使用位图索引；当函数结果不确定时采用B树索引，结果是固定的某几个值时使用位图索引 3. 函数索引中可以水泥用len、trim、substr、upper（每行返回独立结果），不能使用如sum、max、min、avg等 2）例子：create index fbi on student (upper(name)); select * from student where upper(name) =’WISH’; 五.索引建立原则总结1. 如果有两个或者以上的索引，其中有一个唯一性索引，而其他是非唯一，这种情况下oracle将使用唯一性索引而完全忽略非唯一性索引2. 至少要包含组合索引的第一列（即如果索引建立在多个列上，只有它的第一个列被where子句引用时，优化器才会使用该索引）3. 小表不要简历索引4. 对于基数大的列适合建立B树索引，对于基数小的列适合简历位图索引5. 列中有很多空值，但经常查询该列上非空记录时应该建立索引6. 经常进行连接查询的列应该创建索引7. 使用create index时要将最常查询的列放在最前面8. LONG（可变长字符串数据，最长2G）和LONG RAW（可变长二进制数据，最长2G）列不能创建索引9.限制表中索引的数量（创建索引耗费时间，并且随数据量的增大而增大；索引会占用物理空间；当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度）六.注意事项1. 通配符在搜索词首出现时，oracle不能使用索引，eg：复制代码复制代码 –我们在name上创建索引； create index index_name on student(‘name’); –下面的方式oracle不适用name索引 select * from student where name like ‘%wish%’; –如果通配符出现在字符串的其他位置时，优化器能够利用索引；如下： select * from student where name like ‘wish%’; 复制代码复制代码 2. 不要在索引列上使用not，可以采用其他方式代替如下：（oracle碰到not会停止使用索引，而采用全表扫描）复制代码复制代码 select * from student where not (score=100); select * from student where score &lt;&gt; 100; –替换为 select * from student where score&gt;100 or score &lt;100 复制代码复制代码 3. 索引上使用空值比较将停止使用索引， eg：select * from student where score is not null;]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
        <tag>oracle索引</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle 数据库 实例 用户 表空间 之间的关系（转）]]></title>
    <url>%2F2018%2F12%2F13%2Foracle-framework%2F</url>
    <content type="text"><![CDATA[数据库：Oracle数据库是数据的物理存储。这就包括（数据文件ORA或者DBF、控制文件、联机日志、参数文件）。其实Oracle数据库的概念和其它数据库不一样，这里的数据库是一个操作系统只有一个库。可以看作是Oracle就只有一个大数据库。 实例：一个Oracle实例（Oracle Instance）有一系列的后台进程（Backguound Processes)和内存结构（Memory Structures)组成。一个数据库可以有n个实例。 用户：用户是在实例下建立的。不同实例可以建相同名字的用户。 表空间：表空间是一个用来管理数据存储逻辑概念，表空间只是和数据文件（ORA或者DBF文件）发生关系，数据文件是物理的，一个表空间可以包含多个数据文件，而一个数据文件只能隶属一个表空间。 数据文件（dbf、ora）： 数据文件是数据库的物理存储单位。数据库的数据是存储在表空间中的，真 正是在某一个或者多个数据文件中。而一个表空间可以由一个或多个数据文件组成，一个数据文件只能属于一个表空间。一旦数据文件被加入到某个表空间后，就不能删除这个文件，如果要删除某个数据文件，只能删除其所属于的表空间才行。 注：表的数据，是有用户放入某一个表空间的，而这个表空间会随机把这些表数据放到一个或者多个数据文件中。由于oracle的数据库不是普通的概念，oracle是有用户和表空间对数据进行管理和存放的。但是表不是有表空间去查询的，而是由用户去查的。因为不同用户可以在同一个表空间建立同一个名字的表！这里区分就是用户了！ 关系示意图： 理解1：Oracle数据库可以创建多个实例，每个实例可以创建多个表空间，每个表空间下可以创建多个用户（同时用户也属于表空间对应的实例）和数据库文件，用户可以创建多个表（每个表随机存储在一个或多个数据库文件中），如下图：理解2：理解1MS有误。实例下有和，授权访问，是管理的，经授权在中创建，随机存储到不同的中。如下图所示：操作1：安装Oracle后会有默认的实例，即ORCL。一般不创建多个实例，在默认实例下创建表空间和用户等。 1，运行CMD进入DOS界面，首先输入：sqlplus，回车；再输入：sys/sys as sysdba，回车，即进入“SQL〉”操作状态。 2，输入：CREATE TABLESPACE 表空间名称 LOGGING DATAFILE ‘c:\表空间数据文件.ora’ SIZE 500M autoextend on next 200m maxsize 2048m;，表空间创建完成。 3，输入：CREATE USER 用户名称 PROFILE default IDENTIFIED BY 用户密码 DEFAULT TABLESPACE 授权访问的表空间名称 TEMPORARY TABLESPACE temp ACCOUNT UNLOCK;，用户创建完成，并授权用户访问某表空间。 具体操作如下图所示： 操作2： 创建表和插入数据，并查询浏览插入的数据。 1，创建表，输入： create table 表名( 字段名称1 字段类型, 字段名称2 字段类型, 字段名称3 字段类型 );，回车。 2，插入数据，输入：insert into 表名(字段1,字段2,字段3) VALUES (值1,值2,值3);，回车。 3，查询数据，输入：select * from 表名;，回车。 具体操作如下图所示： 基本操作流程1.创建数据表空间 create tablespace CICI logging datafile ‘D:\oraclexe\app\oracle\oradata\CICI\CICI.DBF’ size 32m autoextend on next 32m maxsize 2048m extent management local; 2.创建用户并指定表空间 CREATE USER cici IDENTIFIED BY cici PROFILE DEFAULT DEFAULT TABLESPACE CICI ACCOUNT UNLOCK; – 为用户赋予权限 GRANT connect, resource TO cici; grant create session to cici; 3.登录用户 sql&gt;conn 请输入用户名 cici 请输入密码 XXXXXX 4.建立表 create table aa(name varchar2(100),age number(4)); insert into aa values(‘wo’,29); 5.查询表 select * from cici.A;]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
        <tag>oracle结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle基本命令]]></title>
    <url>%2F2018%2F12%2F13%2Foracle-sql%2F</url>
    <content type="text"><![CDATA[一.ORACLE支持五种类型的完整性约束1.NOT NULL (非空)防止NULL值进入指定的列,在单列基础上定义,默认情况下,ORACLE允许在任何列中有NULL值. 2.CHECK (检查)检查在约束中指定的条件是否得到了满足. 3.UNIQUE (唯一)保证在指定的列中没有重复值.在该表中每一个值或者每一组值都将是唯一的. 4.PRIMARY KEY (主键)用来唯一的标识出表的每一行,并且防止出现NULL值,一个表只能有一个主键约束. 5.POREIGN KEY (外部键)通过使用公共列在表之间建立一种父子(parent-child)关系,在表上定义的外部键可以指向主键或者其他表的唯一键.ORACLE支持五种类型的完整性约束 二.基本命令创建表空间create tablespace schooltbs datafile ‘D:\oracle\datasource\schooltbs.dbf’ size 10M autoextend on; 删除表空间drop tablespace schooltbs[including contents and datafiles]; 查询表空间基本信息select *||tablespace_name from DBA_TABLESPACES; 创建用户create user lihua identified by lihua default tablespace schooltbs temporary tablespace temp; 更改用户alter user lihua identified by 123 default tablespace users; 锁定用户alter user lihua account lock|unlock; 删除用户drop user lihua cascade;–删除用户模式 oracle数据库中的角色connect,dba,select_catalog_role,delete_catalog_role,execute_catalog_role,exp_full_database,imp_full_database,resource 授予连接服务器的角色grant connect to lihua; 授予使用表空间的角色 grant resource to lihua with grant option;–该用户也有授权的权限 授予操作表的权限grant select,insert on user_tbl to scott;–当前用户 grant delete,update on lihua.user_tbl to scott;–系统管理员 修改表的结构(alter)Alter table 表名 add(列的名称,列的类型); 三.基本查询设置每行显示多少字符set linesize 300; 设置每页显示多少条记录set pagesize 30; 用户名的切换conn system/tiger Conn sys/change_on_install as sysdba(注意超级用户 在后面加as sysdba)在超级用户下查找普通用户的表是查不到的必须这样查找 如 select * from scott.emp(普通用户下的emp表) 查看当前是那个用户身份登录:show user; 查看有多少张表:select * from tab;(注意不同用户下的表是不同的) 查看表的结构:desc emp(emp为表名) 取出重复的列(DISTINCT):如 SELECT DISTINCT JOB EMP(去掉job的重复的值) 字符串的链接操作用:|| 查询有奖金的员工:select* from emp where comm is not null; 查询没有奖金的员工信息:select * from emp where comm is null; 两个条件以上就得用and 如查询工资大雨1500和有奖金的员 select * from emp where sal&gt;1500 and comm is not null; 表示两个条件有一个满足就可就用:or 如查询工资大于1500或者没有奖金的员工信息Select * from emp where sal&gt;1500 or comm is not null; 取反可以用not 如 查询员工工资不大于1500和有奖金的员工信息 如: Select * from emp where not (sal&gt;1500 or comm is not null); 在什么什么之间用between—-and—-如查询工资在1500和3000之间的员工信息:Select * from emp where sal between 1500 and 3000; 查询员工编号是2323, 4555, 2222的员工具体信息: 如Select * from emp where empno in(2323,4555,2222); 模糊查询 like 一般结合”%”和”“使用其中%:表示可以匹配任意长度的内容,”“表示匹配一个长度放入内容 如: 查询员工姓名中第二哥字母是M的员工信息:Select from emp where ename LIKE ‘_M%’;又如姓名中包含M的员工 Select from emp where ename LIKE ‘%M%’; oracle中不等于有两种表示方式 “&lt;&gt;”和”!=”排序用order by {asc desc}其中asc 是升序排列 如果不写就默认按升序排列desc是按降序排列 排序语句放在sal语句的最后如: 按员工工资进行排序Select from emp order by sal asc(升序)Selecct from emp order by sal desc(降序)Select * from emp where deptno=’10’ order by sal desc,hiredate asc;(查询部门10的员工工资的升序排列如果工资相等就按员工的入职时间排序) group by 用于对查询的结果进行分组统计: 显示每个部门的平均工资和最高工资 如:Select avg(sal),max(sal) from emp group by deptno; Having 子句用于限制分组显示结果: 显示平均工资大于2000的的部门号和他的平均工资?如:select avg(sal), deptno from emp group by deptno having avg(sal)&gt;2000; 四.锁和数据库对象1.锁数据库用来控制共享资源并发访问的机制。 锁的类型：行级锁，表级锁 行级锁：对正在被修改的行进行锁定。行级锁也被称之为排他锁。 在使用下列语句时，Oracle会自动应用行级锁： insert,update,delete,select…… for update select……for update允许用户一次锁定多条记录进行更新。 使用commit or rollback释放锁。 表级锁： lock table user_tbl in mode mode; 表级锁类型： 行共享 row share 行排他 row exclusive 共享 share 共享行排他 share row exclusive 排他 exclusive 死锁：两个或两个以上的事务相互等待对方释放资源，从而形成死锁 2.数据库对象 oracle数据库对象又称模式对象 数据库对象是逻辑结构的集合，最基本的数据库对象是表 数据库对象：表，序列，视图，索引 2.序列序列用于生成唯一，连续序号的对象。 创建语法： create sequence user_id_seq start with 1000 increment by 1 maxvalue 2000 minvalue 1000 nocycle cache 1000;–指定内存中预先分配的序号 访问序列： select user_id_seq.currval from dual; select user_id-seq.nextval from dual;更改删除序列： alter sequence user_id_seq maxvalue 10000;–不能修改其start with 值 drop sequence user_id_seq; 在Hibernate中访问序列： user_id_seq 3.视图视图以经过定制的方式显示来自一个或多个表的数据 创建视图： create or replace view user_tbl_view (vid,vname,vage) as select id,user_name,age from user_tbl [with check option]|[with read only]; 创建带有错误的视图： create force view user_tbl_force_view as select * from user_table;–此时user_table可以不存在 创建外联接视图： create view user_stu_view as select u.id,u.user_name,u.password,s.ddress from user_tbl u,stu_tbl s where u.s_id(+)=s.id;–哪一方带有(+)，哪一方就是次要的 删除视图： drop user_stu_view; 4.索引索引用于提高SQL语句执行的性能 索引类型： 唯一索引，位图索引，组合索引，基于函数的索引，反向键索引创建标准索引： create index user_id_index on user_tbl(id) tablespace schooltbs; 重建索引： alter index user_id_index rebuild; 删除索引： drop index user_id_index;创建唯一索引： create unique index user_id_index on user_tbl(id); 创建组合索引： create index name_pass_index on user_tbl(user_name,password); 创建反向键索引： create index user_id_index on user_tbl(id) reverse; 五.使用PL/SQL可用于创建存储过程，触发器，程序包，给SQL语句的执行添加程序逻辑。 支持SQL，在PL/SQL中可以使用：数据操纵命令 事务控制命令 游标控制 SQL函数和SQL运算符支持面向对象编程(OOP)可移植性更佳的性能，PL/SQL经过编译执行 分为三个部分：声明部分，可执行部分和异常处理部分 [declare declarations] begin executable statements [exception handlers] end;打开输出 set serverout on; 1.根据输入编号获取某学员的成绩–ifdeclarescore user_tbl.score%type;beginselect score into score from user_tbl where id=’&amp;id’;if score&gt;90 thendbms_output.put_line(‘优秀’);elsif score&gt;80 thendbms_output.put_line(‘良好’);elsif score&gt;60 thendbms_output.put_line(‘及格’);elsedbms_output.put_line(‘差’);end if;end; 2.根据学员姓名获取某学员的成绩–ifdeclarescore user_tbl.score%type;beginselect score into score from user_tbl where user_name=’&amp;name’;if score&gt;90 thendbms_output.put_line(‘优秀’);elsif score&gt;80 thendbms_output.put_line(‘良好’);elsif score&gt;60 thendbms_output.put_line(‘及格’);elsedbms_output.put_line(‘差’);end if;end; 3.case的使用declaregrade user_tbl.grade%type;beginselect grade into grade from user_tbl where id=’&amp;id’;case gradewhen ‘A’ then dbms_output.put_line(‘优异’);when ‘B’ then dbms_output.put_line(‘优秀’);when ‘C’ then dbms_output.put_line(‘良好’);else dbms_output.put_line(‘一般’);end case;end; 4.基本循环declarei number(4):=1;beginloopdbms_output.put_line(‘loop size:’||i);i:=i+1;exit when i&gt;10;end loop;end; 5.while循环declarei number(4):=1;beginwhile i&lt;=10 loopdbms_output.put_line(‘while loop size=’||i);i:=i+1;end loop;end; 6.for循环declarei number(4):=1;beginfor i in 1..10 loopdbms_output.put_line(‘for loop Size:’||i);end loop;end; declarei number(2):=1;j number(2):=1;beginfor i in reverse 1..9 loopfor j in 1..i loopdbms_output.put(j||’x’||i||’=’||j*i||’ ‘);end loop;dbms_output.put_line(‘’);end loop;end; 7.动态SQLdeclareuserId number(2);sql_str varchar2(100);userName user_tbl.user_name%type;beginexecute immediate ‘create table testExe(id number,test_name varchar2(20))’;userId:=’&amp;userId’;sql_str:=’select user_name from user_tbl where id=:id’;execute immediate sql_str into userName using userId;dbms_output.put_line(userName);end;(ordeclare id_param number:=’&amp;id_param’; sql_str varchar2(100); name_param stu_tbl.stu_name%type; begin sql_str:=’select stu_name from stu_tbl where id=:p’; execute immediate sql_str into name_param using id_param; dbms_output.put_line(name_param); end; /) 8.异常处理declaregrade number(4);begingrade:=’&amp;grade’;case gradewhen 1 then dbms_output.put_line(‘好的’);–else dbms_output.put_line(‘不好’);end case;exceptionwhen case_not_found thendbms_output.put_line(‘输入类型不匹配！’);end; 9.系统异常declarerowD user_tbl%rowtype;beginselect into rowD from user_tbl;dbms_output.put_line(rowD.id||’’||rowD.user_name||’ ‘||rowD.password);exceptionwhen too_many_rows thendbms_output.put_line(‘不能将多行赋予一个属性！’);end;ordeclarerowD user_tbl%rowtype;beginselect into rowD from user_tbl where id=5;dbms_output.put_line(rowD.id||’ ‘||rowD.user_name||’ ‘||rowD.password);exceptionwhen too_many_rows thendbms_output.put_line(‘不能将多行赋予一个属性！’);when no_data_found thendbms_output.put_line(‘没有您要查找的数据！’);end; 10.自定义错误declareinvalidError exception;category varchar2(20);begincategory:=’&amp;category’;if category not in(‘附件’,’顶盘’,’备件’) thenraise invalidError;elsedbms_output.put_line(‘您输入的类别是：’||category);end if;exceptionwhen invalidError thendbms_output.put_line(‘无法识别的类别！’);end; 11.引发应用程序异常declareapp_exception exception;grade user_tbl.grade%type;beginselect grade into grade from user_tbl where id=&id;if grade=’A’ thenraise app_exception;elsedbms_output.put_line(‘查询的等级为：’||grade);end if;exceptionwhen app_exception thenraise_application_error(-20001,’未知的等级！’);end;]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
        <tag>oracle sql</tag>
        <tag>oracle 命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle函数]]></title>
    <url>%2F2018%2F12%2F13%2Foracle-function%2F</url>
    <content type="text"><![CDATA[函数的分类: 单行函数分为五种类型：字符函数、数值函数、日期函数、转换函数、通用函数 单行函数:大小写控制函数select lower(‘Hello World’) 转小写, upper(‘Hello World’) 转大写 from dual;–initcap: 首字母大写select initcap(‘hello world’) 首字符大写 from dual; 字符控制函数concat: 字符连接函数, 等同于 ||select concat(‘Hello’,’ World’) from dual; substr:求母串中的某个子串select substr(‘Hello World’,3) from dual;select substr(‘Hello World’,3,4) from dual; length和lengthb: 字符数和字节数select length(‘China’) 字符数, lengthb(‘China’) 字节数 from dual; instr:在母串中，查找子串的位置select instr(‘Hello World’,’ll’) from dual; lpad,rpad: 左右填充,将abcd用*填充到10位select lpad(‘abcd’,10,’‘) 左填充, rpad(‘abcd’,10,’‘) 右填充 from dual; trim: 去掉字符串前后指定的字符select trim(‘H’ from ‘Hello WorldH’) from dual; replace:字符串替换函数select replace(‘Hello Wordl’,’l’,’*’) from dual; 数字函数select round(45.926,2) 四舍五入, trunc(45.926,2) 截断 ,mod(1600,300) 求于 from dual; ROUND函数select round(45.923,0) 整数位, round(45.923,-1) 十位,round(45.923,-2) 百位 from dual; 日期函数显示当前日期select sysdate from dual; 显示时间部分select to_char(sysdate,’yyyy-mm-dd hh24:mi:ss’) from dual; 显示昨天，今天和明天，加减数字仍未日期select sysdate-1 昨天, sysdate 今天, sysdate+1 明天 from dual; 两个日期相减，结果为相差的天数，查询员工信息，显示员工工龄。两个日期不能相加select empno,ename, sysdate-hiredate 天 from emp; 查询员工信息，显示员工工龄,分别按照天，星期，月显示select empno,ename,sysdate-hiredate 天,(sysdate-hiredate)/7 星期, (sysdate-hiredate)/30 月 from emp; months_between:两个日期相差的月数select (sysdate-hiredate)/30 方式一, months_between(sysdate,hiredate) 方式二 from emp; add_months:在指定日期上加上若干个月select add_months(sysdate,1) 下个月, add_months(sysdate,123) “123个月后” from dual last_day: 某个日期当月的最后一天select last_day(sysdate) from dual; next_day:下周六select next_day(sysdate,’星期五’) from dual; 对日期进行四舍五入select round(sysdate,’MONTH’) 月,round(sysdate,’YEAR’) from dual; 对日期进行截断select trunc(sysdate,’MONTH’) 月,trunc(sysdate,’YEAR’) from dual; 日期格式select * from emp where hiredate=to_date(‘1982-01-23’,’yyyy-mm-dd’); 查询当前日期：显示: 2011-09-17 15:12:15今天是星期六select to_char(sysdate,’yyyy-mm-dd hh24:mi:ss”今天是”day’) from dual; 查询员工信息，显示员工的编号，姓名，月薪,要求有货币代码(L)，千位符(,)，小数点(.),select empno,ename,to_char(sal,’L9,999.99’) from emp; 大小写控制函数select lower(‘Hello World’) 转小写, upper(‘Hello World’) 转大写 from dual; initcap: 首字母大写select initcap(‘hello world’) 首字符大写 from dual; 通用函数nvl(exp1,exp2):当exp1为空时，返回exp2nvl2(exp1,exp2,exp3):当exp1为空时，返回exp3；否则返回exp2select ename,sal*12+nvl2(comm,comm,0) 年收入 from emp; NULLIF (expr1, expr2),如果expr1=expr2,返回null;否则,返回expr1select nullif(‘abc’,’abc’) from dual;select nullif(‘abc’,’abcaa’) from dual; COALESCE :找到参数列表中，第一个不为空的值select ename,comm,sal,COALESCE(comm,sal) from emp; 例子:给员工涨工资,根据职位涨，总裁涨1000，经理涨600 其他人员涨400select ename,job,sal 涨前工资,case job when ‘PRESIDENT’ then sal+1000 when ‘MANAGER’ then sal+600 else sal+400 end 涨后工资from emp; select ename,job,sal 涨前工资, decode(job,’PRESIDENT’,sal+1000,’MANAGER’,sal+600,sal+400) 涨后工资 转换函数(Conversion Functions)转换函数将指定字符从一种类型转换为另一种，通常这类函数遵循如下惯例：函数名称后面跟着待转换类型以及输出类型。 TO_CHAR() 本函数又可以分三小类，分别是转换字符-&gt;字符TO_CHAR(c)：将nchar,nvarchar2,clob,nclob类型转换为char类型；例如：SELECT TO_CHAR(‘AABBCC’) FROM DUAL; 转换时间-&gt;字符TO_CHAR(d[,fmt])：将指定的时间(data,timestamp,timestamp with time zone)按照指定格式转换为varchar2类型；例如：SELECT TO_CHAR(sysdate,’yyyy-mm-dd hh24:mi:ss’) FROM DUAL; 转换数值-&gt;字符TO_CHAR(n[,fmt])：将指定数值n按照指定格式fmt转换为varchar2类型并返回；例如：SELECT TO_CHAR(-100, ‘L99G999D99MI’) FROM DUAL; TO_DATE(c[,fmt[,nls]]) 将char,nchar,varchar2,nvarchar2转换为日期类型，如果fmt参数不为空，则按照fmt中指定格式进行转换。注意这里的fmt参数。如果ftm为’J’则表示按照公元制(Julian day)转换，c则必须为大于0并小于5373484的正整数。例如：SELECT TO_DATE(2454336, ‘J’) FROM DUAL;SELECT TO_DATE(‘2007-8-23 23:25:00’, ‘yyyy-mm-dd hh24:mi:ss’) FROM DUAL; 为什么公元制的话，c的值必须不大于5373484呢？因为Oracle的DATE类型的取值范围是公元前4712年1月1日至公元9999年12月31日。看看下面这个语句：SELECT TO_CHAR(TO_DATE(‘9999-12-31’,’yyyy-mm-dd’),’j’) FROM DUAL; TO_NUMBER(c[,fmt[,nls]]) 将char,nchar,varchar2,nvarchar2型字串按照fmt中指定格式转换为数值类型并返回。例如：SELECT TO_NUMBER(‘-100.00’, ‘9G999D99’) FROM DUAL; 其它辅助函数(Miscellaneous Single-Row Functions)DECODE(exp,s1,r1,s2,r2..s,r[,def]) 可以把它理解成一个增强型的if else，只不过它并不通过多行语句，而是在一个函数内实现if else的功能。exp做为初始参数。s做为对比值，相同则返回r，如果s有多个，则持续遍历所有s，直到某个条件为真为止，否则返回默认值def(如果指定了的话)，如果没有默认值，并且前面的对比也都没有为真，则返回空。毫无疑问，decode是个非常重要的函数，在实现行转列等功能时都会用到，需要牢记和熟练使用。 例如：select decode(‘a2’,’a1’,’true1’,’a2’,’true2’,’default’) from dual; GREATEST(n1,n2,…n) 返回序列中的最大值例如：SELECT GREATEST(15,5,75,8) “Greatest” FROM DUAL; LEAST(n1,n2….n) 返回序列中的最小值例如：SELECT LEAST(15,5,75,8) LEAST FROM DUAL; NULLIF(c1,c2)Nullif也是个很有意思的函数。逻辑等价于：CASE WHEN c1 = c2 THEN NULL ELSE c1 END例如：SELECT NULLIF(‘a’,’b’),NULLIF(‘a’,’a’) FROM DUAL; NVL(c1,c2) 逻辑等价于IF c1 is null THEN c2 ELSE c1 END。c1,c2可以是任何类型。如果两者类型不同，则oracle会自动将c2转换为c1的类型。例如：SELECT NVL(null, ‘12’) FROM DUAL; NVL2(c1,c2,c3) 大家可能都用到nvl，但你用过nvl2吗？如果c1非空则返回c2,如果c1为空则返回c3例如：select nvl2(‘a’, ‘b’, ‘c’) isNull,nvl2(null, ‘b’, ‘c’) isNotNull from dual; SYS_CONNECT_BY_PATH(col,c) 该函数只能应用于树状查询。返回通过c1连接的从根到节点的路径。该函数必须与connect by 子句共同使用。多行函数和单行函数相比，oracle提供了丰富的基于组的，多行的函数。这些函数能在select或select的having子句中使用，当用于select子串时常常都和GROUP BY一起使用。多行函数分为接收多个输入，返回一个输出 求员工的工资总和select sum(sal) from emp; 求个数select count(*) from emp; 求平均工资select sum(sal)/count(*) 方式一, avg(sal) 方式二 from emp; 关于空值：组函数会自动滤空select count(*), count(comm) from emp; max和min：求最高工资和最低工资select max(sal) 最高工资,min(sal) 最低工资 from emp; 分组数据：求各个部门的平均工资select deptno,avg(sal) from emp group by deptno; group by作用于多列： 按部门，不同的工种，统计平均工资group by作用于多列：先按照第一列分组；如果相同，再按照第二列分组select deptno,job,avg(sal) from emp group by deptno,job; ：求部门的平均工资大于2000的部门select deptno,avg(sal) from emp group by deptno having avg(sal)&gt;2000; group by的增强select deptno,job,sum(sal) from emp group by rollup(deptno,job); 不同的deptno空两行/取消设置break on deptno skip 2/break on null 转载：https://blog.csdn.net/lailai186/article/]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
        <tag>oracle 函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis完善(spring整合)篇]]></title>
    <url>%2F2018%2F12%2F12%2Fredis4%2F</url>
    <content type="text"><![CDATA[jedisjedis介绍Redis不仅是使用命令来操作，现在基本上主流的语言都有客户端支持，比如java、C、C#、C++、php、Node.js、Go等。在官方网站里列一些Java的客户端，有Jedis、Redisson、Jredis、JDBC-Redis、等其中官方推荐使用Jedis和Redisson。 在企业中用的最多的就是Jedis，下面我们就重点学习下Jedis。Jedis同样也是托管在github上，地址：https://github.com/xetorthio/jedis 通过jedis连接redis单机jar包pom坐标： &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; 单实例连接通过创建单实例jedis对象连接redis服务，如下代码： // 单实例连接redis @Test public void testJedisSingle() { Jedis jedis = new Jedis(&quot;192.168.101.3&quot;, 6379); jedis.set(&quot;name&quot;, &quot;bar&quot;); String name = jedis.get(&quot;name&quot;); System.out.println(name); jedis.close(); } 连接超时解决由于linux防火墙默认开启，redis的服务端口6379并不在开放规则之内，所有需要将此端口开放访问或者关闭防火墙。 关闭防火墙命令： sevice iptables stop 如果是修改防火墙规则，可以修改： /etc/sysconfig/iptables文件 使用连接池连接通过单实例连接redis不能对redis连接进行共享，可以使用连接池对redis连接进行共享，提高资源利用率，使用jedisPool连接redis服务，如下代码： @Test public void pool() { JedisPoolConfig config = new JedisPoolConfig(); //最大连接数 config.setMaxTotal(30); //最大连接空闲数 config.setMaxIdle(2); JedisPool pool = new JedisPool(config, &quot;192.168.101.3&quot;, 6379); Jedis jedis = null; try { jedis = pool.getResource(); jedis.set(&quot;name&quot;, &quot;lisi&quot;); String name = jedis.get(&quot;name&quot;); System.out.println(name); }catch(Exception ex){ ex.printStackTrace(); }finally{ if(jedis != null){ //关闭连接 jedis.close(); } } } jedis与spring整合配置spring配置文件applicationContext.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd &quot;&gt; 连接池配置 &lt;bean id=&quot;jedisPoolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt; &lt;!-- 最大连接数 --&gt; &lt;property name=&quot;maxTotal&quot; value=&quot;30&quot; /&gt; &lt;!-- 最大空闲连接数 --&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;10&quot; /&gt; &lt;!-- 每次释放连接的最大数目 --&gt; &lt;property name=&quot;numTestsPerEvictionRun&quot; value=&quot;1024&quot; /&gt; &lt;!-- 释放连接的扫描间隔（毫秒） --&gt; &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;30000&quot; /&gt; &lt;!-- 连接最小空闲时间 --&gt; &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;1800000&quot; /&gt; &lt;!-- 连接空闲多久后释放, 当空闲时间&gt;该值 且 空闲连接&gt;最大空闲连接数 时直接释放 --&gt; &lt;property name=&quot;softMinEvictableIdleTimeMillis&quot; value=&quot;10000&quot; /&gt; &lt;!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 --&gt; &lt;property name=&quot;maxWaitMillis&quot; value=&quot;1500&quot; /&gt; &lt;!-- 在获取连接的时候检查有效性, 默认false --&gt; &lt;property name=&quot;testOnBorrow&quot; value=&quot;true&quot; /&gt; &lt;!-- 在空闲时检查有效性, 默认false --&gt; &lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot; /&gt; &lt;!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true --&gt; &lt;property name=&quot;blockWhenExhausted&quot; value=&quot;false&quot; /&gt; &lt;/bean&gt; &lt;!-- redis单机 通过连接池 --&gt; &lt;bean id=&quot;jedisPool&quot; class=&quot;redis.clients.jedis.JedisPool&quot; destroy-method=&quot;close&quot;&gt; &lt;constructor-arg name=&quot;poolConfig&quot; ref=&quot;jedisPoolConfig&quot;/&gt; &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.145&quot;/&gt; &lt;constructor-arg name=&quot;port&quot; value=&quot;6379&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; 测试代码： private ApplicationContext applicationContext; @Before public void init() { applicationContext = new ClassPathXmlApplicationContext( &quot;classpath:applicationContext.xml&quot;); } @Test public void testJedisPool() { JedisPool pool = (JedisPool) applicationContext.getBean(&quot;jedisPool&quot;); try { Jedis jedis = pool.getResource(); jedis.set(&quot;name&quot;, &quot;lisi&quot;); String name = jedis.get(&quot;name&quot;); System.out.println(name); }catch(Exception ex){ ex.printStackTrace(); }finally{ if(jedis != null){ //关闭连接 jedis.close(); } } }]]></content>
      <categories>
        <category>spring-redis</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>redis</tag>
        <tag>非关系型数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis高级篇]]></title>
    <url>%2F2018%2F12%2F12%2Fredis3%2F</url>
    <content type="text"><![CDATA[持久化Redis的高性能是由于其将所有数据都存储在了内存中为了使Redis在重启之后仍能保证数据不丢失，需要将数据从内存中同步到硬盘中，这一过程就是持久化。Redis支持两种方式的持久化，一种是RDB方式，一种是AOF方式。可以单独使用其中一种或将二者结合使用。 RDB持久化RDB方式的持久化是通过快照（snapshotting）完成的，当符合一定条件时Redis会自动将内存中的数据进行快照并持久化到硬盘。RDB是Redis默认采用的持久化方式，在redis.conf配置文件中默认有此下配置： save 900 1save 300 10save 60 10000 save 开头的一行就是持久化配置，可以配置多个条件（每行配置一个条件），每个条件之间是“或”的关系，“save 900 1”表示15分钟（900秒钟）内至少1个键被更改则进行快照，“save 300 10”表示5分钟（300秒）内至少10个键被更改则进行快照。 在redis.conf中：配置dir指定rdb快照文件的位置配置dbfilenam指定rdb快照文件的名称 Redis启动后会读取RDB快照文件，将数据从硬盘载入到内存。根据数据量大小与结构和服务器性能不同，这个时间也不同。通常将记录一千万个字符串类型键、大小为1GB的快照文件载入到内存中需要花费20～30秒钟。 问题总结：通过RDB方式实现持久化，一旦Redis异常退出，就会丢失最后一次快照以后更改的所有数据。这就需要开发者根据具体的应用场合，通过组合设置自动快照条件的方式来将可能发生的数据损失控制在能够接受的范围。如果数据很重要以至于无法承受任何损失，则可以考虑使用AOF方式进行持久化。 AOF持久化默认情况下Redis没有开启AOF（append only file）方式的持久化，可以通过appendonly参数开启：appendonly yes开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof，可以通过appendfilename参数修改：appendfilename appendonly.aof 主从复制（了解）什么是主从复制持久化保证了即使redis服务重启也会丢失数据，因为redis服务重启后会将硬盘上持久化的数据恢复到内存中，但是当redis服务器的硬盘损坏了可能会导致数据丢失，如果通过redis的主从复制机制就可以避免这种单点故障，如下图： 说明：主redis中的数据有两个副本（replication）即从redis1和从redis2，即使一台redis服务器宕机其它两台redis服务也可以继续提供服务。主redis中的数据和从redis上的数据保持实时同步，当主redis写入数据时通过主从复制机制会复制到两个从redis服务上。只有一个主redis，可以有多个从redis。主从复制不会阻塞master，在同步数据时，master 可以继续处理client 请求一个redis可以即是主又是从，如下图： 主从配置主redis配置无需特殊配置。 从redis配置修改从redis服务器上的redis.conf文件，添加slaveof 主redisip 主redis端口 上边的配置说明当前该从redis服务器所对应的主redis是192.168.101.3，端口是6379 主从复制过程完整复制在redis2.8版本之前主从复制过程如下图： 复制过程说明： 1、slave 服务启动，slave 会建立和master 的连接，发送sync 命令。2、master启动一个后台进程将数据库快照保存到RDB文件中注意：此时如果生成RDB文件过程中存在写数据操作会导致RDB文件和当前主redis数据不一致，所以此时master 主进程会开始收集写命令并缓存起来。3、master 就发送RDB文件给slave4、slave 将文件保存到磁盘上，然后加载到内存恢复5、master把缓存的命令转发给slave注意：后续master 收到的写命令都会通过开始建立的连接发送给slave。当master 和slave 的连接断开时slave 可以自动重新建立连接。如果master 同时收到多个slave 发来的同步连接命令，只会启动一个进程来写数据库镜像，然后发送给所有slave。 完整复制的问题： 在redis2.8之前从redis每次同步都会从主redis中复制全部的数据，如果从redis是新创建的从主redis中复制全部的数据这是没有问题的，但是，如果当从redis停止运行，再启动时可能只有少部分数据和主redis不同步，此时启动redis仍然会从主redis复制全部数据，这样的性能肯定没有只复制那一小部分不同步的数据高。 部分复制部分复制说明：从机连接主机后，会主动发起 PSYNC 命令，从机会提供 master的runid(机器标识，随机生成的一个串) 和 offset（数据偏移量，如果offset主从不一致则说明数据不同步），主机验证 runid 和 offset 是否有效， runid 相当于主机身份验证码，用来验证从机上一次连接的主机，如果runid验证未通过则，则进行全同步，如果验证通过则说明曾经同步过，根据offset同步部分数据。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>非关系型数据库</tag>
        <tag>数据库</tag>
        <tag>缓存数据库</tag>
        <tag>持久化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis基础篇]]></title>
    <url>%2F2018%2F12%2F12%2Fredis1%2F</url>
    <content type="text"><![CDATA[redis介绍1.什么是NoSQL?NoSQL，泛指非关系型的数据库，NoSQL即Not-Only SQL，它可以作为关系型数据库的良好补充。随着互联网web2.0网站的兴起，非关系型的数据库现在成了一个极其热门的新领域，非关系数据库产品的发展非常迅速。而传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，例如： 1、High performance - 对数据库高并发读写的需求web2.0网站要根据用户个性化信息来实时生成动态页面和提供动态信息，所以基本上无法使用动态页面静态化技术，因此数据库并发负载非常高，往往要达到每秒上万次读写请求。关系数据库应付上万次SQL查询还勉强顶得住，但是应付上万次SQL写数据请求，硬盘IO就已经无法承受了。其实对于普通的BBS网站，往往也存在对高并发写请求的需求，例如网站的实时统计在线用户状态，记录热门帖子的点击次数，投票计数等，因此这是一个相当普遍的需求。 2、Huge Storage - 对海量数据的高效率存储和访问的需求类似Facebook，twitter，Friendfeed这样的SNS网站，每天用户产生海量的用户动态，以Friendfeed为例，一个月就达到了2.5亿条用户动态，对于关系数据库来说，在一张2.5亿条记录的表里面进行SQL查询，效率是极其低下乃至不可忍受的。再例如大型web网站的用户登录系统，例如腾讯，盛大，动辄数以亿计的帐号，关系数据库也很难应付。 3、High Scalability &amp;&amp; High Availability- 对数据库的高可扩展性和高可用性的需求在基于web的架构当中，数据库是最难进行横向扩展的，当一个应用系统的用户量和访问量与日俱增的时候，你的数据库却没有办法像web server和app server那样简单的通过添加更多的硬件和服务节点来扩展性能和负载能力。对于很多需要提供24小时不间断服务的网站来说，对数据库系统进行升级和扩展是非常痛苦的事情，往往需要停机维护和数据迁移，为什么数据库不能通过不断的添加服务器节点来实现扩展呢？ NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。 一些主流的NOSQL产品： NoSQL数据库的四大分类如下： 键值(Key-Value)存储数据库:相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB典型应用： 内容缓存，主要用于处理大量数据的高访问负载。数据模型： 一系列键值对优势： 快速查询劣势： 存储的数据缺少结构化 列存储数据库：相关产品：Cassandra, HBase, Riak典型应用：分布式的文件系统数据模型：以列簇式存储，将同一列数据存在一起优势：查找速度快，可扩展性强，更容易进行分布式扩展劣势：功能相对局限 文档型数据库：相关产品：CouchDB、MongoDB典型应用：Web应用（与Key-Value类似，Value是结构化的）数据模型： 一系列键值对 优势：数据结构要求不严格 劣势： 查询性能不高，而且缺乏统一的查询语法 图形(Graph)数据库：相关数据库：Neo4J、InfoGrid、Infinite Graph典型应用：社交网络数据模型：图结构优势：利用图结构相关算法。劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。 2.redis历史发展2008年，意大利的一家创业公司Merzia推出了一款基于MySQL的网站实时统计系统LLOOGG，然而没过多久该公司的创始人 Salvatore Sanfilippo便 对MySQL的性能感到失望，于是他决定亲自为LLOOGG量身定做一个数据库，并于2009年开发完成，这个数据库就是Redis。 不过Salvatore Sanfilippo并不满足只将Redis用于LLOOGG这一款产品，而是希望更多的人使用它，于是在同一年Salvatore Sanfilippo将Redis开源发布，并开始和Redis的另一名主要的代码贡献者Pieter Noordhuis一起继续着Redis的开发，直到今天。Salvatore Sanfilippo自己也没有想到，短短的几年时间，Redis就拥有了庞大的用户群体。Hacker News在2012年发布了一份数据库的使用情况调查，结果显示有近12%的公司在使用Redis。国内如新浪微博、街旁网、知乎网，国外如GitHub、Stack Overflow、Flickr等都是Redis的用户。 VMware公司从2010年开始赞助Redis的开发， Salvatore Sanfilippo和Pieter Noordhuis也分别在3月和5月加入VMware，全职开发Redis。 3.什么是redisRedis是用C语言开发的一个开源的高性能键值对（key-value）数据库。 它通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下： 字符串类型散列类型列表类型集合类型有序集合类型。3.4redis的应用场景缓存（数据查询、短连接、新闻内容、商品内容等等）。（最多使用）分布式集群架构中的session分离。聊天室的在线好友列表。任务队列。（秒杀、抢购、12306等等）应用排行榜。网站访问统计。数据过期处理（可以精确到毫秒） 4.测试环境redis需要安装在linux服务器上运行测试，本教程使用 linux虚拟机及ssh客户端进行功能测试。 4.1 虚拟机创建Centos6.4虚拟机作为linux服务器。 虚拟机ip：192.168.93.88 4.2 ssh客户端在开发环境(windows)安装ssh客户端，本教程使用SecureCRT作为ssh客户端连接虚拟机。 5.安装运行redis5.1redis安装环境redis是C语言开发，建议在linux上运行，本教程使用Centos6.4作为安装环境。 安装redis需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境， 需要安装gcc：yum install gcc-c++ 5.2redis安装版本说明 本教程使用redis3.0版本。3.0版本主要增加了redis集群功能。 源码下载 从官网下载 http://download.redis.io/releases/redis-3.0.0.tar.gz 将redis-3.0.0.tar.gz拷贝到/usr/local下 解压源码 tar -zxvf redis-3.0.0.tar.gz 进入解压后的目录进行编译 cd /usr/local/redis-3.0.0 make 安装到指定目录,如 /usr/local/redis cd /usr/local/redis-3.0.0 make PREFIX=/usr/local/redis install redis.conf redis.conf是redis的配置文件，redis.conf在redis源码目录。 注意修改port作为redis进程的端口,port默认6379。 拷贝配置文件到安装目录下 进入源码目录，里面有一份配置文件 redis.conf，然后将其拷贝到安装路径下 cd /usr/local/redis mkdir conf cp /usr/local/redis-3.0.0/redis.conf /usr/local/redis/bin 安装目录bin下的文件列表 redis3.0新增的redis-sentinel是redis集群管理工具可实现高可用。 5.3 redis启动5.3.1前端模式启动 直接运行bin/redis-server将以前端模式启动， 前端模式启动的缺点是ssh命令窗口关闭则redis-server程序结束， 不推荐使用此方法。 5.3.2后端模式启动 修改redis.conf配置文件， daemonize yes 以后端模式启动。 执行如下命令启动redis： cd /usr/local/redis ./bin/redis-server ./redis.conf redis默认使用6379端口。 也可更改redis.conf文件，修改端口号： 5.3.3启动多个redis进程 方法1： 启动时指定端口可在一台服务器启动多个redis进程。 cd /usr/local/redis/bin ./redis-server ./redis.conf --port 6380 方法2(推荐此方法)： 创建多个redis目录，以端口号命名，比如：创建6379、6380两个目录， redis的安装文件bin和conf拷贝至这两个目录。 修改6379目录下的redis.conf设置端口号为6379 修改6380目录下的redis.conf设置端口号为6380 启动6379和6380目录下的redis-server程序： cd 6379 ./redis-server . /redis.conf cd 6380 ./redis-server . /redis.conf 查询当前redis的进程： ps aux | grep redis 5.4redis停止强行终止Redis进程可能会导致redis持久化数据丢失。 正确停止Redis的方式应该是向Redis发送SHUTDOWN命令， 方法为： cd /usr/local/redis ./bin/redis-cli shutdown 5.5redis客户端在redis的安装目录中有redis的客户端，即redis-cli（Redis Command Line Interface）， 它是Redis自带的基于命令行的Redis客户端。 5.5.1连接redis服务端 执行bin/redis-cli连接redis服务端： 从上图得知redis-cli默认连接本机的redis，本机的redis没有启动则报上图中的错误。 指定连接redis服务的ip和端口： 5.5.2向redis服务端发送命令 redis-cli连上redis服务后，可以在命令行发送命令。 ping Redis提供了PING命令来测试客户端与Redis的连接是否正常，如果连接正常会收到回复PONG set/get 使用set和get可以向redis设置数据、获取数据。 del 删除指定key的内容。 例如：del name Keys * 查看当前库中所有的key值 5.6redis多数据库5.6.1redis实例 一个redis进程就是一个redis实例，一台服务器可以同时有多个redis实例， 不同的redis实例提供不同的服务端口对外提供服务，每个redis实例之间互相影响。 每个redis实例都包括自己的数据库，数据库中可以存储自己的数据。 5.6.2多数据库测试 一个Redis实例可以包括多个数据库，客户端可以指定连接某个redis实例的哪个数据库， 就好比一个mysql中创建多个数据库，客户端连接时指定连接哪个数据库。 一个redis实例最多可提供16个数据库，下标从0到15，客户端默认连接第0号数据库， 也可以通过select选择连接哪个数据库，如下连接1号库： 在1号库中查询上节设置的数据，结果查询不到： 重新选择第0号数据库，查询数据： 如果选择一个不存在数据库则会报错： 注意：redis不支持修改数据库的名称，只能通过select 0、select 1...选择数据库。 5.6.3注意问题 在0号数据库存储数据，在1号数据库执行清空数据命令却把0号数据库的数据给清空了： 建议：不同的应用系统要使用不同的redis实例而不是使用同一个redis实例下的不同数据库。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>非关系型数据库</tag>
        <tag>数据库</tag>
        <tag>缓存数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis进阶篇]]></title>
    <url>%2F2018%2F12%2F12%2Fredis2%2F</url>
    <content type="text"><![CDATA[数据类型–stringredis string介绍redis中没有使用C语言的字符串表示，而是自定义一个数据结构叫SDS（simple dynamic string）即简单动态字符串。打开下载的redis源码包，找到src下的sds.h文件查看sds源码： struct sdshdr { //字符串长度 unsigned int len; //buf数组中未使用的字节数量 unsigned int free; //用于保存字符串 char buf[]; }; c语言对字符串的存储是使用字符数组，遇到’\0’字符则认为字符串结束，redis的字符串可以存储任何类型的数据，因为任何类型数据都可以表示成二进制，sds结构中的char buf[]就是存储了二进制数据。redis的字符串是二进制安全的，什么是二进制安全？简单理解就是存入什么数据取出的还是什么数据。redis中的sds不像c语言处理字符串那样遇到’\0’字符则认证字符串结束，它不会对存储进去的二进制数据进行处理，存入什么数据取出还是什么数据。 命令赋值SET key value: 127.0.0.1:6379&gt; set test 123 OK 取值：GET key: 127.0.0.1:6379&gt; get test &quot;123“ 当键不存在时返回空结果。 删除Del key: 127.0.0.1:6379&gt; del test (integer) 1 数值增减递增数字 INCR key: 当存储的字符串是整数时，Redis提供了一个实用的命令INCR，其作用是让当前键值递增，并返回递增后的值。 127.0.0.1:6379&gt; incr num (integer) 1 127.0.0.1:6379&gt; incr num (integer) 2 127.0.0.1:6379&gt; incr num (integer) 3 增加指定的整数 INCRBY key increment: 127.0.0.1:6379&gt; incrby num 2 (integer) 5 127.0.0.1:6379&gt; incrby num 2 (integer) 7 127.0.0.1:6379&gt; incrby num 2 (integer) 9 递减数值: DECR key 其它命令减少指定的整数 :DECRBY key decrement 127.0.0.1:6379&gt; decr num (integer) 6 127.0.0.1:6379&gt; decr num (integer) 5 127.0.0.1:6379&gt; decrby num 3 (integer) 2 127.0.0.1:6379&gt; decrby num 3 (integer) -1 向尾部追加值 :APPEND key valueAPPEND的作用是向键值的末尾追加value。如果键不存在则将该键的值设置为value，即相当于 SET key value。返回值是追加后字符串的总长度。 127.0.0.1:6379&gt; set str hello OK 127.0.0.1:6379&gt; append str &quot; world!&quot; (integer) 12 127.0.0.1:6379&gt; get str &quot;hello world!&quot; 获取字符串长度 :STRLEN keySTRLEN命令返回键值的长度，如果键不存在则返回0。 127.0.0.1:6379&gt; strlen str (integer) 0 127.0.0.1:6379&gt; set str hello OK 127.0.0.1:6379&gt; strlen str (integer) 5 同时设置/获取多个键值 :MSET key value [key value …]MGET key [key …] 127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3 OK 127.0.0.1:6379&gt; get k1 &quot;v1&quot; 127.0.0.1:6379&gt; mget k1 k3 1) &quot;v1&quot; 2) &quot;v3&quot; 应用自增主键商品编号、订单号采用string的递增数字特性生成。 定义商品编号key：items:id 192.168.101.3:7003&gt; INCR items:id (integer) 2 192.168.101.3:7003&gt; INCR items:id (integer) 3 数据类型–hash使用string的问题假设有User对象以JSON序列化的形式存储到Redis中，User对象有id，username、password、age、name等属性，存储的过程如下： 保存、更新： User对象 json(string) redis 如果在业务上只是更新age属性，其他的属性并不做更新我应该怎么做呢？ 如果仍然采用上边的方法在传输、处理时会造成资源浪费，下边讲的hash可以很好的解决这个问题。 redis hash介绍hash叫散列类型，它提供了字段和字段值的映射。字段值只能是字符串类型，不支持散列类型、集合类型等其它类型。如下： 命令赋值HSET key field value 一次只能设置一个字段值 127.0.0.1:6379&gt; hset user username zhangsan (integer) 1 HMSET key field value [field value …] 一次可以设置多个字段值 127.0.0.1:6379&gt; hmset user age 20 username lisi OK 取值HGET key field 一次只能获取一个字段值 127.0.0.1:6379&gt; hget user username &quot;zhangsan“ HMGET key field [field …] 一次可以获取多个字段值 127.0.0.1:6379&gt; hmget user age username 1) &quot;20&quot; 2) &quot;lisi&quot; HGETALL key 127.0.0.1:6379&gt; hgetall user 1) &quot;age&quot; 2) &quot;20&quot; 3) &quot;username&quot; 4) &quot;lisi&quot; HSET命令不区分插入和更新操作，当执行插入操作时HSET命令返回1，当执行更新操作时返回0. 删除字段可以删除一个或多个字段，返回值是被删除的字段个数HDEL key field [field …] 127.0.0.1:6379&gt; hdel user age (integer) 1 127.0.0.1:6379&gt; hdel user age name (integer) 0 127.0.0.1:6379&gt; hdel user age username (integer) 1 增加数字HINCRBY key field increment 127.0.0.1:6379&gt; hincrby user age 2 将用户的年龄加2 (integer) 22 127.0.0.1:6379&gt; hget user age 获取用户的年龄 &quot;22“ 其它命令判断字段是否存在HEXISTS key field 127.0.0.1:6379&gt; hexists user age 查看user中是否有age字段 (integer) 1 127.0.0.1:6379&gt; hexists user name 查看user中是否有name字段 (integer) 0 HSETNX key field value 当字段不存在时赋值，类似HSET，区别在于如果字段已经存在，该命令不执行任何操作。 127.0.0.1:6379&gt; hsetnx user age 30 如果user中没有age字段则设置age值为30，否则不做任何操作 (integer) 0 只获取字段名或字段值 HKEYS key HVALS key 127.0.0.1:6379&gt; hmset user age 20 name lisi OK 127.0.0.1:6379&gt; hkeys user 1) &quot;age&quot; 2) &quot;name&quot; 127.0.0.1:6379&gt; hvals user 1) &quot;20&quot; 2) &quot;lisi&quot; 获取字段数量HLEN key 127.0.0.1:6379&gt; hlen user (integer) 2 应用商品信息商品id、商品名称、商品描述、商品库存、商品好评 定义商品信息的key：商品1001的信息在 redis中的key为：items:1001 存储商品信息: 192.168.101.3:7003&gt; HMSET items:1001 id 3 name apple price 999.9 OK 获取商品信息: 192.168.101.3:7003&gt; HGET items:1001 id &quot;3&quot; .168.101.3:7003&gt; HGETALL items:1001 1) &quot;id&quot; 2) &quot;3&quot; 3) &quot;name&quot; 4) &quot;apple&quot; 5) &quot;price&quot; 6) &quot;999.9&quot; 数据类型–listArrayList与LinkedList的区别ArrayList使用数组方式存储数据，所以根据索引查询数据速度快，而新增或者删除元素时需要设计到位移操作，所以比较慢。LinkedList使用双向链接方式存储数据，每个元素都记录前后元素的指针，所以插入、删除数据时只是更改前后元素的指针指向即可，速度非常快，然后通过下标查询元素时需要从头开始索引，所以比较慢，但是如果查询前几个元素或后几个元素速度比较快。 redis list介绍列表类型（list）可以存储一个有序的字符串列表，常用的操作是向列表两端添加元素，或者获得列表的某一个片段。列表类型内部是使用双向链表（double linked list）实现的，所以向列表两端添加元素的时间复杂度为0(1)，获取越接近两端的元素速度就越快。这意味着即使是一个有几千万个元素的列表，获取头部或尾部的10条记录也是极快的。 命令向列表两端增加元素。LPUSH key value [value …] RPUSH key value [value …] 向列表左边增加元素 127.0.0.1:6379&gt; lpush list:1 1 2 3 (integer) 3 向列表右边增加元素 127.0.0.1:6379&gt; rpush list:1 4 5 6 (integer) 3 查看列表LRANGE key start stop LRANGE命令是列表类型最常用的命令之一，获取列表中的某一片段，将返回start、stop之间的所有元素（包含两端的元素），索引从0开始。索引可以是负数，如：“-1”代表最后边的一个元素。 127.0.0.1:6379&gt; lrange list:1 0 2 1) &quot;2&quot; 2) &quot;1&quot; 3) &quot;4&quot; 从列表两端弹出元素LPOP key RPOP key LPOP命令从列表左边弹出一个元素，会分两步完成，第一步是将列表左边的元素从列表中移除，第二步是返回被移除的元素值。 127.0.0.1:6379&gt; lpop list:1 &quot;3“ 127.0.0.1:6379&gt; rpop list:1 &quot;6“ 获取列表中元素的个数LLEN key 127.0.0.1:6379&gt; llen list:1 (integer) 2 ####其它命令删除列表中指定的值 : LREM key count value LREM命令会删除列表中前count个值为value的元素，返回实际删除的元素个数。根据count值的不同， 该命令的执行方式会有所不同： 当count&gt;0时， LREM会从列表左边开始删除。 当count&lt;0时， LREM会从列表后边开始删除。 当count=0时， LREM删除所有值为value的元素。 获得/设置指定索引的元素值 : LINDEX key index LSET key index value 127.0.0.1:6379&gt; lindex l:list 2 &quot;1&quot; 127.0.0.1:6379&gt; lset l:list 2 2 OK 127.0.0.1:6379&gt; lrange l:list 0 -1 1) &quot;6&quot; 2) &quot;5&quot; 3) &quot;2&quot; 4) &quot;2&quot; 只保留列表指定片段，指定范围和LRANGE一致 : LTRIM key start stop 127.0.0.1:6379&gt; lrange l:list 0 -1 1) &quot;6&quot; 2) &quot;5&quot; 3) &quot;0&quot; 4) &quot;2&quot; 127.0.0.1:6379&gt; ltrim l:list 0 2 OK 127.0.0.1:6379&gt; lrange l:list 0 -1 1) &quot;6&quot; 2) &quot;5&quot; 3) &quot;0&quot; 向列表中插入元素 : LINSERT key BEFORE|AFTER pivot value该命令首先会在列表中从左到右查找值为pivot的元素，然后根据第二个参数是BEFORE还是AFTER来决定将value插入到该元素的前面还是后面。 127.0.0.1:6379&gt; lrange list 0 -1 1) &quot;3&quot; 2) &quot;2&quot; 3) &quot;1&quot; 127.0.0.1:6379&gt; linsert list after 3 4 (integer) 4 127.0.0.1:6379&gt; lrange list 0 -1 1) &quot;3&quot; 2) &quot;4&quot; 3) &quot;2&quot; 4) &quot;1&quot; 将元素从一个列表转移到另一个列表中 : RPOPLPUSH source destination 127.0.0.1:6379&gt; rpoplpush list newlist &quot;1&quot; 127.0.0.1:6379&gt; lrange newlist 0 -1 1) &quot;1&quot; 127.0.0.1:6379&gt; lrange list 0 -1 1) &quot;3&quot; 2) &quot;4&quot; 3) &quot;2&quot; 应用商品评论列表思路： 在redis中创建商品评论列表 用户发布商品评论，将评论信息转成json存储到list中。 用户在页面查询评论列表，从redis中取出json数据展示到页面。 定义商品评论列表key： 商品编号为1001的商品评论key：items: comment:1001 192.168.101.3:7001&gt; LPUSH items:comment:1001 &apos;{&quot;id&quot;:1,&quot;name&quot;:&quot;商品不错，很好！！&quot;,&quot;date&quot;:1430295077289}&apos; 数据类型–setredis set介绍在集合中的每个元素都是不同的，且没有顺序。 集合类型和列表类型的对比： 集合类型的常用操作是向集合中加入或删除元素、判断某个元素是否存在等，由于集合类型的Redis内部是使用值为空的散列表实现，所有这些操作的时间复杂度都为0(1)。 Redis还提供了多个集合之间的交集、并集、差集的运算。 ###命令 增加/删除元素SADD key member [member …] SREM key member [member …] 127.0.0.1:6379&gt; sadd set a b c (integer) 3 127.0.0.1:6379&gt; sadd set a (integer) 0 127.0.0.1:6379&gt; srem set c d (integer) 1 获得集合中的所有元素SMEMBERS key 127.0.0.1:6379&gt; smembers set 1) &quot;b&quot; 2) &quot;a” 判断元素是否在集合中，无论集合中有多少元素都可以极速的返回结果。 SISMEMBER key member 127.0.0.1:6379&gt; sismember set a (integer) 1 127.0.0.1:6379&gt; sismember set h (integer) 0 其它命令集合的差集运算 A-B属于A并且不属于B的元素构成的集合。 SDIFF key [key …] 127.0.0.1:6379&gt; sadd setA 1 2 3 (integer) 3 127.0.0.1:6379&gt; sadd setB 2 3 4 (integer) 3 127.0.0.1:6379&gt; sdiff setA setB 1) &quot;1&quot; 127.0.0.1:6379&gt; sdiff setB setA 1) &quot;4&quot; 集合的交集运算 A ∩ B属于A且属于B的元素构成的集合。 SINTER key [key …] 127.0.0.1:6379&gt; sinter setA setB 1) &quot;2&quot; 2) &quot;3&quot; 集合的并集运算 A ∪ B属于A或者属于B的元素构成的集合 SUNION key [key …] 127.0.0.1:6379&gt; sunion setA setB 1) &quot;1&quot; 2) &quot;2&quot; 3) &quot;3&quot; 4) &quot;4&quot; 其它命令获得集合中元素的个数 SCARD key 127.0.0.1:6379&gt; smembers setA 1) &quot;1&quot; 2) &quot;2&quot; 3) &quot;3&quot; 127.0.0.1:6379&gt; scard setA (integer) 3 从集合中弹出一个元素 SPOP key 127.0.0.1:6379&gt; spop setA &quot;1“ 注意：由于集合是无序的，所有SPOP命令会从集合中随机选择一个元素弹出 数据类型–sorted setredis sorted set介绍在集合类型的基础上有序集合类型为集合中的每个元素都关联一个分数，这使得我们不仅可以完成插入、删除和判断元素是否存在在集合中，还能够获得分数最高或最低的前N个元素、获取指定分数范围内的元素等与分数有关的操作。 在某些方面有序集合和列表类型有些相似。 1、二者都是有序的。 2、二者都可以获得某一范围的元素。 但是，二者有着很大区别： 1、列表类型是通过链表实现的，获取靠近两端的数据速度极快，而当元素增多后，访问中间数据的速度会变慢。 2、有序集合类型使用散列表实现，所有即使读取位于中间部分的数据也很快。 3、列表中不能简单的调整某个元素的位置，但是有序集合可以（通过更改分数实现）4、有序集合要比列表类型更耗内存。 ###命令 ####增加元素向有序集合中加入一个元素和该元素的分数，如果该元素已经存在则会用新的分数替换原有的分数。返回值是新加入到集合中的元素个数，不包含之前已经存在的元素。 ZADD key score member [score member …] 127.0.0.1:6379&gt; zadd scoreboard 80 zhangsan 89 lisi 94 wangwu (integer) 3 127.0.0.1:6379&gt; zadd scoreboard 97 lisi (integer) 0 获取元素的分数 ZSCORE key member 127.0.0.1:6379&gt; zscore scoreboard lisi &quot;97&quot; 删除元素ZREM key member [member …] 移除有序集key中的一个或多个成员，不存在的成员将被忽略。 当key存在但不是有序集类型时，返回一个错误。 127.0.0.1:6379&gt; zrem scoreboard lisi (integer) 1 获得排名在某个范围的元素列表获得排名在某个范围的元素列表 ZRANGE key start stop [WITHSCORES]照元素分数从小到大的顺序返回索引从start到stop之间的所有元素（包含两端的元素） 127.0.0.1:6379&gt; zrange scoreboard 0 2 1) &quot;zhangsan&quot; 2) &quot;wangwu&quot; 3) &quot;lisi“ ZREVRANGE key start stop [WITHSCORES]照元素分数从大到小的顺序返回索引从start到stop之间的所有元素（包含两端的元素） 127.0.0.1:6379&gt; zrevrange scoreboard 0 2 1) &quot; lisi &quot; 2) &quot;wangwu&quot; 3) &quot; zhangsan “ 如果需要获得元素的分数的可以在命令尾部加上WITHSCORES参数 127.0.0.1:6379&gt; zrange scoreboard 0 1 WITHSCORES 1) &quot;zhangsan&quot; 2) &quot;80&quot; 3) &quot;wangwu&quot; 4) &quot;94&quot; 其它命令获得指定分数范围的元素 ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] 127.0.0.1:6379&gt; ZRANGEBYSCORE scoreboard 90 97 WITHSCORES 1) &quot;wangwu&quot; 2) &quot;94&quot; 3) &quot;lisi&quot; 4) &quot;97&quot; 127.0.0.1:6379&gt; ZRANGEBYSCORE scoreboard 70 100 limit 1 2 1) &quot;wangwu&quot; 2) &quot;lisi&quot; 增加某个元素的分数，返回值是更改后的分数 ZINCRBY key increment member 给lisi加4分 127.0.0.1:6379&gt; ZINCRBY scoreboard 4 lisi &quot;101“ 获得集合中元素的数量 ZCARD key 127.0.0.1:6379&gt; ZCARD scoreboard (integer) 3 获得指定分数范围内的元素个数 ZCOUNT key min max 127.0.0.1:6379&gt; ZCOUNT scoreboard 80 90 (integer) 1 按照排名范围删除元素 ZREMRANGEBYRANK key start stop 127.0.0.1:6379&gt; ZREMRANGEBYRANK scoreboard 0 1 (integer) 2 127.0.0.1:6379&gt; ZRANGE scoreboard 0 -1 1) &quot;lisi&quot; ZREMRANGEBYSCORE key min max 按照分数范围删除元素 127.0.0.1:6379&gt; zadd scoreboard 84 zhangsan (integer) 1 127.0.0.1:6379&gt; ZREMRANGEBYSCORE scoreboard 80 100 (integer) 1 获取元素的排名 ZRANK key member ZREVRANK key member 从小到大 127.0.0.1:6379&gt; ZRANK scoreboard lisi (integer) 0 从大到小 127.0.0.1:6379&gt; ZREVRANK scoreboard zhangsan (integer) 1 应用商品销售排行榜根据商品销售量对商品进行排行显示，定义sorted set集合，商品销售量为元素的分数。 定义商品销售排行榜key：items:sellsort 写入商品销售量： 商品编号1001的销量是9，商品编号1002的销量是10 192.168.101.3:7007&gt; ZADD items:sellsort 9 1001 10 1002 商品编号1001的销量加1 192.168.101.3:7001&gt; ZINCRBY items:sellsort 1 1001 商品销量前10名： 192.168.101.3:7001&gt; ZRANGE items:sellsort 0 9 withscores keys命令###设置key的生存时间Redis在实际使用过程中更多的用作缓存，然而缓存的数据一般都是需要设置生存时间的，即：到期后数据销毁。 EXPIRE key seconds 设置key的生存时间（单位：秒）key在多少秒后会自动删除 TTL key 查看key生于的生存时间 PERSIST key 清除生存时间 PEXPIRE key milliseconds 生存时间设置单位为：毫秒 例子： 192.168.101.3:7002&gt; set test 1 设置test的值为1 OK 192.168.101.3:7002&gt; get test 获取test的值 &quot;1&quot; 192.168.101.3:7002&gt; EXPIRE test 5 设置test的生存时间为5秒 (integer) 1 192.168.101.3:7002&gt; TTL test 查看test的生于生成时间还有1秒删除 (integer) 1 192.168.101.3:7002&gt; TTL test (integer) -2 192.168.101.3:7002&gt; get test 获取test的值，已经删除 (nil) 其它命令（自学）keys 返回满足给定pattern 的所有key redis 127.0.0.1:6379&gt; keys mylist* 1) &quot;mylist&quot; 2) &quot;mylist5&quot; 3) &quot;mylist6&quot; 4) &quot;mylist7&quot; 5) &quot;mylist8&quot; exists 确认一个key 是否存在 redis 127.0.0.1:6379&gt; exists HongWan (integer) 0 redis 127.0.0.1:6379&gt; exists age (integer) 1 redis 127.0.0.1:6379&gt; 从结果来数据库中不存在HongWan 这个key，但是age 这个key 是存在的 del删除一个key redis 127.0.0.1:6379&gt; del age (integer) 1 redis 127.0.0.1:6379&gt; exists age (integer) 0 redis 127.0.0.1:6379&gt; 从结果来数据库中不存在HongWan 这个key，但是age 这个key 是存在的 rename 重命名key redis 127.0.0.1:6379[1]&gt; keys * 1) &quot;age&quot; redis 127.0.0.1:6379[1]&gt; rename age age_new OK redis 127.0.0.1:6379[1]&gt; keys * 1) &quot;age_new&quot; redis 127.0.0.1:6379[1]&gt; age 成功的被我们改名为age_new 了 type返回值的类型 redis 127.0.0.1:6379&gt; type addr string redis 127.0.0.1:6379&gt; type myzset2 zset redis 127.0.0.1:6379&gt; type mylist list redis 127.0.0.1:6379&gt; ##服务器命令 ping测试连接是否存活 redis 127.0.0.1:6379&gt; ping PONG //执行下面命令之前，我们停止redis 服务器 redis 127.0.0.1:6379&gt; ping Could not connect to Redis at 127.0.0.1:6379: Connection refused //执行下面命令之前，我们启动redis 服务器 not connected&gt; ping PONG redis 127.0.0.1:6379&gt; 第一个ping 时，说明此连接正常 第二个ping 之前，我们将redis 服务器停止，那么ping 是失败的 第三个ping 之前，我们将redis 服务器启动，那么ping 是成功的 echo在命令行打印一些内容 redis 127.0.0.1:6379&gt; echo HongWan &quot;HongWan&quot; redis 127.0.0.1:6379&gt; select 选择数据库。Redis 数据库编号从0~15，我们可以选择任意一个数据库来进行数据的存取。 redis 127.0.0.1:6379&gt; select 1 OK redis 127.0.0.1:6379[1]&gt; select 16 (error) ERR invalid DB index redis 127.0.0.1:6379[16]&gt; 当选择16 时，报错，说明没有编号为16 的这个数据库 quit退出连接。 redis 127.0.0.1:6379&gt; quit dbsize返回当前数据库中key 的数目。 redis 127.0.0.1:6379&gt; dbsize (integer) 18 redis 127.0.0.1:6379&gt; 结果说明此库中有18 个key info获取服务器的信息和统计。 redis 127.0.0.1:6379&gt; info redis_version:2.2.12 redis_git_sha1:00000000 redis_git_dirty:0 arch_bits:32 multiplexing_api:epoll process_id:28480 uptime_in_seconds:2515 uptime_in_days:0 flushdb删除当前选择数据库中的所有key。 redis 127.0.0.1:6379&gt; dbsize (integer) 18 redis 127.0.0.1:6379&gt; flushdb OK redis 127.0.0.1:6379&gt; dbsize (integer) 0 redis 127.0.0.1:6379&gt; 在本例中我们将0 号数据库中的key 都清除了。 flushall删除所有数据库中的所有key。 redis 127.0.0.1:6379[1]&gt; dbsize (integer) 1 redis 127.0.0.1:6379[1]&gt; select 0 OK redis 127.0.0.1:6379&gt; flushall OK redis 127.0.0.1:6379&gt; select 1 OK redis 127.0.0.1:6379[1]&gt; dbsize (integer) 0 redis 127.0.0.1:6379[1]&gt; 在本例中我们先查看了一个1 号数据库中有一个key，然后我切换到0 号库执行flushall 命令，结果1 号库中的key 也被清除了，说是此命令工作正常。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>非关系型数据库</tag>
        <tag>数据库</tag>
        <tag>缓存数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot-redis.md]]></title>
    <url>%2F2018%2F12%2F12%2Fspringboot-redis%2F</url>
    <content type="text"><![CDATA[一. Springboot整合Redis(单机版 注解式开发)1.引入redis起步依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-redis&lt;/artifactId&gt; &lt;/dependency&gt; 2.在虚拟机中开启redis服务 启动server: ./redis-server redis.conf (启动客户端测试: ./redis-cli) 3.在applicaction.properties中配置redis 主机和端口号(这里为我的centos中的主机名以及redis端口号，可自行配置 spring.redis.host=192.168.66.66 spring.redis.port=6379 4.在启动类中加入注解@EnableCaching开启缓存 @EnableCaching @SpringBootApplication 5.在service实现类中利用@Cacheable设置缓存 /** * value : 缓存的名字 , * key ： 缓存map中的key * @param id * @return */ @Cacheable(value = { &quot;sampleCache&quot; },key=&quot;#id&quot;) public String getBook(int id) { System.out.println(&quot;Method executed..&quot;); if (id == 1) { return &quot;Book 1&quot;; } else { return &quot;Book 2&quot;; } } 二. Springboot整合Redis(集群版 注解式开发)1.在applicaction.properties中配置redis 集群 redis.cache.clusterNodes=192.168.66.66:7001,192.168.66.66:7002,192.168.66.66:7003,192.168.66.66:7004 2.自定义config对配置的集群节点进行解析 @Configuration //AaplicationContext.xml public class RedisClusterConfig { //注入集群节点信息 @Value(&quot;${redis.cache.clusterNodes}&quot;) private String clusterNodes; @Bean public JedisCluster getJedisCluster() { // 截取集群节点 String[] cluster = clusterNodes.split(&quot;,&quot;); // 创建set集合 Set&lt;HostAndPort&gt; nodes = new HashSet&lt;HostAndPort&gt;(); // 循环数组把集群节点添加到set集合中 for (String node : cluster) { String[] host = node.split(&quot;:&quot;); //添加集群节点 nodes.add(new HostAndPort(host[0], Integer.parseInt(host[1]))); } //创建集群节点对象 JedisCluster jc = new JedisCluster(nodes); return jc; } 3.在service实现类注入REDIS集群对象并实现缓存 @Autowired private JedisCluster jedisCluster; @Override public Map&lt;String, Object&gt; redisMap() { jedisCluster.set(&quot;user&quot;, &quot;张三丰&quot;); String value = jedisCluster.get(&quot;user&quot;); Map&lt;String, Object&gt; maps = newHashMap&lt;String,Object&gt;(); maps.put(&quot;redis&quot;, value); return maps; }]]></content>
      <categories>
        <category>springboot-redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>非关系型数据库</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
</search>
