<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog of MYH</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-14T05:11:41.124Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>YuHang Ma</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>oracle 数据库 实例 用户 表空间 之间的关系（转）</title>
    <link href="http://yoursite.com/2018/12/13/oracle-framework/"/>
    <id>http://yoursite.com/2018/12/13/oracle-framework/</id>
    <published>2018-12-13T08:00:00.000Z</published>
    <updated>2018-12-14T05:11:41.124Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据库："><a href="#数据库：" class="headerlink" title="数据库："></a>数据库：</h3><p>Oracle数据库是数据的物理存储。这就包括（数据文件ORA或者DBF、控制文件、联机日志、参数文件）。其实Oracle数据库的概念和其它数据库不一样，这里的数据库是一个操作系统只有一个库。可以看作是Oracle就只有一个大数据库。</p><h3 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h3><p>一个Oracle实例（Oracle Instance）有一系列的后台进程（Backguound Processes)和内存结构（Memory Structures)组成。一个数据库可以有n个实例。</p><h3 id="用户："><a href="#用户：" class="headerlink" title="用户："></a>用户：</h3><p>用户是在实例下建立的。不同实例可以建相同名字的用户。</p><h3 id="表空间："><a href="#表空间：" class="headerlink" title="表空间："></a>表空间：</h3><p>表空间是一个用来管理数据存储逻辑概念，表空间只是和数据文件（ORA或者DBF文件）发生关系，数据文件是物理的，一个表空间可以包含多个数据文件，而一个数据文件只能隶属一个表空间。</p><h3 id="数据文件（dbf、ora）："><a href="#数据文件（dbf、ora）：" class="headerlink" title="数据文件（dbf、ora）："></a>数据文件（dbf、ora）：</h3><p> 数据文件是数据库的物理存储单位。数据库的数据是存储在表空间中的，真 正是在某一个或者多个数据文件中。而一个表空间可以由一个或多个数据文件组成，一个数据文件只能属于一个表空间。一旦数据文件被加入到某个表空间后，就不能删除这个文件，如果要删除某个数据文件，只能删除其所属于的表空间才行。</p><h3 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h3><p>表的数据，是有用户放入某一个表空间的，而这个表空间会随机把这些表数据放到一个或者多个数据文件中。由于oracle的数据库不是普通的概念，oracle是有用户和表空间对数据进行管理和存放的。但是表不是有表空间去查询的，而是由用户去查的。因为不同用户可以在同一个表空间建立同一个名字的表！这里区分就是用户了！</p><h3 id="关系示意图："><a href="#关系示意图：" class="headerlink" title="关系示意图："></a>关系示意图：</h3><p><img src="http://pjpn7mq4k.bkt.clouddn.com/oracle1.jpg" alt="avatar"></p><h3 id="理解1："><a href="#理解1：" class="headerlink" title="理解1："></a>理解1：</h3><p>Oracle数据库可以创建多个实例，每个实例可以创建多个表空间，每个表空间下可以创建多个用户（同时用户也属于表空间对应的实例）和数据库文件，用户可以创建多个表（每个表随机存储在一个或多个数据库文件中），如下图：<br><img src="http://pjpn7mq4k.bkt.clouddn.com/oracle2.jpg" alt="avatar"><br>理解2：<br>理解1MS有误。<br>实例下有和，授权访问，是管理的，经授权在中创建，随机存储到不同的中。如下图所示：<br><img src="http://pjpn7mq4k.bkt.clouddn.com/oracle3.jpg" alt="avatar"><br>操作1：<br>安装Oracle后会有默认的实例，即ORCL。一般不创建多个实例，在默认实例下创建表空间和用户等。</p><p>1，运行CMD进入DOS界面，首先输入：sqlplus，回车；再输入：sys/sys as sysdba，回车，即进入“SQL〉”操作状态。</p><p>2，输入：CREATE TABLESPACE 表空间名称 LOGGING DATAFILE ‘c:\表空间数据文件.ora’ SIZE 500M autoextend on next 200m maxsize 2048m;，表空间创建完成。</p><p>3，输入：CREATE USER 用户名称 PROFILE default IDENTIFIED BY 用户密码 DEFAULT TABLESPACE 授权访问的表空间名称 TEMPORARY TABLESPACE temp ACCOUNT UNLOCK;，用户创建完成，并授权用户访问某表空间。</p><p>具体操作如下图所示：<br><img src="http://pjpn7mq4k.bkt.clouddn.com/oracle3.jpg" alt="avatar"><br>操作2：</p><p>创建表和插入数据，并查询浏览插入的数据。</p><p>1，创建表，输入：</p><p>create table 表名(</p><p>字段名称1 字段类型,</p><p>字段名称2 字段类型,</p><p>字段名称3 字段类型</p><p>);，回车。</p><p>2，插入数据，输入：insert into 表名(字段1,字段2,字段3) VALUES</p><p>(值1,值2,值3);，回车。</p><p>3，查询数据，输入：select * from 表名;，回车。</p><p>具体操作如下图所示：<br><img src="http://pjpn7mq4k.bkt.clouddn.com/oracle5.jpg" alt="avatar"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;数据库：&quot;&gt;&lt;a href=&quot;#数据库：&quot; class=&quot;headerlink&quot; title=&quot;数据库：&quot;&gt;&lt;/a&gt;数据库：&lt;/h3&gt;&lt;p&gt;Oracle数据库是数据的物理存储。这就包括（数据文件ORA或者DBF、控制文件、联机日志、参数文件）。其实Oracle数据
      
    
    </summary>
    
      <category term="oracle" scheme="http://yoursite.com/categories/oracle/"/>
    
    
      <category term="oracle" scheme="http://yoursite.com/tags/oracle/"/>
    
      <category term="oracle结构" scheme="http://yoursite.com/tags/oracle%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>oracle单行函数（转||总结）</title>
    <link href="http://yoursite.com/2018/12/13/oracle-function/"/>
    <id>http://yoursite.com/2018/12/13/oracle-function/</id>
    <published>2018-12-13T08:00:00.000Z</published>
    <updated>2018-12-14T09:06:25.378Z</updated>
    
    <content type="html"><![CDATA[<h3 id="大小写转换-lower-upper-initcap"><a href="#大小写转换-lower-upper-initcap" class="headerlink" title="大小写转换(lower,upper,initcap)"></a>大小写转换(lower,upper,initcap)</h3><pre><code>select lower(&apos;Hello World&apos;) 转小写，        upper(&apos;hello world&apos;) 转大写,        initcap(&apos;hello world&apos;) 首字母大写from dual；查询结果:转小写           转大写          首字母大写---------- -------------------  ---------hello world        HELLO WORLD     Hello World</code></pre><h3 id="子串-substr"><a href="#子串-substr" class="headerlink" title="子串(substr)"></a>子串(substr)</h3><pre><code>--select substr(a,b,c) 从a字符串中，从第b位开始取，取到第c位select substr(&apos;Hello World&apos;,3,4) 子串 from dual;查询结果:子串-----llo</code></pre><h3 id="字符-字节-数-length-lengthb"><a href="#字符-字节-数-length-lengthb" class="headerlink" title="字符/字节 数(length/lengthb)"></a>字符/字节 数(length/lengthb)</h3><pre><code>例1）select length(&apos;hello world&apos;) 字符,lengthb(&apos;hello world&apos;) 字节from dual;查询结果:字符     字节------ ------ 11      11例2）select length(&apos;北京&apos;) 字符, lengthb(&apos;北京&apos;) 字节 from dual;查询结果: 字符     字节------ ------ 2        4       </code></pre><h3 id="字串位置查询-instr-a-b"><a href="#字串位置查询-instr-a-b" class="headerlink" title="字串位置查询(instr(a,b))"></a>字串位置查询(instr(a,b))</h3><pre><code>select instr(&apos;hello world&apos;,&apos;ll&apos;) ll的位置from dual;查询结果:LL的位置----- 3</code></pre><h3 id="左右填充-lpad-‘-’-n-’-’-rpad-‘-’-n-’-’"><a href="#左右填充-lpad-‘-’-n-’-’-rpad-‘-’-n-’-’" class="headerlink" title="左右填充(lpad(‘?’,n,’?’)  rpad(‘?’,n,’?’))"></a>左右填充(lpad(‘?’,n,’?’)  rpad(‘?’,n,’?’))</h3><pre><code>说明: 10为补充至10个字节select lpad(&apos;abcd&apos;,10,&apos;*&apos;) 左,rpad(&apos;abcd&apos;,10,&apos;*&apos;) 右 from dual;查询结果:左         右 ---------- ----------    ******abcd abcd******      </code></pre><h3 id="trim-去掉前后指定的字符"><a href="#trim-去掉前后指定的字符" class="headerlink" title="trim 去掉前后指定的字符"></a>trim 去掉前后指定的字符</h3><pre><code>select trim(&apos;H&apos; from &apos;Hello WorldH&apos;) from dual;查询结果:TRIM(&apos;H&apos;FR                              ----------  ello World </code></pre><h3 id="replace-替换"><a href="#replace-替换" class="headerlink" title="replace 替换"></a>replace 替换</h3><pre><code>select replace(&apos;Hello WOrld&apos;,&apos;l&apos;,&apos;*&apos;) from dual;查询结果:REPLACE(&apos;HE       -----------  He**o WOr*d</code></pre><h3 id="round-四舍五入"><a href="#round-四舍五入" class="headerlink" title="round 四舍五入"></a>round 四舍五入</h3><pre><code>select round(45.926,2) 一,round(45.926,1) 二,round(45.926,0) 三,round(45.926,-1) 四,round(45.926,-2) 五 from dual;         查询结果: 一         二         三         四         五 ---------- ---------- ---------- ------- -------- 45.93       45.9         46         50      0 </code></pre><h3 id="trunc-截断"><a href="#trunc-截断" class="headerlink" title="trunc 截断"></a>trunc 截断</h3><pre><code>select trunc(45.926,2) 一,trunc(45.926,1) 二,trunc(45.926,0) 三,trunc(45.926,-1) 四,trunc(45.926,-2) 五from dual查询结果:  一         二         三         四         五 ------ ---------- ---------- ---------- ------------- 45.92       45.9         45         40       0  </code></pre><h3 id="sysdate-当前时间"><a href="#sysdate-当前时间" class="headerlink" title="sysdate 当前时间"></a>sysdate 当前时间</h3><pre><code>select sysdate from dual;查询结果:SYSDATE   -------------01-7月 -16</code></pre><h3 id="格式化时间"><a href="#格式化时间" class="headerlink" title="格式化时间"></a>格式化时间</h3><pre><code>select to_char(sysdate,&apos;yyyy-mm-dd hh24:mi:ss&apos;) from dual;查询结果:TO_CHAR(SYSDATE,&apos;YY                        -------------------                        2018-12-14 15:06:02</code></pre><h3 id="计算员工的工龄：天-星期-月-年"><a href="#计算员工的工龄：天-星期-月-年" class="headerlink" title="计算员工的工龄：天 星期 月 年"></a>计算员工的工龄：天 星期 月 年</h3><pre><code>elect ename,hiredate,(sysdate-hiredate) 天,(sysdate-hiredate)/7 星期,(sysdate-hiredate)/30 月,(sysdate-hiredate)/365 年from emp;查询结果:ENAME    HIREDATE  天       星期        月       年                                                                                   ---- -------------- ---------- ---------- ----------                                                                                  SMITH 17-12月-80 12980.5068 1854.35812 432.683561 35.5630324  ALLEN 20-2月 -81 12915.5068  1845.0724 430.516894 35.3849502 WARD 22-2月 -81 12913.5068 1844.78669 430.450228 35.3794708注意:  不允许日期 + 日期 !</code></pre><h3 id="add-months-53个月后"><a href="#add-months-53个月后" class="headerlink" title="add_months 53个月后"></a>add_months 53个月后</h3><pre><code>select add_months(sysdate,53) from dual;查询结果:ADD_MONTHS(SYS                     -------------- 14-1月-20    </code></pre><h3 id="last-day-某月最后一天"><a href="#last-day-某月最后一天" class="headerlink" title="last_day 某月最后一天"></a>last_day 某月最后一天</h3><pre><code>select last_day(sysdate) from dual;查询结果:LAST_DAY(SYSDA--------------31-12月-18</code></pre><h3 id="下一个周几-next-day"><a href="#下一个周几-next-day" class="headerlink" title="下一个周几 next_day"></a>下一个周几 next_day</h3><pre><code>例(当前日期额下一个周五:)select next_day(sysdate,&apos;星期五&apos;) from dual;查询结果:NEXT_DAY(SYSDA--------------21-12月-18</code></pre><h3 id="查询员工薪水-两位小数，千位符，本地货币代码"><a href="#查询员工薪水-两位小数，千位符，本地货币代码" class="headerlink" title="查询员工薪水:两位小数，千位符，本地货币代码"></a>查询员工薪水:两位小数，千位符，本地货币代码</h3><pre><code>select to_char(sal,&apos;L9,999.99&apos;) from emp;查询结果:TO_CHAR(SAL,&apos;L9,999                    ------------------          ￥800.00     ￥1,600.00     ￥1,250.00   </code></pre><h3 id="nvl2-a-b-c-当a-null的时候，返回c；否则返回b"><a href="#nvl2-a-b-c-当a-null的时候，返回c；否则返回b" class="headerlink" title="nvl2(a,b,c) 当a=null的时候，返回c；否则返回b"></a>nvl2(a,b,c) 当a=null的时候，返回c；否则返回b</h3><pre><code>select sal*12+nvl2(comm,comm,0) from emp;查询结果:SAL*12+NVL2(COMM,COMM,0)   ------------------------    9600   19500   15500   35700</code></pre><h3 id="nullif-a-b-当a-b的时候，返回null；否则返回a"><a href="#nullif-a-b-当a-b的时候，返回null；否则返回a" class="headerlink" title="nullif(a,b) 当a=b的时候，返回null；否则返回a"></a>nullif(a,b) 当a=b的时候，返回null；否则返回a</h3><pre><code>例1:select nullif(&apos;abc&apos;,&apos;abc&apos;) 值 from dual;查询结果:值---例2:select nullif(&apos;abc&apos;,&apos;abcd&apos;) 值 from dual;查询结果:值---abc</code></pre><h3 id="coalesce-从左到右-找到第一个不为null的值"><a href="#coalesce-从左到右-找到第一个不为null的值" class="headerlink" title="coalesce 从左到右 找到第一个不为null的值"></a>coalesce 从左到右 找到第一个不为null的值</h3><pre><code>select comm,sal,coalesce(comm,sal) &quot;第一个不为null的值&quot; from emp;查询结果:      COMM   SAL 第一个不为null的值  ----------- ----- ------------------               800                800    300      1600                300   500      1250                500                  2975               2975   1400      1250               1400 </code></pre><h3 id="涨工资，总裁1000-经理800-其他400"><a href="#涨工资，总裁1000-经理800-其他400" class="headerlink" title="涨工资，总裁1000 经理800 其他400"></a>涨工资，总裁1000 经理800 其他400</h3><pre><code>方法一:select empno,ename,job,sal 涨前,       case job when &apos;PRESIDENT&apos; then sal+1000                when &apos;MANAGER&apos; then sal+800                else sal+400        end 涨后from emp;   方法二:select empno,ename,job,sal 涨前,       decode(job,&apos;PRESIDENT&apos;,sal+1000,                  &apos;MANAGER&apos;,sal+800,                          sal+400) 涨后from emp;查询结果:  EMPNO ENAME    JOB             涨前       涨后      ---------- -------- --------- ---------- ----------        7499 ALLEN    SALESMAN        1600       2000  7521 WARD     SALESMAN        1250       1650  7566 JONES    MANAGER         2975       3775   7654 MARTIN   SALESMAN        1250       1650  7698 BLAKE    MANAGER         2850       3650    7782 CLARK    MANAGER         2450       3250</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;大小写转换-lower-upper-initcap&quot;&gt;&lt;a href=&quot;#大小写转换-lower-upper-initcap&quot; class=&quot;headerlink&quot; title=&quot;大小写转换(lower,upper,initcap)&quot;&gt;&lt;/a&gt;大小写转换(lowe
      
    
    </summary>
    
      <category term="oracle" scheme="http://yoursite.com/categories/oracle/"/>
    
    
      <category term="oracle" scheme="http://yoursite.com/tags/oracle/"/>
    
      <category term="oracle sql" scheme="http://yoursite.com/tags/oracle-sql/"/>
    
      <category term="oracle 单行函数" scheme="http://yoursite.com/tags/oracle-%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>oracle函数</title>
    <link href="http://yoursite.com/2018/12/13/oracle-function1/"/>
    <id>http://yoursite.com/2018/12/13/oracle-function1/</id>
    <published>2018-12-13T08:00:00.000Z</published>
    <updated>2018-12-14T10:01:04.239Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数的分类"><a href="#函数的分类" class="headerlink" title="函数的分类:"></a>函数的分类:</h3><p><img src="http://img.my.csdn.net/uploads/201110/10/0_131826375131Cn.gif" alt="danfunction"></p><h3 id="单行函数分为五种类型：字符函数、数值函数、日期函数、转换函数、通用函数"><a href="#单行函数分为五种类型：字符函数、数值函数、日期函数、转换函数、通用函数" class="headerlink" title="单行函数分为五种类型：字符函数、数值函数、日期函数、转换函数、通用函数"></a>单行函数分为五种类型：字符函数、数值函数、日期函数、转换函数、通用函数</h3><p><img src="http://img.my.csdn.net/uploads/201110/10/0_13182638853OpP.gif" alt="danfunction"></p><h3 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数:"></a>单行函数:</h3><h4 id="大小写控制函数"><a href="#大小写控制函数" class="headerlink" title="大小写控制函数"></a>大小写控制函数</h4><p>select lower(‘Hello World’) 转小写, upper(‘Hello World’) 转大写 from dual;<br>–initcap: 首字母大写<br>select initcap(‘hello world’) 首字符大写 from dual;  </p><h4 id="字符控制函数"><a href="#字符控制函数" class="headerlink" title="字符控制函数"></a>字符控制函数</h4><p>– concat: 字符连接函数, 等同于  ||<br>select concat(‘Hello’,’ World’) from dual;<br>–substr:求母串中的某个子串<br>select substr(‘Hello World’,3) from dual;<br>select substr(‘Hello World’,3,4) from dual;<br>–length和lengthb: 字符数和字节数<br>select length(‘China’) 字符数, lengthb(‘China’) 字节数  from dual;<br>–instr:在母串中，查找子串的位置<br>select instr(‘Hello World’,’ll’) from dual;<br>–lpad,rpad: 左右填充,将abcd用<em>填充到10位<br>select lpad(‘abcd’,10,’</em>‘) 左填充, rpad(‘abcd’,10,’<em>‘) 右填充 from dual;<br>–trim: 去掉字符串前后指定的字符<br>select trim(‘H’ from ‘Hello WorldH’) from dual;<br>–replace:字符串替换函数<br>select replace(‘Hello Wordl’,’l’,’</em>‘) from dual;  </p><h4 id="数字函数"><a href="#数字函数" class="headerlink" title="数字函数"></a>数字函数</h4><p>select round(45.926,2) 四舍五入, trunc(45.926,2)  截断 ,mod(1600,300) 求于 from dual;<br>–ROUND函数<br>select round(45.923,0) 整数位, round(45.923,-1) 十位,round(45.923,-2) 百位 from dual;  </p><h4 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h4><p>–显示当前日期<br>select sysdate from dual;<br>–显示时间部分<br>select to_char(sysdate,’yyyy-mm-dd hh24:mi:ss’) from dual;<br>–显示昨天，今天和明天，加减数字仍未日期<br>select sysdate-1 昨天, sysdate 今天, sysdate+1 明天 from dual;<br>–两个日期相减，结果为相差的天数，查询员工信息，显示员工工龄。两个日期不能相加<br>select empno,ename, sysdate-hiredate 天 from emp;<br>–查询员工信息，显示员工工龄,分别按照天，星期，月显示<br>select empno,ename,sysdate-hiredate 天,(sysdate-hiredate)/7 星期, (sysdate-hiredate)/30 月 from emp;<br>–months_between:两个日期相差的月数<br>select (sysdate-hiredate)/30 方式一, months_between(sysdate,hiredate) 方式二 from emp;<br>–add_months:在指定日期上加上若干个月<br>select add_months(sysdate,1)  下个月, add_months(sysdate,123) “123个月后” from dual<br>–last_day: 某个日期当月的最后一天<br>select last_day(sysdate) from dual;<br>–next_day:下周六<br>select next_day(sysdate,’星期五’) from dual;<br>–对日期进行四舍五入<br>select round(sysdate,’MONTH’)  月,round(sysdate,’YEAR’) from dual;<br>–对日期进行截断<br>select trunc(sysdate,’MONTH’)  月,trunc(sysdate,’YEAR’) from dual;<br>–日期格式<br>select * from emp where hiredate=to_date(‘1982-01-23’,’yyyy-mm-dd’);<br>– 查询当前日期：显示:  2011-09-17 15:12:15今天是星期六<br>select to_char(sysdate,’yyyy-mm-dd hh24:mi:ss”今天是”day’) from dual;<br>–查询员工信息，显示员工的编号，姓名，月薪,要求有货币代码(L)，千位符(,)，小数点(.),<br>select empno,ename,to_char(sal,’L9,999.99’) from emp;<br>–大小写控制函数<br>select lower(‘Hello World’) 转小写, upper(‘Hello World’) 转大写 from dual;<br>–initcap: 首字母大写<br>select initcap(‘hello world’) 首字符大写 from dual;  </p><h4 id="通用函数"><a href="#通用函数" class="headerlink" title="通用函数"></a>通用函数</h4><p>–nvl(exp1,exp2):当exp1为空时，返回exp2<br>–nvl2(exp1,exp2,exp3):当exp1为空时，返回exp3；否则返回exp2<br>select ename,sal*12+nvl2(comm,comm,0) 年收入 from emp;<br>–NULLIF (expr1, expr2),如果expr1=expr2,返回null;否则,返回expr1<br>select nullif(‘abc’,’abc’) from dual;<br>select nullif(‘abc’,’abcaa’) from dual;<br>–COALESCE :找到参数列表中，第一个不为空的值<br>select ename,comm,sal,COALESCE(comm,sal) from emp;<br>–给员工涨工资,根据职位涨，总裁涨1000，经理涨600 其他人员涨400<br>select ename,job,sal 涨前工资,<br>case job when ‘PRESIDENT’ then sal+1000  when ‘MANAGER’   then sal+600  else sal+400<br> end 涨后工资<br>from emp;  </p><p>select ename,job,sal 涨前工资, decode(job,’PRESIDENT’,sal+1000,’MANAGER’,sal+600,sal+400) 涨后工资  </p><h4 id="转换函数-Conversion-Functions"><a href="#转换函数-Conversion-Functions" class="headerlink" title="转换函数(Conversion Functions)"></a>转换函数(Conversion Functions)</h4><p>转换函数将指定字符从一种类型转换为另一种，通常这类函数遵循如下惯例：函数名称后面跟着待转换类型以及输出类型。</p><p>1、TO_CHAR() 本函数又可以分三小类，分别是<br> 转换字符-&gt;字符TO_CHAR(c)：将nchar,nvarchar2,clob,nclob类型转换为char类型；<br>例如：SELECT TO_CHAR(‘AABBCC’) FROM DUAL;</p><p>转换时间-&gt;字符TO_CHAR(d[,fmt])：将指定的时间(data,timestamp,timestamp with time zone)按照指定格式转换为varchar2类型；<br>例如：SELECT TO_CHAR(sysdate,’yyyy-mm-dd hh24:mi:ss’) FROM DUAL;</p><p>转换数值-&gt;字符TO_CHAR(n[,fmt])：将指定数值n按照指定格式fmt转换为varchar2类型并返回；<br>例如：SELECT TO_CHAR(-100, ‘L99G999D99MI’) FROM DUAL;</p><p>2、TO_DATE(c[,fmt[,nls]]) 将char,nchar,varchar2,nvarchar2转换为日期类型，如果fmt参数不为空，则按照fmt中指定格式进行转换。注意这里的fmt参数。如果ftm为’J’则表示按照公元制(Julian day)转换，c则必须为大于0并小于5373484的正整数。<br>例如：<br>SELECT TO_DATE(2454336, ‘J’) FROM DUAL;<br>SELECT TO_DATE(‘2007-8-23 23:25:00’, ‘yyyy-mm-dd hh24:mi:ss’) FROM DUAL;</p><p>为什么公元制的话，c的值必须不大于5373484呢？因为Oracle的DATE类型的取值范围是公元前4712年1月1日至公元9999年12月31日。看看下面这个语句：<br>SELECT TO_CHAR(TO_DATE(‘9999-12-31’,’yyyy-mm-dd’),’j’) FROM DUAL;</p><p>3、TO_NUMBER(c[,fmt[,nls]]) 将char,nchar,varchar2,nvarchar2型字串按照fmt中指定格式转换为数值类型并返回。<br>例如：SELECT TO_NUMBER(‘-100.00’, ‘9G999D99’) FROM DUAL; </p><h3 id="其它辅助函数-Miscellaneous-Single-Row-Functions"><a href="#其它辅助函数-Miscellaneous-Single-Row-Functions" class="headerlink" title="其它辅助函数(Miscellaneous Single-Row Functions)"></a>其它辅助函数(Miscellaneous Single-Row Functions)</h3><p>1、DECODE(exp,s1,r1,s2,r2..s,r[,def]) 可以把它理解成一个增强型的if else，只不过它并不通过多行语句，而是在一个函数内实现if else的功能。<br>exp做为初始参数。s做为对比值，相同则返回r，如果s有多个，则持续遍历所有s，直到某个条件为真为止，否则返回默认值def(如果指定了的话)，如果没有默认值，并且前面的对比也都没有为真，则返回空。<br>毫无疑问，decode是个非常重要的函数，在实现行转列等功能时都会用到，需要牢记和熟练使用。</p><p>例如：select decode(‘a2’,’a1’,’true1’,’a2’,’true2’,’default’) from dual;</p><p>2、GREATEST(n1,n2,…n) 返回序列中的最大值<br>例如：SELECT GREATEST(15,5,75,8) “Greatest” FROM DUAL;</p><p>3、LEAST(n1,n2….n) 返回序列中的最小值<br>例如：SELECT LEAST(15,5,75,8) LEAST FROM DUAL;</p><p>4、NULLIF(c1,c2)<br>Nullif也是个很有意思的函数。逻辑等价于：CASE WHEN c1 = c2 THEN NULL ELSE c1 END<br>例如：SELECT NULLIF(‘a’,’b’),NULLIF(‘a’,’a’) FROM DUAL;</p><p>5、NVL(c1,c2) 逻辑等价于IF c1 is null THEN c2 ELSE c1 END。c1,c2可以是任何类型。如果两者类型不同，则oracle会自动将c2转换为c1的类型。<br>例如：SELECT NVL(null, ‘12’) FROM DUAL;</p><p>6、NVL2(c1,c2,c3) 大家可能都用到nvl，但你用过nvl2吗？如果c1非空则返回c2,如果c1为空则返回c3<br>例如：select nvl2(‘a’, ‘b’, ‘c’) isNull,nvl2(null, ‘b’, ‘c’) isNotNull from dual;</p><p>7、SYS_CONNECT_BY_PATH(col,c) 该函数只能应用于树状查询。返回通过c1连接的从根到节点的路径。该函数必须与connect by 子句共同使用。</p><h3 id="多行函数"><a href="#多行函数" class="headerlink" title="多行函数"></a>多行函数</h3><p>和单行函数相比，oracle提供了丰富的基于组的，多行的函数。这些函数能在select或select的having子句中使用，当用于select子串时常常都和GROUP BY一起使用。多行函数分为接收多个输入，返回一个输出</p><p>–求员工的工资总和<br>select sum(sal) from emp;<br>–求个数<br>select count(<em>) from emp;<br>–求平均工资<br>select sum(sal)/count(</em>) 方式一, avg(sal) 方式二 from emp;<br>–关于空值：组函数会自动滤空<br>select count(*), count(comm) from emp;<br>–max和min：求最高工资和最低工资<br>select max(sal) 最高工资,min(sal) 最低工资 from emp;<br>–分组数据：求各个部门的平均工资<br>select deptno,avg(sal) from emp group by deptno;<br>–group by作用于多列： 按部门，不同的工种，统计平均工资<br>–group by作用于多列：先按照第一列分组；如果相同，再按照第二列分组<br>select deptno,job,avg(sal) from emp group by deptno,job;<br>–：求部门的平均工资大于2000的部门<br>select deptno,avg(sal) from emp group by deptno having avg(sal)&gt;2000;<br>–group by的增强<br>select deptno,job,sum(sal) from emp group by rollup(deptno,job);<br>–不同的deptno空两行/取消设置<br>break on deptno skip 2/break on null  </p><p>转载：<a href="https://blog.csdn.net/lailai186/article/" target="_blank" rel="noopener">https://blog.csdn.net/lailai186/article/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;函数的分类&quot;&gt;&lt;a href=&quot;#函数的分类&quot; class=&quot;headerlink&quot; title=&quot;函数的分类:&quot;&gt;&lt;/a&gt;函数的分类:&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://img.my.csdn.net/uploads/201110/10/0_131
      
    
    </summary>
    
      <category term="oracle" scheme="http://yoursite.com/categories/oracle/"/>
    
    
      <category term="oracle" scheme="http://yoursite.com/tags/oracle/"/>
    
      <category term="oracle sql" scheme="http://yoursite.com/tags/oracle-sql/"/>
    
      <category term="oracle 函数" scheme="http://yoursite.com/tags/oracle-%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>redis高级篇</title>
    <link href="http://yoursite.com/2018/12/12/redis3/"/>
    <id>http://yoursite.com/2018/12/12/redis3/</id>
    <published>2018-12-12T10:15:42.000Z</published>
    <updated>2018-12-13T07:45:05.677Z</updated>
    
    <content type="html"><![CDATA[<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>Redis的高性能是由于其将所有数据都存储在了内存中<br>为了使Redis在重启之后仍能保证数据不丢失，需要将数据从内存中同步到硬盘中，<br>这一过程就是持久化。<br>Redis支持两种方式的持久化，一种是RDB方式，一种是AOF方式。可以单独使用其中一种或将二者结合使用。</p><h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>RDB方式的持久化是通过快照（snapshotting）完成的，当符合一定条件时Redis会自动将内存中的数据进行快照并持久化到硬盘。<br>RDB是Redis默认采用的持久化方式，在redis.conf配置文件中默认有此下配置：</p><p>save 900 1<br>save 300 10<br>save 60 10000</p><p>save 开头的一行就是持久化配置，可以配置多个条件（每行配置一个条件），每个条件之间是“或”的关系，“save 900 1”表示15分钟（900秒钟）内至少1个键被更改则进行快照，“save 300 10”表示5分钟（300秒）内至少10个键被更改则进行快照。</p><p>在redis.conf中：<br>配置dir指定rdb快照文件的位置<br>配置dbfilenam指定rdb快照文件的名称</p><p>Redis启动后会读取RDB快照文件，将数据从硬盘载入到内存。根据数据量大小与结构和服务器性能不同，这个时间也不同。通常将记录一千万个字符串类型键、大小为1GB的快照文件载入到内存中需要花费20～30秒钟。</p><p>问题总结：<br>通过RDB方式实现持久化，一旦Redis异常退出，就会丢失最后一次快照以后更改的所有数据。这就需要开发者根据具体的应用场合，通过组合设置自动快照条件的方式来将可能发生的数据损失控制在能够接受的范围。如果数据很重要以至于无法承受任何损失，则可以考虑使用AOF方式进行持久化。</p><h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>默认情况下Redis没有开启AOF（append only file）方式的持久化，可以通过appendonly参数开启：<br>appendonly yes<br>开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬<br>盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof，可以通过appendfilename参数修改：appendfilename appendonly.aof</p><h2 id="主从复制（了解）"><a href="#主从复制（了解）" class="headerlink" title="主从复制（了解）"></a>主从复制（了解）</h2><h3 id="什么是主从复制"><a href="#什么是主从复制" class="headerlink" title="什么是主从复制"></a>什么是主从复制</h3><p>持久化保证了即使redis服务重启也会丢失数据，因为redis服务重启后会将硬盘上持久化的数据恢复到内存中，但是当redis服务器的硬盘损坏了可能会导致数据丢失，如果通过redis的主从复制机制就可以避免这种单点故障，如下图：</p><p>说明：<br>主redis中的数据有两个副本（replication）即从redis1和从redis2，即使一台redis服务器宕机其它两台redis服务也可以继续提供服务。<br>主redis中的数据和从redis上的数据保持实时同步，当主redis写入数据时通过主从复制机制会复制到两个从redis服务上。<br>只有一个主redis，可以有多个从redis。<br>主从复制不会阻塞master，在同步数据时，master 可以继续处理client 请求<br>一个redis可以即是主又是从，如下图：</p><h3 id="主从配置"><a href="#主从配置" class="headerlink" title="主从配置"></a>主从配置</h3><h4 id="主redis配置"><a href="#主redis配置" class="headerlink" title="主redis配置"></a>主redis配置</h4><p>无需特殊配置。</p><h4 id="从redis配置"><a href="#从redis配置" class="headerlink" title="从redis配置"></a>从redis配置</h4><p>修改从redis服务器上的redis.conf文件，添加slaveof 主redisip  主redis端口</p><p>上边的配置说明当前该从redis服务器所对应的主redis是192.168.101.3，端口是6379</p><h3 id="主从复制过程"><a href="#主从复制过程" class="headerlink" title="主从复制过程"></a>主从复制过程</h3><h4 id="完整复制"><a href="#完整复制" class="headerlink" title="完整复制"></a>完整复制</h4><p>在redis2.8版本之前主从复制过程如下图：</p><p>复制过程说明：</p><p>1、slave 服务启动，slave 会建立和master 的连接，发送sync 命令。<br>2、master启动一个后台进程将数据库快照保存到RDB文件中<br>注意：此时如果生成RDB文件过程中存在写数据操作会导致RDB文件和当前主redis数据不一致，所以此时master 主进程会开始收集写命令并缓存起来。<br>3、master 就发送RDB文件给slave<br>4、slave 将文件保存到磁盘上，然后加载到内存恢复<br>5、master把缓存的命令转发给slave<br>注意：后续master 收到的写命令都会通过开始建立的连接发送给slave。<br>当master 和slave 的连接断开时slave 可以自动重新建立连接。如果master 同时收到多个slave 发来的同步连接命令，只会启动一个进程来写数据库镜像，然后发送给所有slave。</p><p>完整复制的问题：</p><p>在redis2.8之前从redis每次同步都会从主redis中复制全部的数据，如果从redis是新创建的从主redis中复制全部的数据这是没有问题的，但是，如果当从redis停止运行，再启动时可能只有少部分数据和主redis不同步，此时启动redis仍然会从主redis复制全部数据，这样的性能肯定没有只复制那一小部分不同步的数据高。</p><h4 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a>部分复制</h4><p>部分复制说明：<br>从机连接主机后，会主动发起 PSYNC 命令，从机会提供 master的runid(机器标识，随机生成的一个串) 和 offset（数据偏移量，如果offset主从不一致则说明数据不同步），主机验证 runid 和 offset 是否有效， runid 相当于主机身份验证码，用来验证从机上一次连接的主机，如果runid验证未通过则，则进行全同步，如果验证通过则说明曾经同步过，根据offset同步部分数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;持久化&quot;&gt;&lt;a href=&quot;#持久化&quot; class=&quot;headerlink&quot; title=&quot;持久化&quot;&gt;&lt;/a&gt;持久化&lt;/h2&gt;&lt;p&gt;Redis的高性能是由于其将所有数据都存储在了内存中&lt;br&gt;为了使Redis在重启之后仍能保证数据不丢失，需要将数据从内存中同步到硬
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="非关系型数据库" scheme="http://yoursite.com/tags/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="缓存数据库" scheme="http://yoursite.com/tags/%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
      <category term="持久化" scheme="http://yoursite.com/tags/%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>redis完善(spring整合)篇</title>
    <link href="http://yoursite.com/2018/12/12/redis4/"/>
    <id>http://yoursite.com/2018/12/12/redis4/</id>
    <published>2018-12-12T10:15:42.000Z</published>
    <updated>2018-12-13T07:45:55.500Z</updated>
    
    <content type="html"><![CDATA[<h2 id="jedis"><a href="#jedis" class="headerlink" title="jedis"></a>jedis</h2><h3 id="jedis介绍"><a href="#jedis介绍" class="headerlink" title="jedis介绍"></a>jedis介绍</h3><p>Redis不仅是使用命令来操作，现在基本上主流的语言都有客户端支持，比如java、C、C#、C++、php、Node.js、Go等。<br>在官方网站里列一些Java的客户端，有Jedis、Redisson、Jredis、JDBC-Redis、等其中官方推荐使用Jedis和Redisson。 在企业中用的最多的就是Jedis，下面我们就重点学习下Jedis。<br>Jedis同样也是托管在github上，地址：<a href="https://github.com/xetorthio/jedis" target="_blank" rel="noopener">https://github.com/xetorthio/jedis</a> </p><h3 id="通过jedis连接redis单机"><a href="#通过jedis连接redis单机" class="headerlink" title="通过jedis连接redis单机"></a>通过jedis连接redis单机</h3><h4 id="jar包"><a href="#jar包" class="headerlink" title="jar包"></a>jar包</h4><p>pom坐标：</p><pre><code>&lt;dependency&gt;        &lt;groupId&gt;redis.clients&lt;/groupId&gt;        &lt;artifactId&gt;jedis&lt;/artifactId&gt;        &lt;version&gt;2.7.0&lt;/version&gt;    &lt;/dependency&gt;</code></pre><h4 id="单实例连接"><a href="#单实例连接" class="headerlink" title="单实例连接"></a>单实例连接</h4><p>通过创建单实例jedis对象连接redis服务，如下代码：</p><pre><code>// 单实例连接redis@Testpublic void testJedisSingle() {Jedis jedis = new Jedis(&quot;192.168.101.3&quot;, 6379);jedis.set(&quot;name&quot;, &quot;bar&quot;);String name = jedis.get(&quot;name&quot;);System.out.println(name);jedis.close();}</code></pre><h4 id="连接超时解决"><a href="#连接超时解决" class="headerlink" title="连接超时解决"></a>连接超时解决</h4><p>由于linux防火墙默认开启，redis的服务端口6379并不在开放规则之内，所有需要将此端口开放访问或者关闭防火墙。</p><p>关闭防火墙命令：</p><pre><code>sevice iptables stop</code></pre><p>如果是修改防火墙规则，可以修改：</p><pre><code>/etc/sysconfig/iptables文件</code></pre><h4 id="使用连接池连接"><a href="#使用连接池连接" class="headerlink" title="使用连接池连接"></a>使用连接池连接</h4><p>通过单实例连接redis不能对redis连接进行共享，可以使用连接池对redis连接进行共享，提高资源利用率，使用jedisPool连接redis服务，如下代码：</p><pre><code>@Testpublic void pool() {    JedisPoolConfig config = new JedisPoolConfig();    //最大连接数    config.setMaxTotal(30);    //最大连接空闲数    config.setMaxIdle(2);    JedisPool pool = new JedisPool(config, &quot;192.168.101.3&quot;, 6379);    Jedis jedis = null;    try  {        jedis = pool.getResource();        jedis.set(&quot;name&quot;, &quot;lisi&quot;);        String name = jedis.get(&quot;name&quot;);        System.out.println(name);    }catch(Exception ex){        ex.printStackTrace();    }finally{        if(jedis != null){            //关闭连接            jedis.close();        }    }}</code></pre><h4 id="jedis与spring整合"><a href="#jedis与spring整合" class="headerlink" title="jedis与spring整合"></a>jedis与spring整合</h4><p>配置spring配置文件applicationContext.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans     http://www.springframework.org/schema/beans/spring-beans-3.2.xsd     http://www.springframework.org/schema/mvc     http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd     http://www.springframework.org/schema/context     http://www.springframework.org/schema/context/spring-context-3.2.xsd     http://www.springframework.org/schema/aop     http://www.springframework.org/schema/aop/spring-aop-3.2.xsd     http://www.springframework.org/schema/tx     http://www.springframework.org/schema/tx/spring-tx-3.2.xsd &quot;&gt;    连接池配置    &lt;bean id=&quot;jedisPoolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt;    &lt;!-- 最大连接数 --&gt;    &lt;property name=&quot;maxTotal&quot; value=&quot;30&quot; /&gt;    &lt;!-- 最大空闲连接数 --&gt;    &lt;property name=&quot;maxIdle&quot; value=&quot;10&quot; /&gt;    &lt;!-- 每次释放连接的最大数目 --&gt;    &lt;property name=&quot;numTestsPerEvictionRun&quot; value=&quot;1024&quot; /&gt;    &lt;!-- 释放连接的扫描间隔（毫秒） --&gt;    &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;30000&quot; /&gt;    &lt;!-- 连接最小空闲时间 --&gt;    &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;1800000&quot; /&gt;    &lt;!-- 连接空闲多久后释放, 当空闲时间&gt;该值 且 空闲连接&gt;最大空闲连接数 时直接释放 --&gt;    &lt;property name=&quot;softMinEvictableIdleTimeMillis&quot; value=&quot;10000&quot; /&gt;    &lt;!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 --&gt;    &lt;property name=&quot;maxWaitMillis&quot; value=&quot;1500&quot; /&gt;    &lt;!-- 在获取连接的时候检查有效性, 默认false --&gt;    &lt;property name=&quot;testOnBorrow&quot; value=&quot;true&quot; /&gt;    &lt;!-- 在空闲时检查有效性, 默认false --&gt;    &lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot; /&gt;    &lt;!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true --&gt;    &lt;property name=&quot;blockWhenExhausted&quot; value=&quot;false&quot; /&gt;&lt;/bean&gt;&lt;!-- redis单机 通过连接池 --&gt;&lt;bean id=&quot;jedisPool&quot; class=&quot;redis.clients.jedis.JedisPool&quot; destroy-method=&quot;close&quot;&gt;    &lt;constructor-arg name=&quot;poolConfig&quot; ref=&quot;jedisPoolConfig&quot;/&gt;    &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.145&quot;/&gt;    &lt;constructor-arg name=&quot;port&quot; value=&quot;6379&quot;/&gt;&lt;/bean&gt;&lt;/beans&gt;</code></pre><p>测试代码：</p><pre><code>private ApplicationContext applicationContext;@Beforepublic void init() {    applicationContext = new ClassPathXmlApplicationContext(            &quot;classpath:applicationContext.xml&quot;);}@Testpublic void testJedisPool() {JedisPool pool = (JedisPool) applicationContext.getBean(&quot;jedisPool&quot;);        try  {        Jedis jedis = pool.getResource();        jedis.set(&quot;name&quot;, &quot;lisi&quot;);        String name = jedis.get(&quot;name&quot;);        System.out.println(name);    }catch(Exception ex){        ex.printStackTrace();    }finally{        if(jedis != null){            //关闭连接            jedis.close();        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;jedis&quot;&gt;&lt;a href=&quot;#jedis&quot; class=&quot;headerlink&quot; title=&quot;jedis&quot;&gt;&lt;/a&gt;jedis&lt;/h2&gt;&lt;h3 id=&quot;jedis介绍&quot;&gt;&lt;a href=&quot;#jedis介绍&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="spring-redis" scheme="http://yoursite.com/categories/spring-redis/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>redis基础篇</title>
    <link href="http://yoursite.com/2018/12/12/redis1/"/>
    <id>http://yoursite.com/2018/12/12/redis1/</id>
    <published>2018-12-12T10:15:42.000Z</published>
    <updated>2018-12-13T07:43:32.693Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis介绍"><a href="#redis介绍" class="headerlink" title="redis介绍"></a>redis介绍</h1><h2 id="1-什么是NoSQL"><a href="#1-什么是NoSQL" class="headerlink" title="1.什么是NoSQL?"></a>1.什么是NoSQL?</h2><p>NoSQL，泛指非关系型的数据库，NoSQL即Not-Only SQL，它可以作为关系型数据库的良好补充。随着互联网web2.0网站的兴起，非关系型的数据库现在成了一个极其热门的新领域，非关系数据库产品的发展非常迅速。而传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，例如： </p><p>1、High performance - 对数据库高并发读写的需求<br>web2.0网站要根据用户个性化信息来实时生成动态页面和提供动态信息，所以基本上无法使用动态页面静态化技术，因此数据库并发负载非常高，往往要达到每秒上万次读写请求。关系数据库应付上万次SQL查询还勉强顶得住，但是应付上万次SQL写数据请求，硬盘IO就已经无法承受了。其实对于普通的BBS网站，往往也存在对高并发写请求的需求，例如网站的实时统计在线用户状态，记录热门帖子的点击次数，投票计数等，因此这是一个相当普遍的需求。</p><p>2、Huge Storage - 对海量数据的高效率存储和访问的需求<br>类似Facebook，twitter，Friendfeed这样的SNS网站，每天用户产生海量的用户动态，以Friendfeed为例，一个月就达到了2.5亿条用户动态，对于关系数据库来说，在一张2.5亿条记录的表里面进行SQL查询，效率是极其低下乃至不可忍受的。再例如大型web网站的用户登录系统，例如腾讯，盛大，动辄数以亿计的帐号，关系数据库也很难应付。 </p><p>3、High Scalability &amp;&amp; High Availability- 对数据库的高可扩展性和高可用性的需求<br>在基于web的架构当中，数据库是最难进行横向扩展的，当一个应用系统的用户量和访问量与日俱增的时候，你的数据库却没有办法像web server和app server那样简单的通过添加更多的硬件和服务节点来扩展性能和负载能力。对于很多需要提供24小时不间断服务的网站来说，对数据库系统进行升级和扩展是非常痛苦的事情，往往需要停机维护和数据迁移，为什么数据库不能通过不断的添加服务器节点来实现扩展呢？ </p><pre><code>NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。</code></pre><p>一些主流的NOSQL产品：</p><p>NoSQL数据库的四大分类如下：</p><h3 id="键值-Key-Value-存储数据库"><a href="#键值-Key-Value-存储数据库" class="headerlink" title="键值(Key-Value)存储数据库:"></a>键值(Key-Value)存储数据库:</h3><p>相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB<br>典型应用： 内容缓存，主要用于处理大量数据的高访问负载。<br>数据模型： 一系列键值对<br>优势： 快速查询<br>劣势： 存储的数据缺少结构化</p><h3 id="列存储数据库："><a href="#列存储数据库：" class="headerlink" title="列存储数据库："></a>列存储数据库：</h3><p>相关产品：Cassandra, HBase, Riak<br>典型应用：分布式的文件系统<br>数据模型：以列簇式存储，将同一列数据存在一起<br>优势：查找速度快，可扩展性强，更容易进行分布式扩展<br>劣势：功能相对局限</p><h3 id="文档型数据库："><a href="#文档型数据库：" class="headerlink" title="文档型数据库："></a>文档型数据库：</h3><p>相关产品：CouchDB、MongoDB<br>典型应用：Web应用（与Key-Value类似，Value是结构化的）<br>数据模型： 一系列键值对<br> 优势：数据结构要求不严格<br> 劣势： 查询性能不高，而且缺乏统一的查询语法</p><h3 id="图形-Graph-数据库："><a href="#图形-Graph-数据库：" class="headerlink" title="图形(Graph)数据库："></a>图形(Graph)数据库：</h3><p>相关数据库：Neo4J、InfoGrid、Infinite Graph<br>典型应用：社交网络<br>数据模型：图结构<br>优势：利用图结构相关算法。<br>劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。</p><h2 id="2-redis历史发展"><a href="#2-redis历史发展" class="headerlink" title="2.redis历史发展"></a>2.redis历史发展</h2><p>2008年，意大利的一家创业公司Merzia推出了一款基于MySQL的网站实时统计系统LLOOGG，然而没过多久该公司的创始人 Salvatore Sanfilippo便 对MySQL的性能感到失望，于是他决定亲自为LLOOGG量身定做一个数据库，并于2009年开发完成，这个数据库就是Redis。 不过Salvatore Sanfilippo并不满足只将Redis用于LLOOGG这一款产品，而是希望更多的人使用它，于是在同一年Salvatore Sanfilippo将Redis开源发布，并开始和Redis的另一名主要的代码贡献者Pieter Noordhuis一起继续着Redis的开发，直到今天。<br>Salvatore Sanfilippo自己也没有想到，短短的几年时间，Redis就拥有了庞大的用户群体。Hacker News在2012年发布了一份数据库的使用情况调查，结果显示有近12%的公司在使用Redis。国内如新浪微博、街旁网、知乎网，国外如GitHub、Stack Overflow、Flickr等都是Redis的用户。<br>    VMware公司从2010年开始赞助Redis的开发， Salvatore Sanfilippo和Pieter Noordhuis也分别在3月和5月加入VMware，全职开发Redis。</p><h2 id="3-什么是redis"><a href="#3-什么是redis" class="headerlink" title="3.什么是redis"></a>3.什么是redis</h2><p>Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库。</p><p>它通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如<br>下：</p><p>字符串类型<br>散列类型<br>列表类型<br>集合类型<br>有序集合类型。<br>3.4redis的应用场景<br>缓存（数据查询、短连接、新闻内容、商品内容等等）。（最多使用）<br>分布式集群架构中的session分离。<br>聊天室的在线好友列表。<br>任务队列。（秒杀、抢购、12306等等）<br>应用排行榜。<br>网站访问统计。<br>数据过期处理（可以精确到毫秒）</p><h2 id="4-测试环境"><a href="#4-测试环境" class="headerlink" title="4.测试环境"></a>4.测试环境</h2><pre><code>redis需要安装在linux服务器上运行测试，本教程使用 linux虚拟机及ssh客户端进行功能测试。</code></pre><h3 id="4-1-虚拟机"><a href="#4-1-虚拟机" class="headerlink" title="4.1 虚拟机"></a>4.1 虚拟机</h3><pre><code>创建Centos6.4虚拟机作为linux服务器。虚拟机ip：192.168.93.88</code></pre><h3 id="4-2-ssh客户端"><a href="#4-2-ssh客户端" class="headerlink" title="4.2 ssh客户端"></a>4.2 ssh客户端</h3><pre><code>在开发环境(windows)安装ssh客户端，本教程使用SecureCRT作为ssh客户端连接虚拟机。</code></pre><h2 id="5-安装运行redis"><a href="#5-安装运行redis" class="headerlink" title="5.安装运行redis"></a>5.安装运行redis</h2><h3 id="5-1redis安装环境"><a href="#5-1redis安装环境" class="headerlink" title="5.1redis安装环境"></a>5.1redis安装环境</h3><pre><code>redis是C语言开发，建议在linux上运行，本教程使用Centos6.4作为安装环境。安装redis需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境，需要安装gcc：yum install gcc-c++</code></pre><h3 id="5-2redis安装"><a href="#5-2redis安装" class="headerlink" title="5.2redis安装"></a>5.2redis安装</h3><pre><code>版本说明本教程使用redis3.0版本。3.0版本主要增加了redis集群功能。源码下载从官网下载 http://download.redis.io/releases/redis-3.0.0.tar.gz将redis-3.0.0.tar.gz拷贝到/usr/local下解压源码       tar -zxvf redis-3.0.0.tar.gz 进入解压后的目录进行编译cd /usr/local/redis-3.0.0make安装到指定目录,如 /usr/local/rediscd /usr/local/redis-3.0.0 make PREFIX=/usr/local/redis installredis.confredis.conf是redis的配置文件，redis.conf在redis源码目录。注意修改port作为redis进程的端口,port默认6379。拷贝配置文件到安装目录下    进入源码目录，里面有一份配置文件 redis.conf，然后将其拷贝到安装路径下 cd /usr/local/redismkdir confcp /usr/local/redis-3.0.0/redis.conf  /usr/local/redis/bin安装目录bin下的文件列表redis3.0新增的redis-sentinel是redis集群管理工具可实现高可用。</code></pre><h3 id="5-3-redis启动"><a href="#5-3-redis启动" class="headerlink" title="5.3 redis启动"></a>5.3 redis启动</h3><p>5.3.1前端模式启动</p><pre><code>直接运行bin/redis-server将以前端模式启动，前端模式启动的缺点是ssh命令窗口关闭则redis-server程序结束，不推荐使用此方法。</code></pre><p>5.3.2后端模式启动</p><pre><code>修改redis.conf配置文件， daemonize yes 以后端模式启动。执行如下命令启动redis：cd /usr/local/redis./bin/redis-server ./redis.confredis默认使用6379端口。也可更改redis.conf文件，修改端口号：</code></pre><p>5.3.3启动多个redis进程</p><pre><code>方法1：启动时指定端口可在一台服务器启动多个redis进程。cd /usr/local/redis/bin./redis-server ./redis.conf --port 6380方法2(推荐此方法)：创建多个redis目录，以端口号命名，比如：创建6379、6380两个目录，redis的安装文件bin和conf拷贝至这两个目录。修改6379目录下的redis.conf设置端口号为6379修改6380目录下的redis.conf设置端口号为6380启动6379和6380目录下的redis-server程序：cd 6379./redis-server . /redis.confcd 6380./redis-server . /redis.conf查询当前redis的进程：ps aux | grep redis</code></pre><h3 id="5-4redis停止"><a href="#5-4redis停止" class="headerlink" title="5.4redis停止"></a>5.4redis停止</h3><pre><code>强行终止Redis进程可能会导致redis持久化数据丢失。正确停止Redis的方式应该是向Redis发送SHUTDOWN命令，方法为：cd /usr/local/redis./bin/redis-cli shutdown</code></pre><h3 id="5-5redis客户端"><a href="#5-5redis客户端" class="headerlink" title="5.5redis客户端"></a>5.5redis客户端</h3><pre><code>在redis的安装目录中有redis的客户端，即redis-cli（Redis Command Line Interface），它是Redis自带的基于命令行的Redis客户端。</code></pre><p>5.5.1连接redis服务端</p><pre><code>执行bin/redis-cli连接redis服务端：从上图得知redis-cli默认连接本机的redis，本机的redis没有启动则报上图中的错误。指定连接redis服务的ip和端口：</code></pre><p>5.5.2向redis服务端发送命令    </p><pre><code>redis-cli连上redis服务后，可以在命令行发送命令。ping    Redis提供了PING命令来测试客户端与Redis的连接是否正常，如果连接正常会收到回复PONGset/get    使用set和get可以向redis设置数据、获取数据。del    删除指定key的内容。    例如：del nameKeys *    查看当前库中所有的key值</code></pre><h3 id="5-6redis多数据库"><a href="#5-6redis多数据库" class="headerlink" title="5.6redis多数据库"></a>5.6redis多数据库</h3><p>5.6.1redis实例</p><pre><code>一个redis进程就是一个redis实例，一台服务器可以同时有多个redis实例，不同的redis实例提供不同的服务端口对外提供服务，每个redis实例之间互相影响。每个redis实例都包括自己的数据库，数据库中可以存储自己的数据。 </code></pre><p>5.6.2多数据库测试</p><pre><code>一个Redis实例可以包括多个数据库，客户端可以指定连接某个redis实例的哪个数据库，就好比一个mysql中创建多个数据库，客户端连接时指定连接哪个数据库。一个redis实例最多可提供16个数据库，下标从0到15，客户端默认连接第0号数据库，也可以通过select选择连接哪个数据库，如下连接1号库： 在1号库中查询上节设置的数据，结果查询不到：重新选择第0号数据库，查询数据：如果选择一个不存在数据库则会报错：注意：redis不支持修改数据库的名称，只能通过select 0、select 1...选择数据库。</code></pre><p>5.6.3注意问题</p><pre><code>在0号数据库存储数据，在1号数据库执行清空数据命令却把0号数据库的数据给清空了：建议：不同的应用系统要使用不同的redis实例而不是使用同一个redis实例下的不同数据库。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;redis介绍&quot;&gt;&lt;a href=&quot;#redis介绍&quot; class=&quot;headerlink&quot; title=&quot;redis介绍&quot;&gt;&lt;/a&gt;redis介绍&lt;/h1&gt;&lt;h2 id=&quot;1-什么是NoSQL&quot;&gt;&lt;a href=&quot;#1-什么是NoSQL&quot; class=&quot;head
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="非关系型数据库" scheme="http://yoursite.com/tags/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="缓存数据库" scheme="http://yoursite.com/tags/%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis进阶篇</title>
    <link href="http://yoursite.com/2018/12/12/redis2/"/>
    <id>http://yoursite.com/2018/12/12/redis2/</id>
    <published>2018-12-12T10:15:42.000Z</published>
    <updated>2018-12-13T07:44:10.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据类型–string"><a href="#数据类型–string" class="headerlink" title="数据类型–string"></a>数据类型–string</h2><h3 id="redis-string介绍"><a href="#redis-string介绍" class="headerlink" title="redis string介绍"></a>redis string介绍</h3><p>redis中没有使用C语言的字符串表示，而是自定义一个数据结构叫SDS（simple dynamic string）即简单动态字符串。<br>打开下载的redis源码包，找到src下的sds.h文件查看sds源码：</p><pre><code>struct sdshdr {//字符串长度unsigned int len;//buf数组中未使用的字节数量unsigned int free;//用于保存字符串char buf[];};</code></pre><p>c语言对字符串的存储是使用字符数组，遇到’\0’字符则认为字符串结束，redis的字符串可以存储任何类型的数据，因为任何类型数据都可以表示成二进制，sds结构中的char buf[]就是存储了二进制数据。<br>redis的字符串是二进制安全的，什么是二进制安全？简单理解就是存入什么数据取出的还是什么数据。redis中的sds不像c语言处理字符串那样遇到’\0’字符则认证字符串结束，它不会对存储进去的二进制数据进行处理，存入什么数据取出还是什么数据。</p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><p>SET key value:</p><pre><code>127.0.0.1:6379&gt; set test 123OK</code></pre><h4 id="取值："><a href="#取值：" class="headerlink" title="取值："></a>取值：</h4><p>GET key:</p><pre><code>127.0.0.1:6379&gt; get test&quot;123“当键不存在时返回空结果。</code></pre><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>Del key:</p><pre><code>127.0.0.1:6379&gt; del test(integer) 1</code></pre><h4 id="数值增减"><a href="#数值增减" class="headerlink" title="数值增减"></a>数值增减</h4><p>递增数字 INCR key:</p><p>当存储的字符串是整数时，Redis提供了一个实用的命令INCR，其作用是让当前键值递增，并返回递增后的值。</p><pre><code>127.0.0.1:6379&gt; incr num(integer) 1127.0.0.1:6379&gt; incr num(integer) 2127.0.0.1:6379&gt; incr num(integer) 3 </code></pre><p>增加指定的整数 INCRBY key increment:</p><pre><code>127.0.0.1:6379&gt; incrby num 2(integer) 5127.0.0.1:6379&gt; incrby num 2(integer) 7127.0.0.1:6379&gt; incrby num 2(integer) 9 </code></pre><p>递减数值:</p><pre><code>DECR key</code></pre><h4 id="其它命令"><a href="#其它命令" class="headerlink" title="其它命令"></a>其它命令</h4><p>减少指定的整数 :<br>DECRBY key decrement</p><pre><code>127.0.0.1:6379&gt; decr num(integer) 6127.0.0.1:6379&gt; decr num(integer) 5127.0.0.1:6379&gt; decrby num 3(integer) 2127.0.0.1:6379&gt; decrby num 3(integer) -1 </code></pre><p>向尾部追加值 :<br>APPEND key value<br>APPEND的作用是向键值的末尾追加value。如果键不存在则将该键的值设置为value，即相当于 SET key value。返回值是追加后字符串的总长度。 </p><pre><code>127.0.0.1:6379&gt; set str helloOK127.0.0.1:6379&gt; append str &quot; world!&quot;(integer) 12127.0.0.1:6379&gt; get str &quot;hello world!&quot;</code></pre><p>获取字符串长度 :<br>STRLEN key<br>STRLEN命令返回键值的长度，如果键不存在则返回0。 </p><pre><code>127.0.0.1:6379&gt; strlen str (integer) 0127.0.0.1:6379&gt; set str helloOK127.0.0.1:6379&gt; strlen str (integer) 5</code></pre><p>同时设置/获取多个键值 :<br>MSET key value [key value …]<br>MGET key [key …]</p><pre><code>127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3OK127.0.0.1:6379&gt; get k1&quot;v1&quot;127.0.0.1:6379&gt; mget k1 k31) &quot;v1&quot;2) &quot;v3&quot;</code></pre><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="自增主键"><a href="#自增主键" class="headerlink" title="自增主键"></a>自增主键</h4><p>商品编号、订单号采用string的递增数字特性生成。</p><p>定义商品编号key：items:id</p><pre><code>192.168.101.3:7003&gt; INCR items:id(integer) 2192.168.101.3:7003&gt; INCR items:id(integer) 3</code></pre><h2 id="数据类型–hash"><a href="#数据类型–hash" class="headerlink" title="数据类型–hash"></a>数据类型–hash</h2><h3 id="使用string的问题"><a href="#使用string的问题" class="headerlink" title="使用string的问题"></a>使用string的问题</h3><p>假设有User对象以JSON序列化的形式存储到Redis中，User对象有id，username、password、age、name等属性，存储的过程如下：</p><p>保存、更新： </p><p>User对象  json(string)  redis </p><p>如果在业务上只是更新age属性，其他的属性并不做更新我应该怎么做呢？ 如果仍然采用上边的方法在传输、处理时会造成资源浪费，下边讲的hash可以很好的解决这个问题。</p><h3 id="redis-hash介绍"><a href="#redis-hash介绍" class="headerlink" title="redis hash介绍"></a>redis hash介绍</h3><p>hash叫散列类型，它提供了字段和字段值的映射。字段值只能是字符串类型，不支持散列类型、集合类型等其它类型。如下：</p><h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><h4 id="赋值-1"><a href="#赋值-1" class="headerlink" title="赋值"></a>赋值</h4><p>HSET key field value    一次只能设置一个字段值</p><pre><code>127.0.0.1:6379&gt; hset user username zhangsan (integer) 1</code></pre><p>HMSET key field value [field value …]        一次可以设置多个字段值</p><pre><code>127.0.0.1:6379&gt; hmset user age 20 username lisi OK</code></pre><h4 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h4><p>HGET key field            一次只能获取一个字段值</p><pre><code>127.0.0.1:6379&gt; hget user username&quot;zhangsan“</code></pre><p>HMGET key field [field …]                一次可以获取多个字段值</p><pre><code>127.0.0.1:6379&gt; hmget user age username1) &quot;20&quot;2) &quot;lisi&quot;</code></pre><p>HGETALL key</p><pre><code>127.0.0.1:6379&gt; hgetall user1) &quot;age&quot;2) &quot;20&quot;3) &quot;username&quot;4) &quot;lisi&quot;</code></pre><p>HSET命令不区分插入和更新操作，当执行插入操作时HSET命令返回1，当执行更新操作时返回0.</p><h4 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h4><p>可以删除一个或多个字段，返回值是被删除的字段个数<br>HDEL key field [field …]</p><pre><code>127.0.0.1:6379&gt; hdel user age(integer) 1127.0.0.1:6379&gt; hdel user age name(integer) 0127.0.0.1:6379&gt; hdel user age username(integer) 1 </code></pre><h4 id="增加数字"><a href="#增加数字" class="headerlink" title="增加数字"></a>增加数字</h4><pre><code>HINCRBY key field increment127.0.0.1:6379&gt; hincrby user age 2    将用户的年龄加2(integer) 22127.0.0.1:6379&gt; hget user age        获取用户的年龄&quot;22“</code></pre><h4 id="其它命令-1"><a href="#其它命令-1" class="headerlink" title="其它命令"></a>其它命令</h4><p>判断字段是否存在<br>HEXISTS key field</p><pre><code>127.0.0.1:6379&gt; hexists user age        查看user中是否有age字段(integer) 1127.0.0.1:6379&gt; hexists user name    查看user中是否有name字段(integer) 0</code></pre><p>HSETNX key field value</p><p>当字段不存在时赋值，类似HSET，区别在于如果字段已经存在，该命令不执行任何操作。</p><pre><code>127.0.0.1:6379&gt; hsetnx user age 30    如果user中没有age字段则设置age值为30，否则不做任何操作(integer) 0</code></pre><p>只获取字段名或字段值 </p><p>HKEYS key</p><p>HVALS key</p><pre><code>127.0.0.1:6379&gt; hmset user age 20 name lisi OK127.0.0.1:6379&gt; hkeys user1) &quot;age&quot;2) &quot;name&quot;127.0.0.1:6379&gt; hvals user1) &quot;20&quot;2) &quot;lisi&quot;</code></pre><p>获取字段数量<br>HLEN key</p><pre><code>127.0.0.1:6379&gt; hlen user(integer) 2</code></pre><h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><h4 id="商品信息"><a href="#商品信息" class="headerlink" title="商品信息"></a>商品信息</h4><p>商品id、商品名称、商品描述、商品库存、商品好评</p><p>定义商品信息的key：<br>商品1001的信息在 redis中的key为：items:1001</p><p>存储商品信息:</p><pre><code>192.168.101.3:7003&gt; HMSET items:1001 id 3 name apple price 999.9OK</code></pre><p>获取商品信息:</p><pre><code>192.168.101.3:7003&gt; HGET items:1001 id&quot;3&quot;.168.101.3:7003&gt; HGETALL items:10011) &quot;id&quot;2) &quot;3&quot;3) &quot;name&quot;4) &quot;apple&quot;5) &quot;price&quot;6) &quot;999.9&quot;</code></pre><h2 id="数据类型–list"><a href="#数据类型–list" class="headerlink" title="数据类型–list"></a>数据类型–list</h2><h3 id="ArrayList与LinkedList的区别"><a href="#ArrayList与LinkedList的区别" class="headerlink" title="ArrayList与LinkedList的区别"></a>ArrayList与LinkedList的区别</h3><p>ArrayList使用数组方式存储数据，所以根据索引查询数据速度快，而新增或者删除元素时需要设计到位移操作，所以比较慢。<br>LinkedList使用双向链接方式存储数据，每个元素都记录前后元素的指针，所以插入、删除数据时只是更改前后元素的指针指向即可，速度非常快，然后通过下标查询元素时需要从头开始索引，所以比较慢，但是如果查询前几个元素或后几个元素速度比较快。</p><h3 id="redis-list介绍"><a href="#redis-list介绍" class="headerlink" title="redis list介绍"></a>redis list介绍</h3><p>列表类型（list）可以存储一个有序的字符串列表，常用的操作是向列表两端添加元素，或者获得列表的某一个片段。<br>列表类型内部是使用双向链表（double linked list）实现的，所以向列表两端添加元素的时间复杂度为0(1)，获取越接近两端的元素速度就越快。这意味着即使是一个有几千万个元素的列表，获取头部或尾部的10条记录也是极快的。</p><h3 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h3><h4 id="向列表两端增加元素。"><a href="#向列表两端增加元素。" class="headerlink" title="向列表两端增加元素。"></a>向列表两端增加元素。</h4><p>LPUSH key value [value …]</p><p>RPUSH key value [value …]</p><p>向列表左边增加元素 </p><pre><code>127.0.0.1:6379&gt; lpush list:1 1 2 3(integer) 3</code></pre><p>向列表右边增加元素 </p><pre><code>127.0.0.1:6379&gt; rpush list:1 4 5 6(integer) 3</code></pre><h4 id="查看列表"><a href="#查看列表" class="headerlink" title="查看列表"></a>查看列表</h4><pre><code>LRANGE key start stop</code></pre><p>LRANGE命令是列表类型最常用的命令之一，获取列表中的某一片段，将返回start、stop之间的所有元素（包含两端的元素），索引从0开始。索引可以是负数，如：“-1”代表最后边的一个元素。 </p><pre><code>127.0.0.1:6379&gt; lrange list:1 0 21) &quot;2&quot;2) &quot;1&quot;3) &quot;4&quot;</code></pre><h4 id="从列表两端弹出元素"><a href="#从列表两端弹出元素" class="headerlink" title="从列表两端弹出元素"></a>从列表两端弹出元素</h4><p>LPOP key</p><p>RPOP key</p><p>LPOP命令从列表左边弹出一个元素，会分两步完成，第一步是将列表左边的元素从列表中移除，第二步是返回被移除的元素值。 </p><pre><code>127.0.0.1:6379&gt; lpop list:1&quot;3“127.0.0.1:6379&gt; rpop list:1&quot;6“</code></pre><h4 id="获取列表中元素的个数"><a href="#获取列表中元素的个数" class="headerlink" title="获取列表中元素的个数"></a>获取列表中元素的个数</h4><p>LLEN key</p><pre><code>127.0.0.1:6379&gt; llen list:1(integer) 2</code></pre><p>####其它命令<br>删除列表中指定的值 :</p><p>LREM key count value</p><p>LREM命令会删除列表中前count个值为value的元素，返回实际删除的元素个数。根据count值的不同，</p><p>该命令的执行方式会有所不同： </p><p>当count&gt;0时， LREM会从列表左边开始删除。 </p><p>当count&lt;0时， LREM会从列表后边开始删除。 </p><p>当count=0时， LREM删除所有值为value的元素。 </p><p>获得/设置指定索引的元素值 :</p><p>LINDEX key index</p><p>LSET key index value</p><pre><code>127.0.0.1:6379&gt; lindex l:list 2&quot;1&quot;127.0.0.1:6379&gt; lset l:list 2 2OK127.0.0.1:6379&gt; lrange l:list 0 -11) &quot;6&quot;2) &quot;5&quot;3) &quot;2&quot;4) &quot;2&quot;</code></pre><p>只保留列表指定片段，指定范围和LRANGE一致 :</p><p>LTRIM key start stop</p><pre><code>127.0.0.1:6379&gt; lrange l:list 0 -11) &quot;6&quot;2) &quot;5&quot;3) &quot;0&quot;4) &quot;2&quot;127.0.0.1:6379&gt; ltrim l:list 0 2OK127.0.0.1:6379&gt; lrange l:list 0 -11) &quot;6&quot;2) &quot;5&quot;3) &quot;0&quot;</code></pre><p>向列表中插入元素 :</p><p>LINSERT key BEFORE|AFTER pivot value<br>该命令首先会在列表中从左到右查找值为pivot的元素，<br>然后根据第二个参数是BEFORE还是AFTER来决定将value插入到该元素的前面还是后面。 </p><pre><code>127.0.0.1:6379&gt; lrange list 0 -11) &quot;3&quot;2) &quot;2&quot;3) &quot;1&quot;127.0.0.1:6379&gt; linsert list after 3 4(integer) 4127.0.0.1:6379&gt; lrange list 0 -11) &quot;3&quot;2) &quot;4&quot;3) &quot;2&quot;4) &quot;1&quot;</code></pre><p>将元素从一个列表转移到另一个列表中 :</p><p>RPOPLPUSH source destination</p><pre><code>127.0.0.1:6379&gt; rpoplpush list newlist &quot;1&quot;127.0.0.1:6379&gt; lrange newlist 0 -11) &quot;1&quot;127.0.0.1:6379&gt; lrange list 0 -11) &quot;3&quot;2) &quot;4&quot;3) &quot;2&quot; </code></pre><h3 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h3><h4 id="商品评论列表"><a href="#商品评论列表" class="headerlink" title="商品评论列表"></a>商品评论列表</h4><p>思路：</p><p>在redis中创建商品评论列表</p><p>用户发布商品评论，将评论信息转成json存储到list中。</p><p>用户在页面查询评论列表，从redis中取出json数据展示到页面。</p><p>定义商品评论列表key：</p><p>商品编号为1001的商品评论key：items: comment:1001</p><pre><code>192.168.101.3:7001&gt; LPUSH items:comment:1001 &apos;{&quot;id&quot;:1,&quot;name&quot;:&quot;商品不错，很好！！&quot;,&quot;date&quot;:1430295077289}&apos;</code></pre><h2 id="数据类型–set"><a href="#数据类型–set" class="headerlink" title="数据类型–set"></a>数据类型–set</h2><h3 id="redis-set介绍"><a href="#redis-set介绍" class="headerlink" title="redis set介绍"></a>redis set介绍</h3><p>在集合中的每个元素都是不同的，且没有顺序。</p><p>集合类型和列表类型的对比：</p><p>集合类型的常用操作是向集合中加入或删除元素、判断某个元素是否存在等，由于集合类型的Redis内部是使用值为空的散列表实现，所有这些操作的时间复杂度都为0(1)。 </p><p>Redis还提供了多个集合之间的交集、并集、差集的运算。</p><p>###命令</p><h4 id="增加-删除元素"><a href="#增加-删除元素" class="headerlink" title="增加/删除元素"></a>增加/删除元素</h4><p>SADD key member [member …]</p><p>SREM key member [member …]</p><pre><code>127.0.0.1:6379&gt; sadd set a b c(integer) 3127.0.0.1:6379&gt; sadd set a(integer) 0127.0.0.1:6379&gt; srem set c d(integer) 1</code></pre><h4 id="获得集合中的所有元素"><a href="#获得集合中的所有元素" class="headerlink" title="获得集合中的所有元素"></a>获得集合中的所有元素</h4><p>SMEMBERS key</p><pre><code>127.0.0.1:6379&gt; smembers set1) &quot;b&quot;2) &quot;a”</code></pre><p>判断元素是否在集合中，无论集合中有多少元素都可以极速的返回结果。 </p><p>SISMEMBER key member</p><pre><code>127.0.0.1:6379&gt; sismember set a(integer) 1127.0.0.1:6379&gt; sismember set h(integer) 0</code></pre><h3 id="其它命令-2"><a href="#其它命令-2" class="headerlink" title="其它命令"></a>其它命令</h3><h4 id="集合的差集运算-A-B"><a href="#集合的差集运算-A-B" class="headerlink" title="集合的差集运算 A-B"></a>集合的差集运算 A-B</h4><p>属于A并且不属于B的元素构成的集合。 </p><p>SDIFF key [key …]</p><pre><code>127.0.0.1:6379&gt; sadd setA 1 2 3(integer) 3127.0.0.1:6379&gt; sadd setB 2 3 4(integer) 3127.0.0.1:6379&gt; sdiff setA setB 1) &quot;1&quot;127.0.0.1:6379&gt; sdiff setB setA 1) &quot;4&quot;</code></pre><h4 id="集合的交集运算-A-∩-B"><a href="#集合的交集运算-A-∩-B" class="headerlink" title="集合的交集运算 A ∩ B"></a>集合的交集运算 A ∩ B</h4><p>属于A且属于B的元素构成的集合。 </p><p>SINTER key [key …]</p><pre><code>127.0.0.1:6379&gt; sinter setA setB 1) &quot;2&quot;2) &quot;3&quot;</code></pre><h4 id="集合的并集运算-A-∪-B"><a href="#集合的并集运算-A-∪-B" class="headerlink" title="集合的并集运算 A ∪ B"></a>集合的并集运算 A ∪ B</h4><p>属于A或者属于B的元素构成的集合</p><p>SUNION key [key …]</p><pre><code>127.0.0.1:6379&gt; sunion setA setB1) &quot;1&quot;2) &quot;2&quot;3) &quot;3&quot;4) &quot;4&quot;</code></pre><h4 id="其它命令-3"><a href="#其它命令-3" class="headerlink" title="其它命令"></a>其它命令</h4><p>获得集合中元素的个数 </p><p>SCARD key</p><pre><code>127.0.0.1:6379&gt; smembers setA 1) &quot;1&quot;2) &quot;2&quot;3) &quot;3&quot;127.0.0.1:6379&gt; scard setA (integer) 3</code></pre><p>从集合中弹出一个元素 </p><p>SPOP key</p><pre><code>127.0.0.1:6379&gt; spop setA &quot;1“</code></pre><p>注意：由于集合是无序的，所有SPOP命令会从集合中随机选择一个元素弹出 </p><h2 id="数据类型–sorted-set"><a href="#数据类型–sorted-set" class="headerlink" title="数据类型–sorted set"></a>数据类型–sorted set</h2><h3 id="redis-sorted-set介绍"><a href="#redis-sorted-set介绍" class="headerlink" title="redis sorted set介绍"></a>redis sorted set介绍</h3><p>在集合类型的基础上有序集合类型为集合中的每个元素都关联一个分数，这使得我们不仅可以完成插入、删除和判断元素是否存在在集合中，还能够获得分数最高或最低的前N个元素、获取指定分数范围内的元素等与分数有关的操作。 </p><p>在某些方面有序集合和列表类型有些相似。 </p><p>1、二者都是有序的。 </p><p>2、二者都可以获得某一范围的元素。 </p><p>但是，二者有着很大区别： </p><p>1、列表类型是通过链表实现的，获取靠近两端的数据速度极快，而当元素增多后，<br>访问中间数据的速度会变慢。 </p><p>2、有序集合类型使用散列表实现，所有即使读取位于中间部分的数据也很快。 </p><p>3、列表中不能简单的调整某个元素的位置，但是有序集合可以（通过更改分数实现<br>）<br>4、有序集合要比列表类型更耗内存。 </p><p>###命令</p><p>####增加元素<br>向有序集合中加入一个元素和该元素的分数，如果该元素已经存在则会用新的分数替换原有的分数。返回值是新加入到集合中的元素个数，不包含之前已经存在的元素。 </p><p>ZADD key score member [score member …]</p><pre><code>127.0.0.1:6379&gt; zadd scoreboard 80 zhangsan 89 lisi 94 wangwu (integer) 3127.0.0.1:6379&gt; zadd scoreboard 97 lisi (integer) 0</code></pre><p>获取元素的分数 </p><p>ZSCORE key member</p><pre><code>127.0.0.1:6379&gt; zscore scoreboard lisi &quot;97&quot;</code></pre><h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p>ZREM key member [member …]</p><p>移除有序集key中的一个或多个成员，不存在的成员将被忽略。</p><p>当key存在但不是有序集类型时，返回一个错误。</p><pre><code>127.0.0.1:6379&gt; zrem scoreboard lisi(integer) 1</code></pre><h4 id="获得排名在某个范围的元素列表"><a href="#获得排名在某个范围的元素列表" class="headerlink" title="获得排名在某个范围的元素列表"></a>获得排名在某个范围的元素列表</h4><p>获得排名在某个范围的元素列表 </p><p>ZRANGE key start stop [WITHSCORES]<br>照元素分数从小到大的顺序返回索引从start到stop之间的所有元素（包含两端的元素）</p><pre><code>127.0.0.1:6379&gt; zrange scoreboard 0 21) &quot;zhangsan&quot;2) &quot;wangwu&quot;3) &quot;lisi“</code></pre><p>ZREVRANGE key start stop [WITHSCORES]<br>照元素分数从大到小的顺序返回索引从start到stop之间的所有元素（包含两端的元素）</p><pre><code>127.0.0.1:6379&gt; zrevrange scoreboard 0 21) &quot; lisi &quot;2) &quot;wangwu&quot;3) &quot; zhangsan “</code></pre><p>如果需要获得元素的分数的可以在命令尾部加上WITHSCORES参数 </p><pre><code>127.0.0.1:6379&gt; zrange scoreboard 0 1 WITHSCORES1) &quot;zhangsan&quot;2) &quot;80&quot;3) &quot;wangwu&quot;4) &quot;94&quot;</code></pre><h4 id="其它命令-4"><a href="#其它命令-4" class="headerlink" title="其它命令"></a>其它命令</h4><p>获得指定分数范围的元素 </p><p>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</p><pre><code>127.0.0.1:6379&gt; ZRANGEBYSCORE scoreboard 90 97 WITHSCORES1) &quot;wangwu&quot;2) &quot;94&quot;3) &quot;lisi&quot;4) &quot;97&quot;127.0.0.1:6379&gt; ZRANGEBYSCORE scoreboard 70 100 limit 1 21) &quot;wangwu&quot;2) &quot;lisi&quot;</code></pre><p>增加某个元素的分数，返回值是更改后的分数</p><p>ZINCRBY  key increment member</p><p>给lisi加4分 </p><pre><code>127.0.0.1:6379&gt; ZINCRBY scoreboard  4 lisi &quot;101“</code></pre><p>获得集合中元素的数量 </p><p>ZCARD key</p><pre><code>127.0.0.1:6379&gt; ZCARD scoreboard(integer) 3</code></pre><p>获得指定分数范围内的元素个数 </p><p>ZCOUNT key min max</p><pre><code>127.0.0.1:6379&gt; ZCOUNT scoreboard 80 90(integer) 1</code></pre><p>按照排名范围删除元素 </p><p>ZREMRANGEBYRANK key start stop</p><pre><code>127.0.0.1:6379&gt; ZREMRANGEBYRANK scoreboard 0 1(integer) 2 127.0.0.1:6379&gt; ZRANGE scoreboard 0 -11) &quot;lisi&quot;</code></pre><p>ZREMRANGEBYSCORE key min max</p><p>按照分数范围删除元素 </p><pre><code>127.0.0.1:6379&gt; zadd scoreboard 84 zhangsan    (integer) 1127.0.0.1:6379&gt; ZREMRANGEBYSCORE scoreboard 80 100(integer) 1</code></pre><p>获取元素的排名 </p><p>ZRANK key member</p><p>ZREVRANK key member</p><p>从小到大 </p><pre><code>127.0.0.1:6379&gt; ZRANK scoreboard lisi (integer) 0</code></pre><p>从大到小 </p><pre><code>127.0.0.1:6379&gt; ZREVRANK scoreboard zhangsan (integer) 1</code></pre><h3 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h3><h4 id="商品销售排行榜"><a href="#商品销售排行榜" class="headerlink" title="商品销售排行榜"></a>商品销售排行榜</h4><p>根据商品销售量对商品进行排行显示，定义sorted set集合，商品销售量为元素的分数。</p><p>定义商品销售排行榜key：items:sellsort</p><p>写入商品销售量：</p><p>商品编号1001的销量是9，商品编号1002的销量是10</p><pre><code>192.168.101.3:7007&gt; ZADD items:sellsort 9 1001 10 1002</code></pre><p>商品编号1001的销量加1</p><pre><code>192.168.101.3:7001&gt; ZINCRBY items:sellsort 1 1001</code></pre><p>商品销量前10名：</p><pre><code>192.168.101.3:7001&gt; ZRANGE items:sellsort 0 9 withscores</code></pre><h2 id="keys命令"><a href="#keys命令" class="headerlink" title="keys命令"></a>keys命令</h2><p>###设置key的生存时间<br>Redis在实际使用过程中更多的用作缓存，然而缓存的数据一般都是需要设置生存时间的，即：到期后数据销毁。 </p><p>EXPIRE key seconds            设置key的生存时间（单位：秒）key在多少秒后会自动删除</p><p>TTL key                     查看key生于的生存时间</p><p>PERSIST key                清除生存时间 </p><p>PEXPIRE key milliseconds    生存时间设置单位为：毫秒 </p><p>例子：</p><pre><code>192.168.101.3:7002&gt; set test 1        设置test的值为1OK192.168.101.3:7002&gt; get test            获取test的值&quot;1&quot;192.168.101.3:7002&gt; EXPIRE test 5    设置test的生存时间为5秒(integer) 1192.168.101.3:7002&gt; TTL test            查看test的生于生成时间还有1秒删除(integer) 1192.168.101.3:7002&gt; TTL test(integer) -2192.168.101.3:7002&gt; get test            获取test的值，已经删除(nil)</code></pre><h3 id="其它命令（自学）"><a href="#其它命令（自学）" class="headerlink" title="其它命令（自学）"></a>其它命令（自学）</h3><p>keys 返回满足给定pattern 的所有key</p><pre><code>redis 127.0.0.1:6379&gt; keys mylist*1) &quot;mylist&quot;2) &quot;mylist5&quot;3) &quot;mylist6&quot;4) &quot;mylist7&quot;5) &quot;mylist8&quot;</code></pre><p>exists 确认一个key 是否存在</p><pre><code>redis 127.0.0.1:6379&gt; exists HongWan(integer) 0redis 127.0.0.1:6379&gt; exists age(integer) 1redis 127.0.0.1:6379&gt;</code></pre><p>从结果来数据库中不存在HongWan 这个key，但是age 这个key 是存在的</p><p>del删除一个key</p><pre><code>redis 127.0.0.1:6379&gt; del age(integer) 1redis 127.0.0.1:6379&gt; exists age(integer) 0redis 127.0.0.1:6379&gt;</code></pre><p>从结果来数据库中不存在HongWan 这个key，但是age 这个key 是存在的</p><p>rename 重命名key</p><pre><code>redis 127.0.0.1:6379[1]&gt; keys *1) &quot;age&quot;redis 127.0.0.1:6379[1]&gt; rename age age_newOKredis 127.0.0.1:6379[1]&gt; keys *1) &quot;age_new&quot;redis 127.0.0.1:6379[1]&gt;age 成功的被我们改名为age_new 了</code></pre><p>type返回值的类型</p><pre><code>redis 127.0.0.1:6379&gt; type addrstringredis 127.0.0.1:6379&gt; type myzset2zsetredis 127.0.0.1:6379&gt; type mylistlistredis 127.0.0.1:6379&gt;</code></pre><p>##服务器命令</p><p>ping测试连接是否存活</p><pre><code>redis 127.0.0.1:6379&gt; pingPONG</code></pre><p>//执行下面命令之前，我们停止redis 服务器</p><pre><code>redis 127.0.0.1:6379&gt; pingCould not connect to Redis at 127.0.0.1:6379: Connection refused</code></pre><p>//执行下面命令之前，我们启动redis 服务器</p><pre><code>not connected&gt; pingPONGredis 127.0.0.1:6379&gt;第一个ping 时，说明此连接正常第二个ping 之前，我们将redis 服务器停止，那么ping 是失败的第三个ping 之前，我们将redis 服务器启动，那么ping 是成功的</code></pre><p>echo<br>在命令行打印一些内容</p><pre><code>redis 127.0.0.1:6379&gt; echo HongWan&quot;HongWan&quot;redis 127.0.0.1:6379&gt;select</code></pre><p>选择数据库。Redis 数据库编号从0~15，我们可以选择任意一个数据库来进行数据的存取。</p><pre><code>redis 127.0.0.1:6379&gt; select 1OKredis 127.0.0.1:6379[1]&gt; select 16(error) ERR invalid DB indexredis 127.0.0.1:6379[16]&gt;当选择16 时，报错，说明没有编号为16 的这个数据库</code></pre><p>quit<br>退出连接。</p><pre><code>redis 127.0.0.1:6379&gt; quit</code></pre><p>dbsize<br>返回当前数据库中key 的数目。</p><pre><code>redis 127.0.0.1:6379&gt; dbsize(integer) 18redis 127.0.0.1:6379&gt;结果说明此库中有18 个key</code></pre><p>info<br>获取服务器的信息和统计。</p><pre><code>redis 127.0.0.1:6379&gt; inforedis_version:2.2.12redis_git_sha1:00000000redis_git_dirty:0arch_bits:32multiplexing_api:epollprocess_id:28480uptime_in_seconds:2515uptime_in_days:0</code></pre><p>flushdb<br>删除当前选择数据库中的所有key。</p><pre><code>redis 127.0.0.1:6379&gt; dbsize(integer) 18redis 127.0.0.1:6379&gt; flushdbOKredis 127.0.0.1:6379&gt; dbsize(integer) 0redis 127.0.0.1:6379&gt;在本例中我们将0 号数据库中的key 都清除了。</code></pre><p>flushall<br>删除所有数据库中的所有key。</p><pre><code>redis 127.0.0.1:6379[1]&gt; dbsize(integer) 1redis 127.0.0.1:6379[1]&gt; select 0OKredis 127.0.0.1:6379&gt; flushallOKredis 127.0.0.1:6379&gt; select 1OKredis 127.0.0.1:6379[1]&gt; dbsize(integer) 0redis 127.0.0.1:6379[1]&gt;在本例中我们先查看了一个1 号数据库中有一个key，然后我切换到0 号库执行flushall 命令，结果1 号库中的key 也被清除了，说是此命令工作正常。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据类型–string&quot;&gt;&lt;a href=&quot;#数据类型–string&quot; class=&quot;headerlink&quot; title=&quot;数据类型–string&quot;&gt;&lt;/a&gt;数据类型–string&lt;/h2&gt;&lt;h3 id=&quot;redis-string介绍&quot;&gt;&lt;a href=&quot;#red
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="非关系型数据库" scheme="http://yoursite.com/tags/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="缓存数据库" scheme="http://yoursite.com/tags/%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>springboot-redis.md</title>
    <link href="http://yoursite.com/2018/12/12/springboot-redis/"/>
    <id>http://yoursite.com/2018/12/12/springboot-redis/</id>
    <published>2018-12-12T08:26:46.000Z</published>
    <updated>2018-12-13T07:46:43.675Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-Springboot整合Redis-单机版-注解式开发"><a href="#一-Springboot整合Redis-单机版-注解式开发" class="headerlink" title="一. Springboot整合Redis(单机版 注解式开发)"></a>一. Springboot整合Redis(单机版 注解式开发)</h2><p><strong>1.引入redis起步依赖</strong></p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-redis&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p><strong>2.在虚拟机中开启redis服务</strong></p><pre><code>启动server: ./redis-server redis.conf(启动客户端测试: ./redis-cli)</code></pre><p><strong>3.在applicaction.properties中配置redis 主机和端口号(这里为我的centos中的主机名以及redis端口号，可自行配置</strong></p><pre><code>spring.redis.host=192.168.66.66spring.redis.port=6379</code></pre><p><strong>4.在启动类中加入注解@EnableCaching开启缓存</strong></p><pre><code>@EnableCaching@SpringBootApplication</code></pre><p><strong>5.在service实现类中利用@Cacheable设置缓存</strong></p><pre><code>/** * value : 缓存的名字 ,  * key ： 缓存map中的key * @param id* @return*/    @Cacheable(value = { &quot;sampleCache&quot; },key=&quot;#id&quot;)    public String getBook(int id) {        System.out.println(&quot;Method executed..&quot;);        if (id == 1) {                return &quot;Book 1&quot;;        } else {        return &quot;Book 2&quot;;        }    }</code></pre><h2 id="二-Springboot整合Redis-集群版-注解式开发"><a href="#二-Springboot整合Redis-集群版-注解式开发" class="headerlink" title="二. Springboot整合Redis(集群版 注解式开发)"></a>二. Springboot整合Redis(集群版 注解式开发)</h2><p><strong>1.在applicaction.properties中配置redis 集群</strong></p><pre><code>redis.cache.clusterNodes=192.168.66.66:7001,192.168.66.66:7002,192.168.66.66:7003,192.168.66.66:7004</code></pre><p><strong>2.自定义config对配置的集群节点进行解析</strong></p><pre><code>@Configuration //AaplicationContext.xmlpublic class RedisClusterConfig {    //注入集群节点信息    @Value(&quot;${redis.cache.clusterNodes}&quot;)     private String clusterNodes;    @Bean    public JedisCluster getJedisCluster() {    // 截取集群节点    String[] cluster = clusterNodes.split(&quot;,&quot;);    // 创建set集合    Set&lt;HostAndPort&gt; nodes = new HashSet&lt;HostAndPort&gt;();    // 循环数组把集群节点添加到set集合中    for (String node : cluster) {        String[] host = node.split(&quot;:&quot;);        //添加集群节点        nodes.add(new HostAndPort(host[0], Integer.parseInt(host[1])));    }    //创建集群节点对象    JedisCluster jc = new JedisCluster(nodes);    return jc;}</code></pre><p><strong>3.在service实现类注入REDIS集群对象并实现缓存</strong></p><pre><code>@Autowiredprivate JedisCluster jedisCluster;@Overridepublic Map&lt;String, Object&gt; redisMap() {    jedisCluster.set(&quot;user&quot;, &quot;张三丰&quot;);    String value = jedisCluster.get(&quot;user&quot;);    Map&lt;String, Object&gt; maps = newHashMap&lt;String,Object&gt;();    maps.put(&quot;redis&quot;, value);    return maps;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-Springboot整合Redis-单机版-注解式开发&quot;&gt;&lt;a href=&quot;#一-Springboot整合Redis-单机版-注解式开发&quot; class=&quot;headerlink&quot; title=&quot;一. Springboot整合Redis(单机版 注解式开发)&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="springboot-redis" scheme="http://yoursite.com/categories/springboot-redis/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
      <category term="springboot" scheme="http://yoursite.com/tags/springboot/"/>
    
  </entry>
  
</feed>
